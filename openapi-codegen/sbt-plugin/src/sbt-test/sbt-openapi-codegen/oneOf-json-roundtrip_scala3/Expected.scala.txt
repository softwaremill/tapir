package sttp.tapir.generated

object TapirGeneratedEndpoints {

  import sttp.tapir._
  import sttp.tapir.model._
  import sttp.tapir.generic.auto._
  import sttp.tapir.json.circe._
  import io.circe.generic.semiauto._

  import sttp.tapir.generated.TapirGeneratedEndpointsJsonSerdes._
  import TapirGeneratedEndpointsSchemas._

  def enumMap[E: enumextensions.EnumMirror]: Map[String, E] =
    Map.from(
      for e <- enumextensions.EnumMirror[E].values yield e.name.toUpperCase -> e
    )
  // Case-insensitive mapping
  def decodeEnum[T: enumextensions.EnumMirror](eMap: Map[String, T])(s: String): sttp.tapir.DecodeResult[T] =
    scala.util
      .Try(eMap(s.toUpperCase))
      .fold(
        _ =>
          sttp.tapir.DecodeResult.Error(
            s,
            new NoSuchElementException(
              s"Could not find value $s for enum ${enumextensions.EnumMirror[T].mirroredName}, available values: ${enumextensions.EnumMirror[T].values.mkString(", ")}"
            )
          ),
        sttp.tapir.DecodeResult.Value(_)
      )
  def makeQueryCodecForEnum[T: enumextensions.EnumMirror]: sttp.tapir.Codec[List[String], T, sttp.tapir.CodecFormat.TextPlain] = {
    val eMap = enumMap[T](using enumextensions.EnumMirror[T])
    sttp.tapir.Codec.listHead[String, String, sttp.tapir.CodecFormat.TextPlain]
      .mapDecode(decodeEnum[T](eMap))(_.name)
  }
  def makeQueryOptCodecForEnum[T: enumextensions.EnumMirror]: sttp.tapir.Codec[List[String], Option[T], sttp.tapir.CodecFormat.TextPlain] = {
    val eMap = enumMap[T](using enumextensions.EnumMirror[T])
    sttp.tapir.Codec.listHeadOption[String, String, sttp.tapir.CodecFormat.TextPlain]
      .mapDecode(maybeV => DecodeResult.sequence(maybeV.toSeq.map(decodeEnum[T](eMap))).map(_.headOption))(_.map(_.name))
  }
  def makeQuerySeqCodecForEnum[T: enumextensions.EnumMirror]: sttp.tapir.Codec[List[String], List[T], sttp.tapir.CodecFormat.TextPlain] = {
    val eMap = enumMap[T](using enumextensions.EnumMirror[T])
    sttp.tapir.Codec.listHead[String, String, sttp.tapir.CodecFormat.TextPlain]
      .mapDecode(values => DecodeResult.sequence(values.split(',').map(decodeEnum[T](eMap))).map(_.toList))(_.map(_.name).mkString(","))
  }
  def makeQueryOptSeqCodecForEnum[T: enumextensions.EnumMirror]: sttp.tapir.Codec[List[String], Option[List[T]], sttp.tapir.CodecFormat.TextPlain] = {
    val eMap = enumMap[T](using enumextensions.EnumMirror[T])
    sttp.tapir.Codec.listHeadOption[String, String, sttp.tapir.CodecFormat.TextPlain]
      .mapDecode{
        case None => DecodeResult.Value(None)
        case Some(values) => DecodeResult.sequence(values.split(',').map(decodeEnum[T](eMap))).map(r => Some(r.toList))
      }(_.map(_.map(_.name).mkString(",")))
  }
  sealed trait ADTWithoutDiscriminator
  sealed trait ADTWithDiscriminator
  sealed trait ADTWithDiscriminatorNoMapping
  case class SubtypeWithoutD1 (
    s: String,
    i: Option[Int] = None,
    a: Seq[String],
    absent: Option[String] = None
  ) extends ADTWithoutDiscriminator
  case class SubtypeWithD1 (
    s: String,
    i: Option[Int] = None,
    d: Option[Double] = None
  ) extends ADTWithDiscriminator with ADTWithDiscriminatorNoMapping
  case class SubtypeWithoutD3 (
    s: String,
    i: Option[Int] = None,
    e: Option[AnEnum] = None,
    absent: Option[String] = None
  ) extends ADTWithoutDiscriminator
  case class ObjectWithInlineEnum (
    id: java.util.UUID,
    inlineEnum: ObjectWithInlineEnumInlineEnum
  )

  enum ObjectWithInlineEnumInlineEnum derives org.latestbit.circe.adt.codec.JsonTaggedAdt.PureCodec {
    case foo1, foo2, foo3, foo4
  }
  case class SubtypeWithoutD2 (
    a: Seq[String],
    absent: Option[String] = None
  ) extends ADTWithoutDiscriminator
  case class SubtypeWithD2 (
    s: String,
    a: Option[Seq[String]] = None
  ) extends ADTWithDiscriminator with ADTWithDiscriminatorNoMapping

  enum AnEnum derives org.latestbit.circe.adt.codec.JsonTaggedAdt.PureCodec {
    case Foo, Bar, Baz
  }


  lazy val putAdtTest =
    endpoint
      .put
      .in(("adt" / "test"))
      .in(jsonBody[ADTWithoutDiscriminator])
      .out(jsonBody[ADTWithoutDiscriminator].description("successful operation"))

  lazy val postAdtTest =
    endpoint
      .post
      .in(("adt" / "test"))
      .in(jsonBody[ADTWithDiscriminatorNoMapping])
      .out(jsonBody[ADTWithDiscriminator].description("successful operation"))

  lazy val postInlineEnumTest =
    endpoint
      .post
      .in(("inline" / "enum" / "test"))
      .in(query[PostInlineEnumTestQueryEnum]("query-enum").description("An enum, inline, in a query string"))
      .in(query[Option[PostInlineEnumTestQueryOptEnum]]("query-opt-enum").description("An optional enum, inline, in a query string"))
      .in(query[List[PostInlineEnumTestQuerySeqEnum]]("query-seq-enum").description("A sequence of enums, inline, in a query string"))
      .in(query[Option[List[PostInlineEnumTestQueryOptSeqEnum]]]("query-opt-seq-enum").description("An optional sequence of enums, inline, in a query string"))
      .in(jsonBody[ObjectWithInlineEnum])
      .out(statusCode(sttp.model.StatusCode(204)).description("No Content"))

  object PostInlineEnumTestQueryEnum {
    given plainListPostInlineEnumTestQueryEnumCodec: sttp.tapir.Codec[List[String], PostInlineEnumTestQueryEnum, sttp.tapir.CodecFormat.TextPlain] =
      makeQueryCodecForEnum[PostInlineEnumTestQueryEnum]
    given plainListOptPostInlineEnumTestQueryEnumCodec: sttp.tapir.Codec[List[String], Option[PostInlineEnumTestQueryEnum], sttp.tapir.CodecFormat.TextPlain] =
      makeQueryOptCodecForEnum[PostInlineEnumTestQueryEnum]
    given plainListListPostInlineEnumTestQueryEnumCodec: sttp.tapir.Codec[List[String], List[PostInlineEnumTestQueryEnum], sttp.tapir.CodecFormat.TextPlain] =
      makeQuerySeqCodecForEnum[PostInlineEnumTestQueryEnum]
    given plainListOptListPostInlineEnumTestQueryEnumCodec: sttp.tapir.Codec[List[String], Option[List[PostInlineEnumTestQueryEnum]], sttp.tapir.CodecFormat.TextPlain] =
      makeQueryOptSeqCodecForEnum[PostInlineEnumTestQueryEnum]
  }
  enum PostInlineEnumTestQueryEnum derives enumextensions.EnumMirror {
    case bar1, bar2, bar3
  }

  object PostInlineEnumTestQueryOptEnum {
    given plainListPostInlineEnumTestQueryOptEnumCodec: sttp.tapir.Codec[List[String], PostInlineEnumTestQueryOptEnum, sttp.tapir.CodecFormat.TextPlain] =
      makeQueryCodecForEnum[PostInlineEnumTestQueryOptEnum]
    given plainListOptPostInlineEnumTestQueryOptEnumCodec: sttp.tapir.Codec[List[String], Option[PostInlineEnumTestQueryOptEnum], sttp.tapir.CodecFormat.TextPlain] =
      makeQueryOptCodecForEnum[PostInlineEnumTestQueryOptEnum]
    given plainListListPostInlineEnumTestQueryOptEnumCodec: sttp.tapir.Codec[List[String], List[PostInlineEnumTestQueryOptEnum], sttp.tapir.CodecFormat.TextPlain] =
      makeQuerySeqCodecForEnum[PostInlineEnumTestQueryOptEnum]
    given plainListOptListPostInlineEnumTestQueryOptEnumCodec: sttp.tapir.Codec[List[String], Option[List[PostInlineEnumTestQueryOptEnum]], sttp.tapir.CodecFormat.TextPlain] =
      makeQueryOptSeqCodecForEnum[PostInlineEnumTestQueryOptEnum]
  }
  enum PostInlineEnumTestQueryOptEnum derives enumextensions.EnumMirror {
    case bar1, bar2, bar3
  }

  object PostInlineEnumTestQuerySeqEnum {
    given plainListPostInlineEnumTestQuerySeqEnumCodec: sttp.tapir.Codec[List[String], PostInlineEnumTestQuerySeqEnum, sttp.tapir.CodecFormat.TextPlain] =
      makeQueryCodecForEnum[PostInlineEnumTestQuerySeqEnum]
    given plainListOptPostInlineEnumTestQuerySeqEnumCodec: sttp.tapir.Codec[List[String], Option[PostInlineEnumTestQuerySeqEnum], sttp.tapir.CodecFormat.TextPlain] =
      makeQueryOptCodecForEnum[PostInlineEnumTestQuerySeqEnum]
    given plainListListPostInlineEnumTestQuerySeqEnumCodec: sttp.tapir.Codec[List[String], List[PostInlineEnumTestQuerySeqEnum], sttp.tapir.CodecFormat.TextPlain] =
      makeQuerySeqCodecForEnum[PostInlineEnumTestQuerySeqEnum]
    given plainListOptListPostInlineEnumTestQuerySeqEnumCodec: sttp.tapir.Codec[List[String], Option[List[PostInlineEnumTestQuerySeqEnum]], sttp.tapir.CodecFormat.TextPlain] =
      makeQueryOptSeqCodecForEnum[PostInlineEnumTestQuerySeqEnum]
  }
  enum PostInlineEnumTestQuerySeqEnum derives enumextensions.EnumMirror {
    case baz1, baz2, baz3
  }

  object PostInlineEnumTestQueryOptSeqEnum {
    given plainListPostInlineEnumTestQueryOptSeqEnumCodec: sttp.tapir.Codec[List[String], PostInlineEnumTestQueryOptSeqEnum, sttp.tapir.CodecFormat.TextPlain] =
      makeQueryCodecForEnum[PostInlineEnumTestQueryOptSeqEnum]
    given plainListOptPostInlineEnumTestQueryOptSeqEnumCodec: sttp.tapir.Codec[List[String], Option[PostInlineEnumTestQueryOptSeqEnum], sttp.tapir.CodecFormat.TextPlain] =
      makeQueryOptCodecForEnum[PostInlineEnumTestQueryOptSeqEnum]
    given plainListListPostInlineEnumTestQueryOptSeqEnumCodec: sttp.tapir.Codec[List[String], List[PostInlineEnumTestQueryOptSeqEnum], sttp.tapir.CodecFormat.TextPlain] =
      makeQuerySeqCodecForEnum[PostInlineEnumTestQueryOptSeqEnum]
    given plainListOptListPostInlineEnumTestQueryOptSeqEnumCodec: sttp.tapir.Codec[List[String], Option[List[PostInlineEnumTestQueryOptSeqEnum]], sttp.tapir.CodecFormat.TextPlain] =
      makeQueryOptSeqCodecForEnum[PostInlineEnumTestQueryOptSeqEnum]
  }
  enum PostInlineEnumTestQueryOptSeqEnum derives enumextensions.EnumMirror {
    case baz1, baz2, baz3
  }


  lazy val generatedEndpoints = List(putAdtTest, postAdtTest, postInlineEnumTest)

}
