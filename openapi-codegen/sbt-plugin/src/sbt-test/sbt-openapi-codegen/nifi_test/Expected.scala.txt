
package sttp.tapir.generated

object TapirGeneratedEndpoints {

  import sttp.tapir._
  import sttp.tapir.model._
  import sttp.tapir.generic.auto._
  import sttp.tapir.json.circe._
  import io.circe.generic.semiauto._
  
  import sttp.tapir.generated.TapirGeneratedEndpointsJsonSerdes._
  import sttp.tapir.generated.TapirGeneratedEndpointsXmlSerdes._
  import TapirGeneratedEndpointsSchemas._

  case class `*/*CodecFormat`() extends CodecFormat {
    override val mediaType: sttp.model.MediaType = sttp.model.MediaType.unsafeApply(mainType = "*", subType = "*")
  }
  case class `application/x-www-form-urlencodedCodecFormat`() extends CodecFormat {
    override val mediaType: sttp.model.MediaType = sttp.model.MediaType.unsafeApply(mainType = "application", subType = "x-www-form-urlencoded")
  }
  
  
  
  case class CommaSeparatedValues[T](values: List[T])
  case class ExplodedValues[T](values: List[T])
  trait ExtraParamSupport[T] {
    def decode(s: String): sttp.tapir.DecodeResult[T]
    def encode(t: T): String
  }
  implicit def makePathCodecFromSupport[T](implicit support: ExtraParamSupport[T]): sttp.tapir.Codec[String, T, sttp.tapir.CodecFormat.TextPlain] = {
    sttp.tapir.Codec.string.mapDecode(support.decode)(support.encode)
  }
  implicit def makeQueryCodecFromSupport[T](implicit support: ExtraParamSupport[T]): sttp.tapir.Codec[List[String], T, sttp.tapir.CodecFormat.TextPlain] = {
    sttp.tapir.Codec.listHead[String, String, sttp.tapir.CodecFormat.TextPlain]
      .mapDecode(support.decode)(support.encode)
  }
  implicit def makeQueryOptCodecFromSupport[T](implicit support: ExtraParamSupport[T]): sttp.tapir.Codec[List[String], Option[T], sttp.tapir.CodecFormat.TextPlain] = {
    sttp.tapir.Codec.listHeadOption[String, String, sttp.tapir.CodecFormat.TextPlain]
      .mapDecode(maybeV => DecodeResult.sequence(maybeV.toSeq.map(support.decode)).map(_.headOption))(_.map(support.encode))
  }
  implicit def makeUnexplodedQuerySeqCodecFromListHead[T](implicit support: sttp.tapir.Codec[List[String], T, sttp.tapir.CodecFormat.TextPlain]): sttp.tapir.Codec[List[String], CommaSeparatedValues[T], sttp.tapir.CodecFormat.TextPlain] = {
    sttp.tapir.Codec.listHead[String, String, sttp.tapir.CodecFormat.TextPlain]
      .mapDecode(values => DecodeResult.sequence(values.split(',').toSeq.map(e => support.rawDecode(List(e)))).map(s => CommaSeparatedValues(s.toList)))(_.values.map(support.encode).mkString(","))
  }
  implicit def makeUnexplodedQueryOptSeqCodecFromListHead[T](implicit support: sttp.tapir.Codec[List[String], T, sttp.tapir.CodecFormat.TextPlain]): sttp.tapir.Codec[List[String], Option[CommaSeparatedValues[T]], sttp.tapir.CodecFormat.TextPlain] = {
    sttp.tapir.Codec.listHeadOption[String, String, sttp.tapir.CodecFormat.TextPlain]
      .mapDecode{
        case None => DecodeResult.Value(None)
        case Some(values) => DecodeResult.sequence(values.split(',').toSeq.map(e => support.rawDecode(List(e)))).map(r => Some(CommaSeparatedValues(r.toList)))
      }(_.map(_.values.map(support.encode).mkString(",")))
  }
  implicit def makeExplodedQuerySeqCodecFromListSeq[T](implicit support: sttp.tapir.Codec[List[String], List[T], sttp.tapir.CodecFormat.TextPlain]): sttp.tapir.Codec[List[String], ExplodedValues[T], sttp.tapir.CodecFormat.TextPlain] = {
    support.mapDecode(l => DecodeResult.Value(ExplodedValues(l)))(_.values)
  }
  implicit class RichBody[A, T](bod: EndpointIO.Body[A, T]) {
    def widenBody[TT >: T]: EndpointIO.Body[A, TT] = bod.map(_.asInstanceOf[TT])(_.asInstanceOf[T])
  }
  implicit class RichStreamBody[A, T, R](bod: sttp.tapir.StreamBodyIO[A, T, R]) {
    def widenBody[TT >: T]: sttp.tapir.StreamBodyIO[A, TT, R] = bod.map(_.asInstanceOf[TT])(_.asInstanceOf[T])
  }
  type ByteString <: Array[Byte]
  implicit def toByteString(ba: Array[Byte]): ByteString = ba.asInstanceOf[ByteString]

  case class EnumExtraParamSupport[T <: enumeratum.EnumEntry](enumName: String, T: enumeratum.Enum[T]) extends ExtraParamSupport[T] {
    // Case-insensitive mapping
    def decode(s: String): sttp.tapir.DecodeResult[T] =
      scala.util.Try(T.upperCaseNameValuesToMap(s.toUpperCase))
        .fold(
          _ =>
            sttp.tapir.DecodeResult.Error(
              s,
              new NoSuchElementException(
                s"Could not find value $s for enum ${enumName}, available values: ${T.values.mkString(", ")}"
              )
            ),
          sttp.tapir.DecodeResult.Value(_)
        )
    def encode(t: T): String = t.entryName
  }
  def extraCodecSupport[T <: enumeratum.EnumEntry](enumName: String, T: enumeratum.Enum[T]): ExtraParamSupport[T] =
    EnumExtraParamSupport(enumName, T)
  case class ParameterProviderReferencingComponentsEntity (
    parameterProviderReferencingComponents: Option[Set[ParameterProviderReferencingComponentEntity]] = None
  )
  case class ReplayLastEventResponseEntity (
    aggregateSnapshot: Option[ReplayLastEventSnapshotDTO] = None,
    componentId: Option[String] = None,
    nodeSnapshots: Option[Seq[NodeReplayLastEventSnapshotDTO]] = None,
    nodes: Option[ReplayLastEventResponseEntityNodes] = None
  )
  
  sealed trait ReplayLastEventResponseEntityNodes extends enumeratum.EnumEntry
  object ReplayLastEventResponseEntityNodes extends enumeratum.Enum[ReplayLastEventResponseEntityNodes] with enumeratum.CirceEnum[ReplayLastEventResponseEntityNodes] {
    val values = findValues
    case object ALL extends ReplayLastEventResponseEntityNodes
    case object PRIMARY extends ReplayLastEventResponseEntityNodes
  }
  case class ProcessorStatusSnapshotEntity (
    canRead: Option[Boolean] = None,
    id: Option[String] = None,
    processorStatusSnapshot: Option[ProcessorStatusSnapshotDTO] = None
  )
  case class Restriction (
    explanation: Option[String] = None,
    requiredPermission: Option[String] = None
  )
  case class FlowAnalysisResultEntity (
    flowAnalysisPending: Option[Boolean] = None,
    ruleViolations: Option[Seq[FlowAnalysisRuleViolationDTO]] = None,
    rules: Option[Seq[FlowAnalysisRuleDTO]] = None
  )
  case class AffectedComponentEntity (
    bulletins: Option[Seq[BulletinEntity]] = None,
    component: Option[AffectedComponentDTO] = None,
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    id: Option[String] = None,
    permissions: Option[PermissionsDTO] = None,
    position: Option[PositionDTO] = None,
    processGroup: Option[ProcessGroupNameDTO] = None,
    referenceType: Option[AffectedComponentEntityReferenceType] = None,
    revision: Option[RevisionDTO] = None,
    uri: Option[String] = None
  )
  
  sealed trait AffectedComponentEntityReferenceType extends enumeratum.EnumEntry
  object AffectedComponentEntityReferenceType extends enumeratum.Enum[AffectedComponentEntityReferenceType] with enumeratum.CirceEnum[AffectedComponentEntityReferenceType] {
    val values = findValues
    case object PROCESSOR extends AffectedComponentEntityReferenceType
    case object CONTROLLER_SERVICE extends AffectedComponentEntityReferenceType
    case object INPUT_PORT extends AffectedComponentEntityReferenceType
    case object OUTPUT_PORT extends AffectedComponentEntityReferenceType
    case object REMOTE_INPUT_PORT extends AffectedComponentEntityReferenceType
    case object REMOTE_OUTPUT_PORT extends AffectedComponentEntityReferenceType
  }
  case class ProcessGroupFlowEntity (
    permissions: Option[PermissionsDTO] = None,
    processGroupFlow: Option[ProcessGroupFlowDTO] = None,
    revision: Option[RevisionDTO] = None
  )
  case class BannerDTO (
    footerText: Option[String] = None,
    headerText: Option[String] = None
  )
  case class QueueSizeDTO (
    byteCount: Option[Long] = None,
    objectCount: Option[Int] = None
  )
  case class JmxMetricsResultsEntity (
    jmxMetricsResults: Option[Seq[JmxMetricsResultDTO]] = None
  )
  type LongParameterInt = Long
  case class ProcessGroupStatusEntity (
    canRead: Option[Boolean] = None,
    processGroupStatus: Option[ProcessGroupStatusDTO] = None
  )
  case class ProvenanceSearchValueDTO (
    inverse: Option[Boolean] = None,
    value: Option[String] = None
  )
  case class ExternalControllerServiceReference (
    identifier: Option[String] = None,
    name: Option[String] = None
  )
  case class FlowBreadcrumbDTO (
    id: Option[String] = None,
    name: Option[String] = None,
    versionControlInformation: Option[VersionControlInformationDTO] = None
  )
  case class Bundle (
    artifact: Option[String] = None,
    group: Option[String] = None,
    version: Option[String] = None
  )
  case class PrioritizerTypesEntity (
    prioritizerTypes: Option[Set[DocumentedTypeDTO]] = None
  )
  case class ComponentSearchResultDTO (
    groupId: Option[String] = None,
    id: Option[String] = None,
    matches: Option[Seq[String]] = None,
    name: Option[String] = None,
    parentGroup: Option[SearchResultGroupDTO] = None,
    versionedGroup: Option[SearchResultGroupDTO] = None
  )
  case class ParameterProviderEntity (
    bulletins: Option[Seq[BulletinEntity]] = None,
    component: Option[ParameterProviderDTO] = None,
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    id: Option[String] = None,
    permissions: Option[PermissionsDTO] = None,
    position: Option[PositionDTO] = None,
    revision: Option[RevisionDTO] = None,
    uri: Option[String] = None
  )
  case class ControllerServiceReferencingComponentDTO (
    activeThreadCount: Option[Int] = None,
    descriptors: Option[Map[String, PropertyDescriptorDTO]] = None,
    groupId: Option[String] = None,
    id: Option[String] = None,
    name: Option[String] = None,
    properties: Option[Map[String, String]] = None,
    referenceCycle: Option[Boolean] = None,
    referenceType: Option[ControllerServiceReferencingComponentDTOReferenceType] = None,
    referencingComponents: Option[Set[ControllerServiceReferencingComponentEntity]] = None,
    state: Option[String] = None,
    `type`: Option[String] = None,
    validationErrors: Option[Seq[String]] = None
  )
  
  sealed trait ControllerServiceReferencingComponentDTOReferenceType extends enumeratum.EnumEntry
  object ControllerServiceReferencingComponentDTOReferenceType extends enumeratum.Enum[ControllerServiceReferencingComponentDTOReferenceType] with enumeratum.CirceEnum[ControllerServiceReferencingComponentDTOReferenceType] {
    val values = findValues
    case object Processor extends ControllerServiceReferencingComponentDTOReferenceType
    case object ControllerService extends ControllerServiceReferencingComponentDTOReferenceType
    case object ReportingTask extends ControllerServiceReferencingComponentDTOReferenceType
    case object FlowRegistryClient extends ControllerServiceReferencingComponentDTOReferenceType
  }
  case class ConnectableComponent (
    comments: Option[String] = None,
    groupId: Option[String] = None,
    id: Option[String] = None,
    instanceIdentifier: Option[String] = None,
    name: Option[String] = None,
    `type`: Option[ConnectableComponentType] = None
  )
  
  sealed trait ConnectableComponentType extends enumeratum.EnumEntry
  object ConnectableComponentType extends enumeratum.Enum[ConnectableComponentType] with enumeratum.CirceEnum[ConnectableComponentType] {
    val values = findValues
    case object PROCESSOR extends ConnectableComponentType
    case object REMOTE_INPUT_PORT extends ConnectableComponentType
    case object REMOTE_OUTPUT_PORT extends ConnectableComponentType
    case object INPUT_PORT extends ConnectableComponentType
    case object OUTPUT_PORT extends ConnectableComponentType
    case object FUNNEL extends ConnectableComponentType
  }
  case class ControllerServiceStatusDTO (
    activeThreadCount: Option[Int] = None,
    runStatus: Option[ControllerServiceStatusDTORunStatus] = None,
    validationStatus: Option[ControllerServiceStatusDTOValidationStatus] = None
  )
  
  sealed trait ControllerServiceStatusDTORunStatus extends enumeratum.EnumEntry
  object ControllerServiceStatusDTORunStatus extends enumeratum.Enum[ControllerServiceStatusDTORunStatus] with enumeratum.CirceEnum[ControllerServiceStatusDTORunStatus] {
    val values = findValues
    case object ENABLED extends ControllerServiceStatusDTORunStatus
    case object ENABLING extends ControllerServiceStatusDTORunStatus
    case object DISABLED extends ControllerServiceStatusDTORunStatus
    case object DISABLING extends ControllerServiceStatusDTORunStatus
  }
  
  sealed trait ControllerServiceStatusDTOValidationStatus extends enumeratum.EnumEntry
  object ControllerServiceStatusDTOValidationStatus extends enumeratum.Enum[ControllerServiceStatusDTOValidationStatus] with enumeratum.CirceEnum[ControllerServiceStatusDTOValidationStatus] {
    val values = findValues
    case object VALID extends ControllerServiceStatusDTOValidationStatus
    case object INVALID extends ControllerServiceStatusDTOValidationStatus
    case object VALIDATING extends ControllerServiceStatusDTOValidationStatus
  }
  case class ParameterProviderConfigurationEntity (
    component: Option[ParameterProviderConfigurationDTO] = None,
    id: Option[String] = None,
    permissions: Option[PermissionsDTO] = None
  )
  type IntegerParameterInt = Int
  case class FlowAnalysisRuleStatusDTO (
    activeThreadCount: Option[Int] = None,
    runStatus: Option[FlowAnalysisRuleStatusDTORunStatus] = None,
    validationStatus: Option[FlowAnalysisRuleStatusDTOValidationStatus] = None
  )
  
  sealed trait FlowAnalysisRuleStatusDTORunStatus extends enumeratum.EnumEntry
  object FlowAnalysisRuleStatusDTORunStatus extends enumeratum.Enum[FlowAnalysisRuleStatusDTORunStatus] with enumeratum.CirceEnum[FlowAnalysisRuleStatusDTORunStatus] {
    val values = findValues
    case object ENABLED extends FlowAnalysisRuleStatusDTORunStatus
    case object DISABLED extends FlowAnalysisRuleStatusDTORunStatus
  }
  
  sealed trait FlowAnalysisRuleStatusDTOValidationStatus extends enumeratum.EnumEntry
  object FlowAnalysisRuleStatusDTOValidationStatus extends enumeratum.Enum[FlowAnalysisRuleStatusDTOValidationStatus] with enumeratum.CirceEnum[FlowAnalysisRuleStatusDTOValidationStatus] {
    val values = findValues
    case object VALID extends FlowAnalysisRuleStatusDTOValidationStatus
    case object INVALID extends FlowAnalysisRuleStatusDTOValidationStatus
    case object VALIDATING extends FlowAnalysisRuleStatusDTOValidationStatus
  }
  case class DifferenceDTO (
    difference: Option[String] = None,
    differenceType: Option[String] = None
  )
  case class ListingRequestEntity (
    listingRequest: Option[ListingRequestDTO] = None
  )
  case class StatusHistoryDTO (
    aggregateSnapshots: Option[Seq[StatusSnapshotDTO]] = None,
    componentDetails: Option[Map[String, String]] = None,
    fieldDescriptors: Option[Seq[StatusDescriptorDTO]] = None,
    generated: Option[String] = None,
    nodeSnapshots: Option[Seq[NodeStatusSnapshotsDTO]] = None
  )
  case class VersionedFunnel (
    comments: Option[String] = None,
    componentType: Option[VersionedFunnelComponentType] = None,
    groupIdentifier: Option[String] = None,
    identifier: Option[String] = None,
    instanceIdentifier: Option[String] = None,
    name: Option[String] = None,
    position: Option[Position] = None
  )
  
  sealed trait VersionedFunnelComponentType extends enumeratum.EnumEntry
  object VersionedFunnelComponentType extends enumeratum.Enum[VersionedFunnelComponentType] with enumeratum.CirceEnum[VersionedFunnelComponentType] {
    val values = findValues
    case object CONNECTION extends VersionedFunnelComponentType
    case object PROCESSOR extends VersionedFunnelComponentType
    case object PROCESS_GROUP extends VersionedFunnelComponentType
    case object REMOTE_PROCESS_GROUP extends VersionedFunnelComponentType
    case object INPUT_PORT extends VersionedFunnelComponentType
    case object OUTPUT_PORT extends VersionedFunnelComponentType
    case object REMOTE_INPUT_PORT extends VersionedFunnelComponentType
    case object REMOTE_OUTPUT_PORT extends VersionedFunnelComponentType
    case object FUNNEL extends VersionedFunnelComponentType
    case object LABEL extends VersionedFunnelComponentType
    case object CONTROLLER_SERVICE extends VersionedFunnelComponentType
    case object REPORTING_TASK extends VersionedFunnelComponentType
    case object FLOW_ANALYSIS_RULE extends VersionedFunnelComponentType
    case object PARAMETER_CONTEXT extends VersionedFunnelComponentType
    case object PARAMETER_PROVIDER extends VersionedFunnelComponentType
    case object FLOW_REGISTRY_CLIENT extends VersionedFunnelComponentType
  }
  case class StatusHistoryEntity (
    canRead: Option[Boolean] = None,
    statusHistory: Option[StatusHistoryDTO] = None
  )
  case class RequiredPermissionDTO (
    id: Option[String] = None,
    label: Option[String] = None
  )
  case class ComponentHistoryDTO (
    componentId: Option[String] = None,
    propertyHistory: Option[Map[String, PropertyHistoryDTO]] = None
  )
  case class VersionedFlowSnapshotMetadataEntity (
    registryId: Option[String] = None,
    versionedFlowSnapshotMetadata: Option[RegisteredFlowSnapshotMetadata] = None
  )
  case class AllowableValueEntity (
    allowableValue: Option[AllowableValueDTO] = None,
    canRead: Option[Boolean] = None
  )
  case class ClientIdParameter (
    clientId: Option[String] = None
  )
  case class AccessPolicySummaryEntity (
    bulletins: Option[Seq[BulletinEntity]] = None,
    component: Option[AccessPolicySummaryDTO] = None,
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    id: Option[String] = None,
    permissions: Option[PermissionsDTO] = None,
    position: Option[PositionDTO] = None,
    revision: Option[RevisionDTO] = None,
    uri: Option[String] = None
  )
  case class RemoteProcessGroupPortDTO (
    batchSettings: Option[BatchSettingsDTO] = None,
    comments: Option[String] = None,
    concurrentlySchedulableTaskCount: Option[Int] = None,
    connected: Option[Boolean] = None,
    exists: Option[Boolean] = None,
    groupId: Option[String] = None,
    id: Option[String] = None,
    name: Option[String] = None,
    targetId: Option[String] = None,
    targetRunning: Option[Boolean] = None,
    transmitting: Option[Boolean] = None,
    useCompression: Option[Boolean] = None,
    versionedComponentId: Option[String] = None
  )
  case class ConfigurationAnalysisEntity (
    configurationAnalysis: Option[ConfigurationAnalysisDTO] = None
  )
  case class ControllerServiceApiDTO (
    bundle: Option[BundleDTO] = None,
    `type`: Option[String] = None
  )
  case class PeerDTO (
    flowFileCount: Option[Int] = None,
    hostname: Option[String] = None,
    port: Option[Int] = None,
    secure: Option[Boolean] = None
  )
  case class ConnectionStatusSnapshotDTO (
    bytesIn: Option[Long] = None,
    bytesOut: Option[Long] = None,
    bytesQueued: Option[Long] = None,
    destinationId: Option[String] = None,
    destinationName: Option[String] = None,
    flowFileAvailability: Option[String] = None,
    flowFilesIn: Option[Int] = None,
    flowFilesOut: Option[Int] = None,
    flowFilesQueued: Option[Int] = None,
    groupId: Option[String] = None,
    id: Option[String] = None,
    input: Option[String] = None,
    loadBalanceStatus: Option[ConnectionStatusSnapshotDTOLoadBalanceStatus] = None,
    name: Option[String] = None,
    output: Option[String] = None,
    percentUseBytes: Option[Int] = None,
    percentUseCount: Option[Int] = None,
    predictions: Option[ConnectionStatusPredictionsSnapshotDTO] = None,
    queued: Option[String] = None,
    queuedCount: Option[String] = None,
    queuedSize: Option[String] = None,
    sourceId: Option[String] = None,
    sourceName: Option[String] = None
  )
  
  sealed trait ConnectionStatusSnapshotDTOLoadBalanceStatus extends enumeratum.EnumEntry
  object ConnectionStatusSnapshotDTOLoadBalanceStatus extends enumeratum.Enum[ConnectionStatusSnapshotDTOLoadBalanceStatus] with enumeratum.CirceEnum[ConnectionStatusSnapshotDTOLoadBalanceStatus] {
    val values = findValues
    case object LOAD_BALANCE_NOT_CONFIGURED extends ConnectionStatusSnapshotDTOLoadBalanceStatus
    case object LOAD_BALANCE_ACTIVE extends ConnectionStatusSnapshotDTOLoadBalanceStatus
    case object LOAD_BALANCE_INACTIVE extends ConnectionStatusSnapshotDTOLoadBalanceStatus
  }
  case class FlowAnalysisRuleRunStatusEntity (
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    revision: Option[RevisionDTO] = None,
    state: Option[FlowAnalysisRuleRunStatusEntityState] = None
  )
  
  sealed trait FlowAnalysisRuleRunStatusEntityState extends enumeratum.EnumEntry
  object FlowAnalysisRuleRunStatusEntityState extends enumeratum.Enum[FlowAnalysisRuleRunStatusEntityState] with enumeratum.CirceEnum[FlowAnalysisRuleRunStatusEntityState] {
    val values = findValues
    case object ENABLED extends FlowAnalysisRuleRunStatusEntityState
    case object DISABLED extends FlowAnalysisRuleRunStatusEntityState
  }
  case class UserGroupDTO (
    accessPolicies: Option[Set[AccessPolicyEntity]] = None,
    configurable: Option[Boolean] = None,
    id: Option[String] = None,
    identity: Option[String] = None,
    parentGroupId: Option[String] = None,
    position: Option[PositionDTO] = None,
    users: Option[Set[TenantEntity]] = None,
    versionedComponentId: Option[String] = None
  )
  case class PortDTO (
    allowRemoteAccess: Option[Boolean] = None,
    comments: Option[String] = None,
    concurrentlySchedulableTaskCount: Option[Int] = None,
    id: Option[String] = None,
    name: Option[String] = None,
    parentGroupId: Option[String] = None,
    portFunction: Option[PortDTOPortFunction] = None,
    position: Option[PositionDTO] = None,
    state: Option[PortDTOState] = None,
    transmitting: Option[Boolean] = None,
    `type`: Option[PortDTOType] = None,
    validationErrors: Option[Seq[String]] = None,
    versionedComponentId: Option[String] = None
  )
  
  sealed trait PortDTOPortFunction extends enumeratum.EnumEntry
  object PortDTOPortFunction extends enumeratum.Enum[PortDTOPortFunction] with enumeratum.CirceEnum[PortDTOPortFunction] {
    val values = findValues
    case object STANDARD extends PortDTOPortFunction
    case object FAILURE extends PortDTOPortFunction
  }
  
  sealed trait PortDTOState extends enumeratum.EnumEntry
  object PortDTOState extends enumeratum.Enum[PortDTOState] with enumeratum.CirceEnum[PortDTOState] {
    val values = findValues
    case object RUNNING extends PortDTOState
    case object STOPPED extends PortDTOState
    case object DISABLED extends PortDTOState
  }
  
  sealed trait PortDTOType extends enumeratum.EnumEntry
  object PortDTOType extends enumeratum.Enum[PortDTOType] with enumeratum.CirceEnum[PortDTOType] {
    val values = findValues
    case object INPUT_PORT extends PortDTOType
    case object OUTPUT_PORT extends PortDTOType
  }
  case class NodeDTO (
    activeThreadCount: Option[Int] = None,
    address: Option[String] = None,
    apiPort: Option[Int] = None,
    bytesQueued: Option[Long] = None,
    connectionRequested: Option[String] = None,
    events: Option[Seq[NodeEventDTO]] = None,
    flowFileBytes: Option[Long] = None,
    flowFilesQueued: Option[Int] = None,
    heartbeat: Option[String] = None,
    nodeId: Option[String] = None,
    nodeStartTime: Option[String] = None,
    queued: Option[String] = None,
    roles: Option[Set[String]] = None,
    status: Option[String] = None
  )
  case class ProcessorRunStatusDetailsEntity (
    permissions: Option[PermissionsDTO] = None,
    revision: Option[RevisionDTO] = None,
    runStatusDetails: Option[ProcessorRunStatusDetailsDTO] = None
  )
  case class BatchSettingsDTO (
    count: Option[Int] = None,
    duration: Option[String] = None,
    size: Option[String] = None
  )
  case class ActionEntity (
    action: Option[ActionDTO] = None,
    canRead: Option[Boolean] = None,
    id: Option[Int] = None,
    sourceId: Option[String] = None,
    timestamp: Option[String] = None
  )
  case class ConnectionStatisticsSnapshotDTO (
    id: Option[String] = None,
    predictedBytesAtNextInterval: Option[Long] = None,
    predictedCountAtNextInterval: Option[Int] = None,
    predictedMillisUntilBytesBackpressure: Option[Long] = None,
    predictedMillisUntilCountBackpressure: Option[Long] = None,
    predictedPercentBytes: Option[Int] = None,
    predictedPercentCount: Option[Int] = None,
    predictionIntervalMillis: Option[Long] = None
  )
  case class ComponentValidationResultEntity (
    bulletins: Option[Seq[BulletinEntity]] = None,
    component: Option[ComponentValidationResultDTO] = None,
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    id: Option[String] = None,
    permissions: Option[PermissionsDTO] = None,
    position: Option[PositionDTO] = None,
    revision: Option[RevisionDTO] = None,
    uri: Option[String] = None
  )
  case class VersionedFlowsEntity (
    versionedFlows: Option[Set[VersionedFlowEntity]] = None
  )
  case class VersionedProcessor (
    annotationData: Option[String] = None,
    autoTerminatedRelationships: Option[Set[String]] = None,
    backoffMechanism: Option[String] = None,
    bulletinLevel: Option[String] = None,
    bundle: Option[Bundle] = None,
    comments: Option[String] = None,
    componentType: Option[VersionedProcessorComponentType] = None,
    concurrentlySchedulableTaskCount: Option[Int] = None,
    executionNode: Option[String] = None,
    groupIdentifier: Option[String] = None,
    identifier: Option[String] = None,
    instanceIdentifier: Option[String] = None,
    maxBackoffPeriod: Option[String] = None,
    name: Option[String] = None,
    penaltyDuration: Option[String] = None,
    position: Option[Position] = None,
    properties: Option[Map[String, String]] = None,
    propertyDescriptors: Option[Map[String, VersionedPropertyDescriptor]] = None,
    retriedRelationships: Option[Set[String]] = None,
    retryCount: Option[Int] = None,
    runDurationMillis: Option[Long] = None,
    scheduledState: Option[VersionedProcessorScheduledState] = None,
    schedulingPeriod: Option[String] = None,
    schedulingStrategy: Option[String] = None,
    style: Option[Map[String, String]] = None,
    `type`: Option[String] = None,
    yieldDuration: Option[String] = None
  )
  
  sealed trait VersionedProcessorComponentType extends enumeratum.EnumEntry
  object VersionedProcessorComponentType extends enumeratum.Enum[VersionedProcessorComponentType] with enumeratum.CirceEnum[VersionedProcessorComponentType] {
    val values = findValues
    case object CONNECTION extends VersionedProcessorComponentType
    case object PROCESSOR extends VersionedProcessorComponentType
    case object PROCESS_GROUP extends VersionedProcessorComponentType
    case object REMOTE_PROCESS_GROUP extends VersionedProcessorComponentType
    case object INPUT_PORT extends VersionedProcessorComponentType
    case object OUTPUT_PORT extends VersionedProcessorComponentType
    case object REMOTE_INPUT_PORT extends VersionedProcessorComponentType
    case object REMOTE_OUTPUT_PORT extends VersionedProcessorComponentType
    case object FUNNEL extends VersionedProcessorComponentType
    case object LABEL extends VersionedProcessorComponentType
    case object CONTROLLER_SERVICE extends VersionedProcessorComponentType
    case object REPORTING_TASK extends VersionedProcessorComponentType
    case object FLOW_ANALYSIS_RULE extends VersionedProcessorComponentType
    case object PARAMETER_CONTEXT extends VersionedProcessorComponentType
    case object PARAMETER_PROVIDER extends VersionedProcessorComponentType
    case object FLOW_REGISTRY_CLIENT extends VersionedProcessorComponentType
  }
  
  sealed trait VersionedProcessorScheduledState extends enumeratum.EnumEntry
  object VersionedProcessorScheduledState extends enumeratum.Enum[VersionedProcessorScheduledState] with enumeratum.CirceEnum[VersionedProcessorScheduledState] {
    val values = findValues
    case object ENABLED extends VersionedProcessorScheduledState
    case object DISABLED extends VersionedProcessorScheduledState
    case object RUNNING extends VersionedProcessorScheduledState
  }
  case class LineageRequestDTO (
    clusterNodeId: Option[String] = None,
    eventId: Option[Long] = None,
    lineageRequestType: Option[LineageRequestDTOLineageRequestType] = None,
    uuid: Option[String] = None
  )
  
  sealed trait LineageRequestDTOLineageRequestType extends enumeratum.EnumEntry
  object LineageRequestDTOLineageRequestType extends enumeratum.Enum[LineageRequestDTOLineageRequestType] with enumeratum.CirceEnum[LineageRequestDTOLineageRequestType] {
    val values = findValues
    case object PARENTS extends LineageRequestDTOLineageRequestType
    case object CHILDREN extends LineageRequestDTOLineageRequestType
    case object FLOWFILE extends LineageRequestDTOLineageRequestType
  }
  case class ConnectionDTO (
    availableRelationships: Option[Set[String]] = None,
    backPressureDataSizeThreshold: Option[String] = None,
    backPressureObjectThreshold: Option[Long] = None,
    bends: Option[Seq[PositionDTO]] = None,
    destination: Option[ConnectableDTO] = None,
    flowFileExpiration: Option[String] = None,
    getzIndex: Option[Long] = None,
    id: Option[String] = None,
    labelIndex: Option[Int] = None,
    loadBalanceCompression: Option[String] = None,
    loadBalancePartitionAttribute: Option[String] = None,
    loadBalanceStatus: Option[String] = None,
    loadBalanceStrategy: Option[String] = None,
    name: Option[String] = None,
    parentGroupId: Option[String] = None,
    position: Option[PositionDTO] = None,
    prioritizers: Option[Seq[String]] = None,
    retriedRelationships: Option[Set[String]] = None,
    selectedRelationships: Option[Set[String]] = None,
    source: Option[ConnectableDTO] = None,
    versionedComponentId: Option[String] = None
  )
  case class SearchResultsEntity (
    searchResultsDTO: Option[SearchResultsDTO] = None
  )
  case class ControllerServiceReferencingComponentEntity (
    bulletins: Option[Seq[BulletinEntity]] = None,
    component: Option[ControllerServiceReferencingComponentDTO] = None,
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    id: Option[String] = None,
    operatePermissions: Option[PermissionsDTO] = None,
    permissions: Option[PermissionsDTO] = None,
    position: Option[PositionDTO] = None,
    revision: Option[RevisionDTO] = None,
    uri: Option[String] = None
  )
  case class AssetDTO (
    digest: Option[String] = None,
    id: Option[String] = None,
    missingContent: Option[Boolean] = None,
    name: Option[String] = None
  )
  case class VersionedFlowCoordinates (
    branch: Option[String] = None,
    bucketId: Option[String] = None,
    flowId: Option[String] = None,
    latest: Option[Boolean] = None,
    registryId: Option[String] = None,
    storageLocation: Option[String] = None,
    version: Option[String] = None
  )
  case class ExplicitRestrictionDTO (
    explanation: Option[String] = None,
    requiredPermission: Option[RequiredPermissionDTO] = None
  )
  case class CounterDTO (
    context: Option[String] = None,
    id: Option[String] = None,
    name: Option[String] = None,
    value: Option[String] = None,
    valueCount: Option[Long] = None
  )
  case class BulletinBoardEntity (
    bulletinBoard: Option[BulletinBoardDTO] = None
  )
  case class ProcessGroupStatusSnapshotEntity (
    canRead: Option[Boolean] = None,
    id: Option[String] = None,
    processGroupStatusSnapshot: Option[ProcessGroupStatusSnapshotDTO] = None
  )
  case class CopyRequestEntity (
    connections: Option[Set[String]] = None,
    funnels: Option[Set[String]] = None,
    inputPorts: Option[Set[String]] = None,
    labels: Option[Set[String]] = None,
    outputPorts: Option[Set[String]] = None,
    processGroups: Option[Set[String]] = None,
    processors: Option[Set[String]] = None,
    remoteProcessGroups: Option[Set[String]] = None
  )
  case class ProcessGroupStatusSnapshotDTO (
    activeThreadCount: Option[Int] = None,
    bytesIn: Option[Long] = None,
    bytesOut: Option[Long] = None,
    bytesQueued: Option[Long] = None,
    bytesRead: Option[Long] = None,
    bytesReceived: Option[Long] = None,
    bytesSent: Option[Long] = None,
    bytesTransferred: Option[Long] = None,
    bytesWritten: Option[Long] = None,
    connectionStatusSnapshots: Option[Seq[ConnectionStatusSnapshotEntity]] = None,
    flowFilesIn: Option[Int] = None,
    flowFilesOut: Option[Int] = None,
    flowFilesQueued: Option[Int] = None,
    flowFilesReceived: Option[Int] = None,
    flowFilesSent: Option[Int] = None,
    flowFilesTransferred: Option[Int] = None,
    id: Option[String] = None,
    input: Option[String] = None,
    inputPortStatusSnapshots: Option[Seq[PortStatusSnapshotEntity]] = None,
    name: Option[String] = None,
    output: Option[String] = None,
    outputPortStatusSnapshots: Option[Seq[PortStatusSnapshotEntity]] = None,
    processGroupStatusSnapshots: Option[Seq[ProcessGroupStatusSnapshotEntity]] = None,
    processingNanos: Option[Long] = None,
    processingPerformanceStatus: Option[ProcessingPerformanceStatusDTO] = None,
    processorStatusSnapshots: Option[Seq[ProcessorStatusSnapshotEntity]] = None,
    queued: Option[String] = None,
    queuedCount: Option[String] = None,
    queuedSize: Option[String] = None,
    read: Option[String] = None,
    received: Option[String] = None,
    remoteProcessGroupStatusSnapshots: Option[Seq[RemoteProcessGroupStatusSnapshotEntity]] = None,
    sent: Option[String] = None,
    statelessActiveThreadCount: Option[Int] = None,
    terminatedThreadCount: Option[Int] = None,
    transferred: Option[String] = None,
    versionedFlowState: Option[ProcessGroupStatusSnapshotDTOVersionedFlowState] = None,
    written: Option[String] = None
  )
  
  sealed trait ProcessGroupStatusSnapshotDTOVersionedFlowState extends enumeratum.EnumEntry
  object ProcessGroupStatusSnapshotDTOVersionedFlowState extends enumeratum.Enum[ProcessGroupStatusSnapshotDTOVersionedFlowState] with enumeratum.CirceEnum[ProcessGroupStatusSnapshotDTOVersionedFlowState] {
    val values = findValues
    case object LOCALLY_MODIFIED extends ProcessGroupStatusSnapshotDTOVersionedFlowState
    case object STALE extends ProcessGroupStatusSnapshotDTOVersionedFlowState
    case object LOCALLY_MODIFIED_AND_STALE extends ProcessGroupStatusSnapshotDTOVersionedFlowState
    case object UP_TO_DATE extends ProcessGroupStatusSnapshotDTOVersionedFlowState
    case object SYNC_FAILURE extends ProcessGroupStatusSnapshotDTOVersionedFlowState
  }
  case class NodeConnectionStatisticsSnapshotDTO (
    address: Option[String] = None,
    apiPort: Option[Int] = None,
    nodeId: Option[String] = None,
    statisticsSnapshot: Option[ConnectionStatisticsSnapshotDTO] = None
  )
  case class FlowAnalysisRuleDefinition (
    additionalDetails: Option[Boolean] = None,
    artifact: Option[String] = None,
    buildInfo: Option[BuildInfo] = None,
    deprecated: Option[Boolean] = None,
    deprecationAlternatives: Option[Set[String]] = None,
    deprecationReason: Option[String] = None,
    dynamicProperties: Option[Seq[DynamicProperty]] = None,
    explicitRestrictions: Option[Set[Restriction]] = None,
    group: Option[String] = None,
    propertyDescriptors: Option[Map[String, PropertyDescriptor]] = None,
    providedApiImplementations: Option[Seq[DefinedType]] = None,
    restricted: Option[Boolean] = None,
    restrictedExplanation: Option[String] = None,
    seeAlso: Option[Set[String]] = None,
    stateful: Option[Stateful] = None,
    supportsDynamicProperties: Option[Boolean] = None,
    supportsSensitiveDynamicProperties: Option[Boolean] = None,
    systemResourceConsiderations: Option[Seq[SystemResourceConsideration]] = None,
    tags: Option[Set[String]] = None,
    `type`: Option[String] = None,
    typeDescription: Option[String] = None,
    version: Option[String] = None
  )
  case class FlowRegistryClientEntity (
    bulletins: Option[Seq[BulletinEntity]] = None,
    component: Option[FlowRegistryClientDTO] = None,
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    id: Option[String] = None,
    operatePermissions: Option[PermissionsDTO] = None,
    permissions: Option[PermissionsDTO] = None,
    position: Option[PositionDTO] = None,
    revision: Option[RevisionDTO] = None,
    uri: Option[String] = None
  )
  case class DynamicRelationship (
    description: Option[String] = None,
    name: Option[String] = None
  )
  case class ParameterProviderApplyParametersRequestDTO (
    complete: Option[Boolean] = None,
    failureReason: Option[String] = None,
    lastUpdated: Option[java.time.Instant] = None,
    parameterContextUpdates: Option[Seq[ParameterContextUpdateEntity]] = None,
    parameterProvider: Option[ParameterProviderDTO] = None,
    percentCompleted: Option[Int] = None,
    referencingComponents: Option[Set[AffectedComponentEntity]] = None,
    requestId: Option[String] = None,
    state: Option[String] = None,
    submissionTime: Option[java.time.Instant] = None,
    updateSteps: Option[Seq[ParameterProviderApplyParametersUpdateStepDTO]] = None,
    uri: Option[String] = None
  )
  case class ParameterContextReferenceEntity (
    component: Option[ParameterContextReferenceDTO] = None,
    id: Option[String] = None,
    permissions: Option[PermissionsDTO] = None
  )
  case class ConnectionStatusDTO (
    aggregateSnapshot: Option[ConnectionStatusSnapshotDTO] = None,
    destinationId: Option[String] = None,
    destinationName: Option[String] = None,
    groupId: Option[String] = None,
    id: Option[String] = None,
    name: Option[String] = None,
    nodeSnapshots: Option[Seq[NodeConnectionStatusSnapshotDTO]] = None,
    sourceId: Option[String] = None,
    sourceName: Option[String] = None,
    statsLastRefreshed: Option[String] = None
  )
  case class ParameterContextEntity (
    bulletins: Option[Seq[BulletinEntity]] = None,
    component: Option[ParameterContextDTO] = None,
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    id: Option[String] = None,
    permissions: Option[PermissionsDTO] = None,
    position: Option[PositionDTO] = None,
    revision: Option[RevisionDTO] = None,
    uri: Option[String] = None
  )
  case class CountersDTO (
    aggregateSnapshot: Option[CountersSnapshotDTO] = None,
    nodeSnapshots: Option[Seq[NodeCountersSnapshotDTO]] = None
  )
  case class VersionControlInformationDTO (
    branch: Option[String] = None,
    bucketId: Option[String] = None,
    bucketName: Option[String] = None,
    flowDescription: Option[String] = None,
    flowId: Option[String] = None,
    flowName: Option[String] = None,
    groupId: Option[String] = None,
    registryId: Option[String] = None,
    registryName: Option[String] = None,
    state: Option[VersionControlInformationDTOState] = None,
    stateExplanation: Option[String] = None,
    storageLocation: Option[String] = None,
    version: Option[String] = None
  )
  
  sealed trait VersionControlInformationDTOState extends enumeratum.EnumEntry
  object VersionControlInformationDTOState extends enumeratum.Enum[VersionControlInformationDTOState] with enumeratum.CirceEnum[VersionControlInformationDTOState] {
    val values = findValues
    case object LOCALLY_MODIFIED extends VersionControlInformationDTOState
    case object STALE extends VersionControlInformationDTOState
    case object LOCALLY_MODIFIED_AND_STALE extends VersionControlInformationDTOState
    case object UP_TO_DATE extends VersionControlInformationDTOState
    case object SYNC_FAILURE extends VersionControlInformationDTOState
  }
  case class AttributeDTO (
    name: Option[String] = None,
    previousValue: Option[String] = None,
    value: Option[String] = None
  )
  case class ScheduleComponentsEntity (
    components: Option[Map[String, RevisionDTO]] = None,
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    id: Option[String] = None,
    state: Option[ScheduleComponentsEntityState] = None
  )
  
  sealed trait ScheduleComponentsEntityState extends enumeratum.EnumEntry
  object ScheduleComponentsEntityState extends enumeratum.Enum[ScheduleComponentsEntityState] with enumeratum.CirceEnum[ScheduleComponentsEntityState] {
    val values = findValues
    case object RUNNING extends ScheduleComponentsEntityState
    case object STOPPED extends ScheduleComponentsEntityState
    case object ENABLED extends ScheduleComponentsEntityState
    case object DISABLED extends ScheduleComponentsEntityState
  }
  case class ReportingTaskEntity (
    bulletins: Option[Seq[BulletinEntity]] = None,
    component: Option[ReportingTaskDTO] = None,
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    id: Option[String] = None,
    operatePermissions: Option[PermissionsDTO] = None,
    permissions: Option[PermissionsDTO] = None,
    position: Option[PositionDTO] = None,
    revision: Option[RevisionDTO] = None,
    status: Option[ReportingTaskStatusDTO] = None,
    uri: Option[String] = None
  )
  case class RuntimeManifest (
    agentType: Option[String] = None,
    buildInfo: Option[BuildInfo] = None,
    bundles: Option[Seq[Bundle]] = None,
    identifier: Option[String] = None,
    schedulingDefaults: Option[SchedulingDefaults] = None,
    version: Option[String] = None
  )
  case class VersionedFlowDTO (
    action: Option[VersionedFlowDTOAction] = None,
    branch: Option[String] = None,
    bucketId: Option[String] = None,
    comments: Option[String] = None,
    description: Option[String] = None,
    flowId: Option[String] = None,
    flowName: Option[String] = None,
    registryId: Option[String] = None
  )
  
  sealed trait VersionedFlowDTOAction extends enumeratum.EnumEntry
  object VersionedFlowDTOAction extends enumeratum.Enum[VersionedFlowDTOAction] with enumeratum.CirceEnum[VersionedFlowDTOAction] {
    val values = findValues
    case object COMMIT extends VersionedFlowDTOAction
    case object FORCE_COMMIT extends VersionedFlowDTOAction
  }
  case class NodeSearchResultDTO (
    address: Option[String] = None,
    id: Option[String] = None
  )
  case class ResourcesEntity (
    resources: Option[Seq[ResourceDTO]] = None
  )
  case class ComponentManifest (
    apis: Option[Seq[DefinedType]] = None,
    controllerServices: Option[Seq[ControllerServiceDefinition]] = None,
    flowAnalysisRules: Option[Seq[FlowAnalysisRuleDefinition]] = None,
    parameterProviders: Option[Seq[ParameterProviderDefinition]] = None,
    processors: Option[Seq[ProcessorDefinition]] = None,
    reportingTasks: Option[Seq[ReportingTaskDefinition]] = None
  )
  case class ComponentValidationResultsEntity (
    validationResults: Option[Seq[ComponentValidationResultEntity]] = None
  )
  case class StartVersionControlRequestEntity (
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    processGroupRevision: Option[RevisionDTO] = None,
    versionedFlow: Option[VersionedFlowDTO] = None
  )
  case class PasteResponseEntity (
    flow: Option[FlowDTO] = None,
    revision: Option[RevisionDTO] = None
  )
  case class FlowFileEntity (
    flowFile: Option[FlowFileDTO] = None
  )
  case class ControllerBulletinsEntity (
    bulletins: Option[Seq[BulletinEntity]] = None,
    controllerServiceBulletins: Option[Seq[BulletinEntity]] = None,
    flowAnalysisRuleBulletins: Option[Seq[BulletinEntity]] = None,
    flowRegistryClientBulletins: Option[Seq[BulletinEntity]] = None,
    parameterProviderBulletins: Option[Seq[BulletinEntity]] = None,
    reportingTaskBulletins: Option[Seq[BulletinEntity]] = None
  )
  case class ProcessGroupUploadEntity (
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    flowSnapshot: Option[RegisteredFlowSnapshot] = None,
    groupId: Option[String] = None,
    groupName: Option[String] = None,
    positionDTO: Option[PositionDTO] = None,
    revisionDTO: Option[RevisionDTO] = None
  )
  case class BulletinBoardPatternParameter (
    pattern: Option[BulletinBoardPatternParameterPattern] = None,
    rawPattern: Option[String] = None
  )
  case class BulletinBoardPatternParameterPattern (
  
  )
  case class ClusterSummaryEntity (
    clusterSummary: Option[ClusterSummaryDTO] = None
  )
  case class HistoryEntity (
    history: Option[HistoryDTO] = None
  )
  case class PortRunStatusEntity (
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    revision: Option[RevisionDTO] = None,
    state: Option[PortRunStatusEntityState] = None
  )
  
  sealed trait PortRunStatusEntityState extends enumeratum.EnumEntry
  object PortRunStatusEntityState extends enumeratum.Enum[PortRunStatusEntityState] with enumeratum.CirceEnum[PortRunStatusEntityState] {
    val values = findValues
    case object RUNNING extends PortRunStatusEntityState
    case object STOPPED extends PortRunStatusEntityState
    case object DISABLED extends PortRunStatusEntityState
  }
  case class SubmitReplayRequestEntity (
    clusterNodeId: Option[String] = None,
    eventId: Option[Long] = None
  )
  case class PropertyResourceDefinition (
    cardinality: Option[PropertyResourceDefinitionCardinality] = None,
    resourceTypes: Option[Set[PropertyResourceDefinitionResourceTypesItem]] = None
  )
  
  sealed trait PropertyResourceDefinitionCardinality extends enumeratum.EnumEntry
  object PropertyResourceDefinitionCardinality extends enumeratum.Enum[PropertyResourceDefinitionCardinality] with enumeratum.CirceEnum[PropertyResourceDefinitionCardinality] {
    val values = findValues
    case object SINGLE extends PropertyResourceDefinitionCardinality
    case object MULTIPLE extends PropertyResourceDefinitionCardinality
  }
  
  sealed trait PropertyResourceDefinitionResourceTypesItem extends enumeratum.EnumEntry
  object PropertyResourceDefinitionResourceTypesItem extends enumeratum.Enum[PropertyResourceDefinitionResourceTypesItem] with enumeratum.CirceEnum[PropertyResourceDefinitionResourceTypesItem] {
    val values = findValues
    case object FILE extends PropertyResourceDefinitionResourceTypesItem
    case object DIRECTORY extends PropertyResourceDefinitionResourceTypesItem
    case object TEXT extends PropertyResourceDefinitionResourceTypesItem
    case object URL extends PropertyResourceDefinitionResourceTypesItem
  }
  case class VersionedRemoteProcessGroup (
    comments: Option[String] = None,
    communicationsTimeout: Option[String] = None,
    componentType: Option[VersionedRemoteProcessGroupComponentType] = None,
    groupIdentifier: Option[String] = None,
    identifier: Option[String] = None,
    inputPorts: Option[Set[VersionedRemoteGroupPort]] = None,
    instanceIdentifier: Option[String] = None,
    localNetworkInterface: Option[String] = None,
    name: Option[String] = None,
    outputPorts: Option[Set[VersionedRemoteGroupPort]] = None,
    position: Option[Position] = None,
    proxyHost: Option[String] = None,
    proxyPassword: Option[String] = None,
    proxyPort: Option[Int] = None,
    proxyUser: Option[String] = None,
    targetUris: Option[String] = None,
    transportProtocol: Option[String] = None,
    yieldDuration: Option[String] = None
  )
  
  sealed trait VersionedRemoteProcessGroupComponentType extends enumeratum.EnumEntry
  object VersionedRemoteProcessGroupComponentType extends enumeratum.Enum[VersionedRemoteProcessGroupComponentType] with enumeratum.CirceEnum[VersionedRemoteProcessGroupComponentType] {
    val values = findValues
    case object CONNECTION extends VersionedRemoteProcessGroupComponentType
    case object PROCESSOR extends VersionedRemoteProcessGroupComponentType
    case object PROCESS_GROUP extends VersionedRemoteProcessGroupComponentType
    case object REMOTE_PROCESS_GROUP extends VersionedRemoteProcessGroupComponentType
    case object INPUT_PORT extends VersionedRemoteProcessGroupComponentType
    case object OUTPUT_PORT extends VersionedRemoteProcessGroupComponentType
    case object REMOTE_INPUT_PORT extends VersionedRemoteProcessGroupComponentType
    case object REMOTE_OUTPUT_PORT extends VersionedRemoteProcessGroupComponentType
    case object FUNNEL extends VersionedRemoteProcessGroupComponentType
    case object LABEL extends VersionedRemoteProcessGroupComponentType
    case object CONTROLLER_SERVICE extends VersionedRemoteProcessGroupComponentType
    case object REPORTING_TASK extends VersionedRemoteProcessGroupComponentType
    case object FLOW_ANALYSIS_RULE extends VersionedRemoteProcessGroupComponentType
    case object PARAMETER_CONTEXT extends VersionedRemoteProcessGroupComponentType
    case object PARAMETER_PROVIDER extends VersionedRemoteProcessGroupComponentType
    case object FLOW_REGISTRY_CLIENT extends VersionedRemoteProcessGroupComponentType
  }
  case class NarSummariesEntity (
    currentTime: Option[String] = None,
    narSummaries: Option[Seq[NarSummaryEntity]] = None
  )
  case class Position (
    x: Option[Double] = None,
    y: Option[Double] = None
  )
  case class VersionedReportingTaskSnapshot (
    controllerServices: Option[Seq[VersionedControllerService]] = None,
    reportingTasks: Option[Seq[VersionedReportingTask]] = None
  )
  case class TenantEntity (
    bulletins: Option[Seq[BulletinEntity]] = None,
    component: Option[TenantDTO] = None,
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    id: Option[String] = None,
    permissions: Option[PermissionsDTO] = None,
    position: Option[PositionDTO] = None,
    revision: Option[RevisionDTO] = None,
    uri: Option[String] = None
  )
  case class ConnectionEntity (
    bends: Option[Seq[PositionDTO]] = None,
    bulletins: Option[Seq[BulletinEntity]] = None,
    component: Option[ConnectionDTO] = None,
    destinationGroupId: Option[String] = None,
    destinationId: Option[String] = None,
    destinationType: ConnectionEntityDestinationType,
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    getzIndex: Option[Long] = None,
    id: Option[String] = None,
    labelIndex: Option[Int] = None,
    permissions: Option[PermissionsDTO] = None,
    position: Option[PositionDTO] = None,
    revision: Option[RevisionDTO] = None,
    sourceGroupId: Option[String] = None,
    sourceId: Option[String] = None,
    sourceType: ConnectionEntitySourceType,
    status: Option[ConnectionStatusDTO] = None,
    uri: Option[String] = None
  )
  
  sealed trait ConnectionEntityDestinationType extends enumeratum.EnumEntry
  object ConnectionEntityDestinationType extends enumeratum.Enum[ConnectionEntityDestinationType] with enumeratum.CirceEnum[ConnectionEntityDestinationType] {
    val values = findValues
    case object PROCESSOR extends ConnectionEntityDestinationType
    case object REMOTE_INPUT_PORT extends ConnectionEntityDestinationType
    case object REMOTE_OUTPUT_PORT extends ConnectionEntityDestinationType
    case object INPUT_PORT extends ConnectionEntityDestinationType
    case object OUTPUT_PORT extends ConnectionEntityDestinationType
    case object FUNNEL extends ConnectionEntityDestinationType
  }
  
  sealed trait ConnectionEntitySourceType extends enumeratum.EnumEntry
  object ConnectionEntitySourceType extends enumeratum.Enum[ConnectionEntitySourceType] with enumeratum.CirceEnum[ConnectionEntitySourceType] {
    val values = findValues
    case object PROCESSOR extends ConnectionEntitySourceType
    case object REMOTE_INPUT_PORT extends ConnectionEntitySourceType
    case object REMOTE_OUTPUT_PORT extends ConnectionEntitySourceType
    case object INPUT_PORT extends ConnectionEntitySourceType
    case object OUTPUT_PORT extends ConnectionEntitySourceType
    case object FUNNEL extends ConnectionEntitySourceType
  }
  case class SystemResourceConsideration (
    description: Option[String] = None,
    resource: Option[String] = None
  )
  case class UserGroupEntity (
    bulletins: Option[Seq[BulletinEntity]] = None,
    component: Option[UserGroupDTO] = None,
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    id: Option[String] = None,
    permissions: Option[PermissionsDTO] = None,
    position: Option[PositionDTO] = None,
    revision: Option[RevisionDTO] = None,
    uri: Option[String] = None
  )
  case class FlowRegistryBucket (
    createdTimestamp: Option[Long] = None,
    description: Option[String] = None,
    identifier: Option[String] = None,
    name: Option[String] = None,
    permissions: Option[FlowRegistryPermissions] = None
  )
  case class FlowBreadcrumbEntity (
    breadcrumb: Option[FlowBreadcrumbDTO] = None,
    id: Option[String] = None,
    parentBreadcrumb: Option[FlowBreadcrumbEntity] = None,
    permissions: Option[PermissionsDTO] = None,
    versionedFlowState: Option[FlowBreadcrumbEntityVersionedFlowState] = None
  )
  
  sealed trait FlowBreadcrumbEntityVersionedFlowState extends enumeratum.EnumEntry
  object FlowBreadcrumbEntityVersionedFlowState extends enumeratum.Enum[FlowBreadcrumbEntityVersionedFlowState] with enumeratum.CirceEnum[FlowBreadcrumbEntityVersionedFlowState] {
    val values = findValues
    case object LOCALLY_MODIFIED extends FlowBreadcrumbEntityVersionedFlowState
    case object STALE extends FlowBreadcrumbEntityVersionedFlowState
    case object LOCALLY_MODIFIED_AND_STALE extends FlowBreadcrumbEntityVersionedFlowState
    case object UP_TO_DATE extends FlowBreadcrumbEntityVersionedFlowState
    case object SYNC_FAILURE extends FlowBreadcrumbEntityVersionedFlowState
  }
  case class FunnelDTO (
    id: Option[String] = None,
    parentGroupId: Option[String] = None,
    position: Option[PositionDTO] = None,
    versionedComponentId: Option[String] = None
  )
  case class ProcessorRunStatusDetailsDTO (
    activeThreadCount: Option[Int] = None,
    id: Option[String] = None,
    name: Option[String] = None,
    runStatus: Option[ProcessorRunStatusDetailsDTORunStatus] = None,
    validationErrors: Option[Set[String]] = None
  )
  
  sealed trait ProcessorRunStatusDetailsDTORunStatus extends enumeratum.EnumEntry
  object ProcessorRunStatusDetailsDTORunStatus extends enumeratum.Enum[ProcessorRunStatusDetailsDTORunStatus] with enumeratum.CirceEnum[ProcessorRunStatusDetailsDTORunStatus] {
    val values = findValues
    case object Running extends ProcessorRunStatusDetailsDTORunStatus
    case object Stopped extends ProcessorRunStatusDetailsDTORunStatus
    case object Invalid extends ProcessorRunStatusDetailsDTORunStatus
    case object Validating extends ProcessorRunStatusDetailsDTORunStatus
    case object Disabled extends ProcessorRunStatusDetailsDTORunStatus
  }
  case class CopyResponseEntity (
    connections: Option[Set[VersionedConnection]] = None,
    externalControllerServiceReferences: Option[Map[String, ExternalControllerServiceReference]] = None,
    funnels: Option[Set[VersionedFunnel]] = None,
    id: Option[String] = None,
    inputPorts: Option[Set[VersionedPort]] = None,
    labels: Option[Set[VersionedLabel]] = None,
    outputPorts: Option[Set[VersionedPort]] = None,
    parameterContexts: Option[Map[String, VersionedParameterContext]] = None,
    parameterProviders: Option[Map[String, ParameterProviderReference]] = None,
    processGroups: Option[Set[VersionedProcessGroup]] = None,
    processors: Option[Set[VersionedProcessor]] = None,
    remoteProcessGroups: Option[Set[VersionedRemoteProcessGroup]] = None
  )
  case class Stateful (
    description: Option[String] = None,
    scopes: Option[Set[StatefulScopesItem]] = None
  )
  
  sealed trait StatefulScopesItem extends enumeratum.EnumEntry
  object StatefulScopesItem extends enumeratum.Enum[StatefulScopesItem] with enumeratum.CirceEnum[StatefulScopesItem] {
    val values = findValues
    case object CLUSTER extends StatefulScopesItem
    case object LOCAL extends StatefulScopesItem
  }
  case class RemoteProcessGroupEntity (
    bulletins: Option[Seq[BulletinEntity]] = None,
    component: Option[RemoteProcessGroupDTO] = None,
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    id: Option[String] = None,
    inputPortCount: Option[Int] = None,
    operatePermissions: Option[PermissionsDTO] = None,
    outputPortCount: Option[Int] = None,
    permissions: Option[PermissionsDTO] = None,
    position: Option[PositionDTO] = None,
    revision: Option[RevisionDTO] = None,
    status: Option[RemoteProcessGroupStatusDTO] = None,
    uri: Option[String] = None
  )
  case class FlowRegistryClientDTO (
    annotationData: Option[String] = None,
    bundle: Option[BundleDTO] = None,
    deprecated: Option[Boolean] = None,
    description: Option[String] = None,
    descriptors: Option[Map[String, PropertyDescriptorDTO]] = None,
    extensionMissing: Option[Boolean] = None,
    id: Option[String] = None,
    multipleVersionsAvailable: Option[Boolean] = None,
    name: Option[String] = None,
    properties: Option[Map[String, String]] = None,
    restricted: Option[Boolean] = None,
    sensitiveDynamicPropertyNames: Option[Set[String]] = None,
    supportsBranching: Option[Boolean] = None,
    supportsSensitiveDynamicProperties: Option[Boolean] = None,
    `type`: Option[String] = None,
    validationErrors: Option[Seq[String]] = None,
    validationStatus: Option[FlowRegistryClientDTOValidationStatus] = None
  )
  
  sealed trait FlowRegistryClientDTOValidationStatus extends enumeratum.EnumEntry
  object FlowRegistryClientDTOValidationStatus extends enumeratum.Enum[FlowRegistryClientDTOValidationStatus] with enumeratum.CirceEnum[FlowRegistryClientDTOValidationStatus] {
    val values = findValues
    case object VALID extends FlowRegistryClientDTOValidationStatus
    case object INVALID extends FlowRegistryClientDTOValidationStatus
    case object VALIDATING extends FlowRegistryClientDTOValidationStatus
  }
  case class ControllerDTO (
    activeRemotePortCount: Option[Int] = None,
    comments: Option[String] = None,
    disabledCount: Option[Int] = None,
    id: Option[String] = None,
    inactiveRemotePortCount: Option[Int] = None,
    inputPortCount: Option[Int] = None,
    inputPorts: Option[Set[PortDTO]] = None,
    instanceId: Option[String] = None,
    invalidCount: Option[Int] = None,
    name: Option[String] = None,
    outputPortCount: Option[Int] = None,
    outputPorts: Option[Set[PortDTO]] = None,
    remoteSiteHttpListeningPort: Option[Int] = None,
    remoteSiteListeningPort: Option[Int] = None,
    runningCount: Option[Int] = None,
    siteToSiteSecure: Option[Boolean] = None,
    stoppedCount: Option[Int] = None
  )
  case class ControllerServiceTypesEntity (
    controllerServiceTypes: Option[Set[DocumentedTypeDTO]] = None
  )
  case class ProcessorRunStatusEntity (
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    revision: Option[RevisionDTO] = None,
    state: Option[ProcessorRunStatusEntityState] = None
  )
  
  sealed trait ProcessorRunStatusEntityState extends enumeratum.EnumEntry
  object ProcessorRunStatusEntityState extends enumeratum.Enum[ProcessorRunStatusEntityState] with enumeratum.CirceEnum[ProcessorRunStatusEntityState] {
    val values = findValues
    case object RUNNING extends ProcessorRunStatusEntityState
    case object STOPPED extends ProcessorRunStatusEntityState
    case object DISABLED extends ProcessorRunStatusEntityState
    case object RUN_ONCE extends ProcessorRunStatusEntityState
  }
  case class NodeEventDTO (
    category: Option[String] = None,
    message: Option[String] = None,
    timestamp: Option[String] = None
  )
  case class DefinedType (
    artifact: Option[String] = None,
    group: Option[String] = None,
    `type`: Option[String] = None,
    typeDescription: Option[String] = None,
    version: Option[String] = None
  )
  case class ParameterProviderReference (
    bundle: Option[Bundle] = None,
    identifier: Option[String] = None,
    name: Option[String] = None,
    `type`: Option[String] = None
  )
  case class ProcessorStatusDTO (
    aggregateSnapshot: Option[ProcessorStatusSnapshotDTO] = None,
    groupId: Option[String] = None,
    id: Option[String] = None,
    name: Option[String] = None,
    nodeSnapshots: Option[Seq[NodeProcessorStatusSnapshotDTO]] = None,
    runStatus: Option[ProcessorStatusDTORunStatus] = None,
    statsLastRefreshed: Option[String] = None,
    `type`: Option[String] = None
  )
  
  sealed trait ProcessorStatusDTORunStatus extends enumeratum.EnumEntry
  object ProcessorStatusDTORunStatus extends enumeratum.Enum[ProcessorStatusDTORunStatus] with enumeratum.CirceEnum[ProcessorStatusDTORunStatus] {
    val values = findValues
    case object Running extends ProcessorStatusDTORunStatus
    case object Stopped extends ProcessorStatusDTORunStatus
    case object Validating extends ProcessorStatusDTORunStatus
    case object Disabled extends ProcessorStatusDTORunStatus
    case object Invalid extends ProcessorStatusDTORunStatus
  }
  case class RunStatusDetailsRequestEntity (
    processorIds: Option[Set[String]] = None
  )
  case class CurrentUserEntity (
    anonymous: Option[Boolean] = None,
    canVersionFlows: Option[Boolean] = None,
    componentRestrictionPermissions: Option[Set[ComponentRestrictionPermissionDTO]] = None,
    controllerPermissions: Option[PermissionsDTO] = None,
    countersPermissions: Option[PermissionsDTO] = None,
    identity: Option[String] = None,
    logoutSupported: Option[Boolean] = None,
    parameterContextPermissions: Option[PermissionsDTO] = None,
    policiesPermissions: Option[PermissionsDTO] = None,
    provenancePermissions: Option[PermissionsDTO] = None,
    restrictedComponentsPermissions: Option[PermissionsDTO] = None,
    systemPermissions: Option[PermissionsDTO] = None,
    tenantsPermissions: Option[PermissionsDTO] = None
  )
  case class ClusterSearchResultsEntity (
    nodeResults: Option[Seq[NodeSearchResultDTO]] = None
  )
  case class ProvenanceEntity (
    provenance: Option[ProvenanceDTO] = None
  )
  case class ProvenanceSearchableFieldDTO (
    field: Option[String] = None,
    id: Option[String] = None,
    label: Option[String] = None,
    `type`: Option[String] = None
  )
  case class ParameterContextUpdateRequestDTO (
    complete: Option[Boolean] = None,
    failureReason: Option[String] = None,
    lastUpdated: Option[java.time.Instant] = None,
    parameterContext: Option[ParameterContextDTO] = None,
    percentCompleted: Option[Int] = None,
    referencingComponents: Option[Set[AffectedComponentEntity]] = None,
    requestId: Option[String] = None,
    state: Option[String] = None,
    submissionTime: Option[java.time.Instant] = None,
    updateSteps: Option[Seq[ParameterContextUpdateStepDTO]] = None,
    uri: Option[String] = None
  )
  case class VersionedReportingTask (
    annotationData: Option[String] = None,
    bundle: Option[Bundle] = None,
    comments: Option[String] = None,
    componentType: Option[VersionedReportingTaskComponentType] = None,
    groupIdentifier: Option[String] = None,
    identifier: Option[String] = None,
    instanceIdentifier: Option[String] = None,
    name: Option[String] = None,
    position: Option[Position] = None,
    properties: Option[Map[String, String]] = None,
    propertyDescriptors: Option[Map[String, VersionedPropertyDescriptor]] = None,
    scheduledState: Option[VersionedReportingTaskScheduledState] = None,
    schedulingPeriod: Option[String] = None,
    schedulingStrategy: Option[String] = None,
    `type`: Option[String] = None
  )
  
  sealed trait VersionedReportingTaskComponentType extends enumeratum.EnumEntry
  object VersionedReportingTaskComponentType extends enumeratum.Enum[VersionedReportingTaskComponentType] with enumeratum.CirceEnum[VersionedReportingTaskComponentType] {
    val values = findValues
    case object CONNECTION extends VersionedReportingTaskComponentType
    case object PROCESSOR extends VersionedReportingTaskComponentType
    case object PROCESS_GROUP extends VersionedReportingTaskComponentType
    case object REMOTE_PROCESS_GROUP extends VersionedReportingTaskComponentType
    case object INPUT_PORT extends VersionedReportingTaskComponentType
    case object OUTPUT_PORT extends VersionedReportingTaskComponentType
    case object REMOTE_INPUT_PORT extends VersionedReportingTaskComponentType
    case object REMOTE_OUTPUT_PORT extends VersionedReportingTaskComponentType
    case object FUNNEL extends VersionedReportingTaskComponentType
    case object LABEL extends VersionedReportingTaskComponentType
    case object CONTROLLER_SERVICE extends VersionedReportingTaskComponentType
    case object REPORTING_TASK extends VersionedReportingTaskComponentType
    case object FLOW_ANALYSIS_RULE extends VersionedReportingTaskComponentType
    case object PARAMETER_CONTEXT extends VersionedReportingTaskComponentType
    case object PARAMETER_PROVIDER extends VersionedReportingTaskComponentType
    case object FLOW_REGISTRY_CLIENT extends VersionedReportingTaskComponentType
  }
  
  sealed trait VersionedReportingTaskScheduledState extends enumeratum.EnumEntry
  object VersionedReportingTaskScheduledState extends enumeratum.Enum[VersionedReportingTaskScheduledState] with enumeratum.CirceEnum[VersionedReportingTaskScheduledState] {
    val values = findValues
    case object ENABLED extends VersionedReportingTaskScheduledState
    case object DISABLED extends VersionedReportingTaskScheduledState
    case object RUNNING extends VersionedReportingTaskScheduledState
  }
  case class UseCase (
    configuration: Option[String] = None,
    description: Option[String] = None,
    inputRequirement: Option[UseCaseInputRequirement] = None,
    keywords: Option[Seq[String]] = None,
    notes: Option[String] = None
  )
  
  sealed trait UseCaseInputRequirement extends enumeratum.EnumEntry
  object UseCaseInputRequirement extends enumeratum.Enum[UseCaseInputRequirement] with enumeratum.CirceEnum[UseCaseInputRequirement] {
    val values = findValues
    case object INPUT_REQUIRED extends UseCaseInputRequirement
    case object INPUT_ALLOWED extends UseCaseInputRequirement
    case object INPUT_FORBIDDEN extends UseCaseInputRequirement
  }
  case class ConnectionStatusPredictionsSnapshotDTO (
    predictedBytesAtNextInterval: Option[Long] = None,
    predictedCountAtNextInterval: Option[Int] = None,
    predictedMillisUntilBytesBackpressure: Option[Long] = None,
    predictedMillisUntilCountBackpressure: Option[Long] = None,
    predictedPercentBytes: Option[Int] = None,
    predictedPercentCount: Option[Int] = None,
    predictionIntervalSeconds: Option[Int] = None
  )
  case class AssetEntity (
    asset: Option[AssetDTO] = None
  )
  case class ProcessingPerformanceStatusDTO (
    contentReadDuration: Option[Long] = None,
    contentWriteDuration: Option[Long] = None,
    cpuDuration: Option[Long] = None,
    garbageCollectionDuration: Option[Long] = None,
    identifier: Option[String] = None,
    sessionCommitDuration: Option[Long] = None
  )
  case class ControllerServicesEntity (
    controllerServices: Option[Set[ControllerServiceEntity]] = None,
    currentTime: Option[String] = None
  )
  case class PropertyHistoryDTO (
    previousValues: Option[Seq[PreviousValueDTO]] = None
  )
  case class RemotePortRunStatusEntity (
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    revision: Option[RevisionDTO] = None,
    state: Option[RemotePortRunStatusEntityState] = None
  )
  
  sealed trait RemotePortRunStatusEntityState extends enumeratum.EnumEntry
  object RemotePortRunStatusEntityState extends enumeratum.Enum[RemotePortRunStatusEntityState] with enumeratum.CirceEnum[RemotePortRunStatusEntityState] {
    val values = findValues
    case object TRANSMITTING extends RemotePortRunStatusEntityState
    case object STOPPED extends RemotePortRunStatusEntityState
  }
  case class ProcessorsEntity (
    processors: Option[Set[ProcessorEntity]] = None
  )
  case class PortStatusDTO (
    aggregateSnapshot: Option[PortStatusSnapshotDTO] = None,
    groupId: Option[String] = None,
    id: Option[String] = None,
    name: Option[String] = None,
    nodeSnapshots: Option[Seq[NodePortStatusSnapshotDTO]] = None,
    runStatus: Option[PortStatusDTORunStatus] = None,
    statsLastRefreshed: Option[String] = None,
    transmitting: Option[Boolean] = None
  )
  
  sealed trait PortStatusDTORunStatus extends enumeratum.EnumEntry
  object PortStatusDTORunStatus extends enumeratum.Enum[PortStatusDTORunStatus] with enumeratum.CirceEnum[PortStatusDTORunStatus] {
    val values = findValues
    case object Running extends PortStatusDTORunStatus
    case object Stopped extends PortStatusDTORunStatus
    case object Validating extends PortStatusDTORunStatus
    case object Disabled extends PortStatusDTORunStatus
    case object Invalid extends PortStatusDTORunStatus
  }
  case class ProcessGroupsEntity (
    processGroups: Option[Set[ProcessGroupEntity]] = None
  )
  case class RemoteProcessGroupStatusSnapshotDTO (
    activeThreadCount: Option[Int] = None,
    bytesReceived: Option[Long] = None,
    bytesSent: Option[Long] = None,
    flowFilesReceived: Option[Int] = None,
    flowFilesSent: Option[Int] = None,
    groupId: Option[String] = None,
    id: Option[String] = None,
    name: Option[String] = None,
    received: Option[String] = None,
    sent: Option[String] = None,
    targetUri: Option[String] = None,
    transmissionStatus: Option[String] = None
  )
  case class ParameterEntity (
    canWrite: Option[Boolean] = None,
    parameter: Option[ParameterDTO] = None
  )
  case class AccessPolicySummaryDTO (
    action: Option[AccessPolicySummaryDTOAction] = None,
    componentReference: Option[ComponentReferenceEntity] = None,
    configurable: Option[Boolean] = None,
    id: Option[String] = None,
    parentGroupId: Option[String] = None,
    position: Option[PositionDTO] = None,
    resource: Option[String] = None,
    versionedComponentId: Option[String] = None
  )
  
  sealed trait AccessPolicySummaryDTOAction extends enumeratum.EnumEntry
  object AccessPolicySummaryDTOAction extends enumeratum.Enum[AccessPolicySummaryDTOAction] with enumeratum.CirceEnum[AccessPolicySummaryDTOAction] {
    val values = findValues
    case object read extends AccessPolicySummaryDTOAction
  }
  case class FlowSnippetDTO (
    connections: Option[Set[ConnectionDTO]] = None,
    controllerServices: Option[Set[ControllerServiceDTO]] = None,
    funnels: Option[Set[FunnelDTO]] = None,
    inputPorts: Option[Set[PortDTO]] = None,
    labels: Option[Set[LabelDTO]] = None,
    outputPorts: Option[Set[PortDTO]] = None,
    processGroups: Option[Set[ProcessGroupDTO]] = None,
    processors: Option[Set[ProcessorDTO]] = None,
    remoteProcessGroups: Option[Set[RemoteProcessGroupDTO]] = None
  )
  case class AffectedComponentDTO (
    activeThreadCount: Option[Int] = None,
    id: Option[String] = None,
    name: Option[String] = None,
    processGroupId: Option[String] = None,
    referenceType: Option[AffectedComponentDTOReferenceType] = None,
    state: Option[String] = None,
    validationErrors: Option[Seq[String]] = None
  )
  
  sealed trait AffectedComponentDTOReferenceType extends enumeratum.EnumEntry
  object AffectedComponentDTOReferenceType extends enumeratum.Enum[AffectedComponentDTOReferenceType] with enumeratum.CirceEnum[AffectedComponentDTOReferenceType] {
    val values = findValues
    case object PROCESSOR extends AffectedComponentDTOReferenceType
    case object CONTROLLER_SERVICE extends AffectedComponentDTOReferenceType
    case object INPUT_PORT extends AffectedComponentDTOReferenceType
    case object OUTPUT_PORT extends AffectedComponentDTOReferenceType
    case object REMOTE_INPUT_PORT extends AffectedComponentDTOReferenceType
    case object REMOTE_OUTPUT_PORT extends AffectedComponentDTOReferenceType
    case object STATELESS_GROUP extends AffectedComponentDTOReferenceType
  }
  case class ProcessorEntity (
    bulletins: Option[Seq[BulletinEntity]] = None,
    component: Option[ProcessorDTO] = None,
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    id: Option[String] = None,
    inputRequirement: Option[String] = None,
    operatePermissions: Option[PermissionsDTO] = None,
    permissions: Option[PermissionsDTO] = None,
    position: Option[PositionDTO] = None,
    revision: Option[RevisionDTO] = None,
    status: Option[ProcessorStatusDTO] = None,
    uri: Option[String] = None
  )
  case class ParameterGroupConfigurationEntity (
    groupName: Option[String] = None,
    parameterContextName: Option[String] = None,
    parameterSensitivities: Option[Map[String, ParameterGroupConfigurationEntityParameterSensitivitiesItem]] = None,
    synchronized: Option[Boolean] = None
  )
  
  sealed trait ParameterGroupConfigurationEntityParameterSensitivitiesItem extends enumeratum.EnumEntry
  object ParameterGroupConfigurationEntityParameterSensitivitiesItem extends enumeratum.Enum[ParameterGroupConfigurationEntityParameterSensitivitiesItem] with enumeratum.CirceEnum[ParameterGroupConfigurationEntityParameterSensitivitiesItem] {
    val values = findValues
    case object SENSITIVE extends ParameterGroupConfigurationEntityParameterSensitivitiesItem
    case object NON_SENSITIVE extends ParameterGroupConfigurationEntityParameterSensitivitiesItem
  }
  case class UserGroupsEntity (
    userGroups: Option[Seq[UserGroupEntity]] = None
  )
  case class InputPortsEntity (
    inputPorts: Option[Set[PortEntity]] = None
  )
  case class ParameterProviderTypesEntity (
    parameterProviderTypes: Option[Set[DocumentedTypeDTO]] = None
  )
  case class AccessPolicyEntity (
    bulletins: Option[Seq[BulletinEntity]] = None,
    component: Option[AccessPolicyDTO] = None,
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    generated: Option[String] = None,
    id: Option[String] = None,
    permissions: Option[PermissionsDTO] = None,
    position: Option[PositionDTO] = None,
    revision: Option[RevisionDTO] = None,
    uri: Option[String] = None
  )
  case class VersionedPropertyDescriptor (
    displayName: Option[String] = None,
    dynamic: Option[Boolean] = None,
    identifiesControllerService: Option[Boolean] = None,
    name: Option[String] = None,
    resourceDefinition: Option[VersionedResourceDefinition] = None,
    sensitive: Option[Boolean] = None
  )
  case class PortEntity (
    allowRemoteAccess: Option[Boolean] = None,
    bulletins: Option[Seq[BulletinEntity]] = None,
    component: Option[PortDTO] = None,
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    id: Option[String] = None,
    operatePermissions: Option[PermissionsDTO] = None,
    permissions: Option[PermissionsDTO] = None,
    portType: Option[String] = None,
    position: Option[PositionDTO] = None,
    revision: Option[RevisionDTO] = None,
    status: Option[PortStatusDTO] = None,
    uri: Option[String] = None
  )
  case class ParameterContextValidationStepDTO (
    complete: Option[Boolean] = None,
    description: Option[String] = None,
    failureReason: Option[String] = None
  )
  case class ControllerConfigurationDTO (
    maxTimerDrivenThreadCount: Option[Int] = None
  )
  case class CreateActiveRequestEntity (
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    processGroupId: Option[String] = None
  )
  case class VersionedProcessGroup (
    comments: Option[String] = None,
    componentType: Option[VersionedProcessGroupComponentType] = None,
    connections: Option[Set[VersionedConnection]] = None,
    controllerServices: Option[Set[VersionedControllerService]] = None,
    defaultBackPressureDataSizeThreshold: Option[String] = None,
    defaultBackPressureObjectThreshold: Option[Long] = None,
    defaultFlowFileExpiration: Option[String] = None,
    executionEngine: Option[VersionedProcessGroupExecutionEngine] = None,
    flowFileConcurrency: Option[String] = None,
    flowFileOutboundPolicy: Option[String] = None,
    funnels: Option[Set[VersionedFunnel]] = None,
    groupIdentifier: Option[String] = None,
    identifier: Option[String] = None,
    inputPorts: Option[Set[VersionedPort]] = None,
    instanceIdentifier: Option[String] = None,
    labels: Option[Set[VersionedLabel]] = None,
    logFileSuffix: Option[String] = None,
    maxConcurrentTasks: Option[Int] = None,
    name: Option[String] = None,
    outputPorts: Option[Set[VersionedPort]] = None,
    parameterContextName: Option[String] = None,
    position: Option[Position] = None,
    processGroups: Option[Set[VersionedProcessGroup]] = None,
    processors: Option[Set[VersionedProcessor]] = None,
    remoteProcessGroups: Option[Set[VersionedRemoteProcessGroup]] = None,
    scheduledState: Option[VersionedProcessGroupScheduledState] = None,
    statelessFlowTimeout: Option[String] = None,
    versionedFlowCoordinates: Option[VersionedFlowCoordinates] = None
  )
  
  sealed trait VersionedProcessGroupComponentType extends enumeratum.EnumEntry
  object VersionedProcessGroupComponentType extends enumeratum.Enum[VersionedProcessGroupComponentType] with enumeratum.CirceEnum[VersionedProcessGroupComponentType] {
    val values = findValues
    case object CONNECTION extends VersionedProcessGroupComponentType
    case object PROCESSOR extends VersionedProcessGroupComponentType
    case object PROCESS_GROUP extends VersionedProcessGroupComponentType
    case object REMOTE_PROCESS_GROUP extends VersionedProcessGroupComponentType
    case object INPUT_PORT extends VersionedProcessGroupComponentType
    case object OUTPUT_PORT extends VersionedProcessGroupComponentType
    case object REMOTE_INPUT_PORT extends VersionedProcessGroupComponentType
    case object REMOTE_OUTPUT_PORT extends VersionedProcessGroupComponentType
    case object FUNNEL extends VersionedProcessGroupComponentType
    case object LABEL extends VersionedProcessGroupComponentType
    case object CONTROLLER_SERVICE extends VersionedProcessGroupComponentType
    case object REPORTING_TASK extends VersionedProcessGroupComponentType
    case object FLOW_ANALYSIS_RULE extends VersionedProcessGroupComponentType
    case object PARAMETER_CONTEXT extends VersionedProcessGroupComponentType
    case object PARAMETER_PROVIDER extends VersionedProcessGroupComponentType
    case object FLOW_REGISTRY_CLIENT extends VersionedProcessGroupComponentType
  }
  
  sealed trait VersionedProcessGroupExecutionEngine extends enumeratum.EnumEntry
  object VersionedProcessGroupExecutionEngine extends enumeratum.Enum[VersionedProcessGroupExecutionEngine] with enumeratum.CirceEnum[VersionedProcessGroupExecutionEngine] {
    val values = findValues
    case object STANDARD extends VersionedProcessGroupExecutionEngine
    case object STATELESS extends VersionedProcessGroupExecutionEngine
    case object INHERITED extends VersionedProcessGroupExecutionEngine
  }
  
  sealed trait VersionedProcessGroupScheduledState extends enumeratum.EnumEntry
  object VersionedProcessGroupScheduledState extends enumeratum.Enum[VersionedProcessGroupScheduledState] with enumeratum.CirceEnum[VersionedProcessGroupScheduledState] {
    val values = findValues
    case object ENABLED extends VersionedProcessGroupScheduledState
    case object DISABLED extends VersionedProcessGroupScheduledState
    case object RUNNING extends VersionedProcessGroupScheduledState
  }
  case class ConnectionStatusSnapshotEntity (
    canRead: Option[Boolean] = None,
    connectionStatusSnapshot: Option[ConnectionStatusSnapshotDTO] = None,
    id: Option[String] = None
  )
  case class PeersEntity (
    peers: Option[Seq[PeerDTO]] = None
  )
  case class ControllerStatusDTO (
    activeRemotePortCount: Option[Int] = None,
    activeThreadCount: Option[Int] = None,
    bytesQueued: Option[Long] = None,
    disabledCount: Option[Int] = None,
    flowFilesQueued: Option[Int] = None,
    inactiveRemotePortCount: Option[Int] = None,
    invalidCount: Option[Int] = None,
    locallyModifiedAndStaleCount: Option[Int] = None,
    locallyModifiedCount: Option[Int] = None,
    queued: Option[String] = None,
    runningCount: Option[Int] = None,
    staleCount: Option[Int] = None,
    stoppedCount: Option[Int] = None,
    syncFailureCount: Option[Int] = None,
    terminatedThreadCount: Option[Int] = None,
    upToDateCount: Option[Int] = None
  )
  case class PermissionsDTO (
    canRead: Option[Boolean] = None,
    canWrite: Option[Boolean] = None
  )
  case class RemoteProcessGroupStatusEntity (
    canRead: Option[Boolean] = None,
    remoteProcessGroupStatus: Option[RemoteProcessGroupStatusDTO] = None
  )
  case class ProcessorStatusSnapshotDTO (
    activeThreadCount: Option[Int] = None,
    bytesIn: Option[Long] = None,
    bytesOut: Option[Long] = None,
    bytesRead: Option[Long] = None,
    bytesWritten: Option[Long] = None,
    executionNode: Option[ProcessorStatusSnapshotDTOExecutionNode] = None,
    flowFilesIn: Option[Int] = None,
    flowFilesOut: Option[Int] = None,
    groupId: Option[String] = None,
    id: Option[String] = None,
    input: Option[String] = None,
    name: Option[String] = None,
    output: Option[String] = None,
    processingPerformanceStatus: Option[ProcessingPerformanceStatusDTO] = None,
    read: Option[String] = None,
    runStatus: Option[ProcessorStatusSnapshotDTORunStatus] = None,
    taskCount: Option[Int] = None,
    tasks: Option[String] = None,
    tasksDuration: Option[String] = None,
    tasksDurationNanos: Option[Long] = None,
    terminatedThreadCount: Option[Int] = None,
    `type`: Option[String] = None,
    written: Option[String] = None
  )
  
  sealed trait ProcessorStatusSnapshotDTOExecutionNode extends enumeratum.EnumEntry
  object ProcessorStatusSnapshotDTOExecutionNode extends enumeratum.Enum[ProcessorStatusSnapshotDTOExecutionNode] with enumeratum.CirceEnum[ProcessorStatusSnapshotDTOExecutionNode] {
    val values = findValues
    case object ALL extends ProcessorStatusSnapshotDTOExecutionNode
    case object PRIMARY extends ProcessorStatusSnapshotDTOExecutionNode
  }
  
  sealed trait ProcessorStatusSnapshotDTORunStatus extends enumeratum.EnumEntry
  object ProcessorStatusSnapshotDTORunStatus extends enumeratum.Enum[ProcessorStatusSnapshotDTORunStatus] with enumeratum.CirceEnum[ProcessorStatusSnapshotDTORunStatus] {
    val values = findValues
    case object Running extends ProcessorStatusSnapshotDTORunStatus
    case object Stopped extends ProcessorStatusSnapshotDTORunStatus
    case object Validating extends ProcessorStatusSnapshotDTORunStatus
    case object Disabled extends ProcessorStatusSnapshotDTORunStatus
    case object Invalid extends ProcessorStatusSnapshotDTORunStatus
  }
  case class FlowRegistryBranchDTO (
    name: Option[String] = None
  )
  case class ComponentReferenceEntity (
    bulletins: Option[Seq[BulletinEntity]] = None,
    component: Option[ComponentReferenceDTO] = None,
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    id: Option[String] = None,
    parentGroupId: Option[String] = None,
    permissions: Option[PermissionsDTO] = None,
    position: Option[PositionDTO] = None,
    revision: Option[RevisionDTO] = None,
    uri: Option[String] = None
  )
  case class ParameterContextValidationRequestDTO (
    complete: Option[Boolean] = None,
    componentValidationResults: Option[ComponentValidationResultsEntity] = None,
    failureReason: Option[String] = None,
    lastUpdated: Option[java.time.Instant] = None,
    parameterContext: Option[ParameterContextDTO] = None,
    percentCompleted: Option[Int] = None,
    requestId: Option[String] = None,
    state: Option[String] = None,
    submissionTime: Option[java.time.Instant] = None,
    updateSteps: Option[Seq[ParameterContextValidationStepDTO]] = None,
    uri: Option[String] = None
  )
  case class ComponentDetailsDTO (
  
  )
  case class StorageUsageDTO (
    freeSpace: Option[String] = None,
    freeSpaceBytes: Option[Long] = None,
    identifier: Option[String] = None,
    totalSpace: Option[String] = None,
    totalSpaceBytes: Option[Long] = None,
    usedSpace: Option[String] = None,
    usedSpaceBytes: Option[Long] = None,
    utilization: Option[String] = None
  )
  case class NodeEntity (
    node: Option[NodeDTO] = None
  )
  case class RemoteProcessGroupStatusDTO (
    aggregateSnapshot: Option[RemoteProcessGroupStatusSnapshotDTO] = None,
    groupId: Option[String] = None,
    id: Option[String] = None,
    name: Option[String] = None,
    nodeSnapshots: Option[Seq[NodeRemoteProcessGroupStatusSnapshotDTO]] = None,
    statsLastRefreshed: Option[String] = None,
    targetUri: Option[String] = None,
    transmissionStatus: Option[String] = None,
    validationStatus: Option[RemoteProcessGroupStatusDTOValidationStatus] = None
  )
  
  sealed trait RemoteProcessGroupStatusDTOValidationStatus extends enumeratum.EnumEntry
  object RemoteProcessGroupStatusDTOValidationStatus extends enumeratum.Enum[RemoteProcessGroupStatusDTOValidationStatus] with enumeratum.CirceEnum[RemoteProcessGroupStatusDTOValidationStatus] {
    val values = findValues
    case object VALID extends RemoteProcessGroupStatusDTOValidationStatus
    case object INVALID extends RemoteProcessGroupStatusDTOValidationStatus
    case object VALIDATING extends RemoteProcessGroupStatusDTOValidationStatus
  }
  case class AboutEntity (
    about: Option[AboutDTO] = None
  )
  case class BuildInfo (
    compiler: Option[String] = None,
    compilerFlags: Option[String] = None,
    revision: Option[String] = None,
    targetArch: Option[String] = None,
    timestamp: Option[Long] = None,
    version: Option[String] = None
  )
  case class TenantsEntity (
    userGroups: Option[Seq[TenantEntity]] = None,
    users: Option[Seq[TenantEntity]] = None
  )
  case class PropertyDependencyDTO (
    dependentValues: Option[Set[String]] = None,
    propertyName: Option[String] = None
  )
  case class AuthenticationConfigurationDTO (
    externalLoginRequired: Option[Boolean] = None,
    loginSupported: Option[Boolean] = None,
    loginUri: Option[String] = None,
    logoutUri: Option[String] = None
  )
  case class ParameterProviderDTO (
    affectedComponents: Option[Set[AffectedComponentEntity]] = None,
    annotationData: Option[String] = None,
    bundle: Option[BundleDTO] = None,
    comments: Option[String] = None,
    customUiUrl: Option[String] = None,
    deprecated: Option[Boolean] = None,
    descriptors: Option[Map[String, PropertyDescriptorDTO]] = None,
    extensionMissing: Option[Boolean] = None,
    id: Option[String] = None,
    multipleVersionsAvailable: Option[Boolean] = None,
    name: Option[String] = None,
    parameterGroupConfigurations: Option[Seq[ParameterGroupConfigurationEntity]] = None,
    parameterStatus: Option[Set[ParameterStatusDTO]] = None,
    parentGroupId: Option[String] = None,
    persistsState: Option[Boolean] = None,
    position: Option[PositionDTO] = None,
    properties: Option[Map[String, String]] = None,
    referencingParameterContexts: Option[Set[ParameterProviderReferencingComponentEntity]] = None,
    restricted: Option[Boolean] = None,
    `type`: Option[String] = None,
    validationErrors: Option[Seq[String]] = None,
    validationStatus: Option[ParameterProviderDTOValidationStatus] = None,
    versionedComponentId: Option[String] = None
  )
  
  sealed trait ParameterProviderDTOValidationStatus extends enumeratum.EnumEntry
  object ParameterProviderDTOValidationStatus extends enumeratum.Enum[ParameterProviderDTOValidationStatus] with enumeratum.CirceEnum[ParameterProviderDTOValidationStatus] {
    val values = findValues
    case object VALID extends ParameterProviderDTOValidationStatus
    case object INVALID extends ParameterProviderDTOValidationStatus
    case object VALIDATING extends ParameterProviderDTOValidationStatus
  }
  case class PortStatusEntity (
    canRead: Option[Boolean] = None,
    portStatus: Option[PortStatusDTO] = None
  )
  case class OutputPortsEntity (
    outputPorts: Option[Set[PortEntity]] = None
  )
  case class ProcessorsRunStatusDetailsEntity (
    runStatusDetails: Option[Seq[ProcessorRunStatusDetailsEntity]] = None
  )
  case class FlowRegistryBranchEntity (
    branch: Option[FlowRegistryBranchDTO] = None
  )
  case class ParameterProviderDefinition (
    additionalDetails: Option[Boolean] = None,
    artifact: Option[String] = None,
    buildInfo: Option[BuildInfo] = None,
    deprecated: Option[Boolean] = None,
    deprecationAlternatives: Option[Set[String]] = None,
    deprecationReason: Option[String] = None,
    dynamicProperties: Option[Seq[DynamicProperty]] = None,
    explicitRestrictions: Option[Set[Restriction]] = None,
    group: Option[String] = None,
    propertyDescriptors: Option[Map[String, PropertyDescriptor]] = None,
    providedApiImplementations: Option[Seq[DefinedType]] = None,
    restricted: Option[Boolean] = None,
    restrictedExplanation: Option[String] = None,
    seeAlso: Option[Set[String]] = None,
    stateful: Option[Stateful] = None,
    supportsDynamicProperties: Option[Boolean] = None,
    supportsSensitiveDynamicProperties: Option[Boolean] = None,
    systemResourceConsiderations: Option[Seq[SystemResourceConsideration]] = None,
    tags: Option[Set[String]] = None,
    `type`: Option[String] = None,
    typeDescription: Option[String] = None,
    version: Option[String] = None
  )
  case class ParameterContextDTO (
    boundProcessGroups: Option[Set[ProcessGroupEntity]] = None,
    description: Option[String] = None,
    id: Option[String] = None,
    inheritedParameterContexts: Option[Seq[ParameterContextReferenceEntity]] = None,
    name: Option[String] = None,
    parameterProviderConfiguration: Option[ParameterProviderConfigurationEntity] = None,
    parameters: Option[Set[ParameterEntity]] = None
  )
  case class ResourceClaimDetailsDTO (
    awaitingDestruction: Option[Boolean] = None,
    claimantCount: Option[Int] = None,
    container: Option[String] = None,
    identifier: Option[String] = None,
    inUse: Option[Boolean] = None,
    section: Option[String] = None,
    writable: Option[Boolean] = None
  )
  case class ProcessorDTO (
    bundle: Option[BundleDTO] = None,
    config: Option[ProcessorConfigDTO] = None,
    deprecated: Option[Boolean] = None,
    description: Option[String] = None,
    executionNodeRestricted: Option[Boolean] = None,
    extensionMissing: Option[Boolean] = None,
    id: Option[String] = None,
    inputRequirement: Option[String] = None,
    multipleVersionsAvailable: Option[Boolean] = None,
    name: Option[String] = None,
    parentGroupId: Option[String] = None,
    persistsState: Option[Boolean] = None,
    position: Option[PositionDTO] = None,
    relationships: Option[Seq[RelationshipDTO]] = None,
    restricted: Option[Boolean] = None,
    state: Option[ProcessorDTOState] = None,
    style: Option[Map[String, String]] = None,
    supportsBatching: Option[Boolean] = None,
    supportsParallelProcessing: Option[Boolean] = None,
    supportsSensitiveDynamicProperties: Option[Boolean] = None,
    `type`: Option[String] = None,
    validationErrors: Option[Seq[String]] = None,
    validationStatus: Option[ProcessorDTOValidationStatus] = None,
    versionedComponentId: Option[String] = None
  )
  
  sealed trait ProcessorDTOState extends enumeratum.EnumEntry
  object ProcessorDTOState extends enumeratum.Enum[ProcessorDTOState] with enumeratum.CirceEnum[ProcessorDTOState] {
    val values = findValues
    case object RUNNING extends ProcessorDTOState
    case object STOPPED extends ProcessorDTOState
    case object DISABLED extends ProcessorDTOState
  }
  
  sealed trait ProcessorDTOValidationStatus extends enumeratum.EnumEntry
  object ProcessorDTOValidationStatus extends enumeratum.Enum[ProcessorDTOValidationStatus] with enumeratum.CirceEnum[ProcessorDTOValidationStatus] {
    val values = findValues
    case object VALID extends ProcessorDTOValidationStatus
    case object INVALID extends ProcessorDTOValidationStatus
    case object VALIDATING extends ProcessorDTOValidationStatus
  }
  case class ConnectionStatisticsEntity (
    canRead: Option[Boolean] = None,
    connectionStatistics: Option[ConnectionStatisticsDTO] = None
  )
  case class FlowRegistryPermissions (
    canDelete: Option[Boolean] = None,
    canRead: Option[Boolean] = None,
    canWrite: Option[Boolean] = None
  )
  case class VersionedFlowUpdateRequestEntity (
    processGroupRevision: Option[RevisionDTO] = None,
    request: Option[VersionedFlowUpdateRequestDTO] = None
  )
  case class ControllerServiceAPI (
    bundle: Option[Bundle] = None,
    `type`: Option[String] = None
  )
  case class VersionedFlowUpdateRequestDTO (
    complete: Option[Boolean] = None,
    failureReason: Option[String] = None,
    lastUpdated: Option[String] = None,
    percentCompleted: Option[Int] = None,
    processGroupId: Option[String] = None,
    requestId: Option[String] = None,
    state: Option[String] = None,
    uri: Option[String] = None,
    versionControlInformation: Option[VersionControlInformationDTO] = None
  )
  case class PropertyDescriptorDTO (
    allowableValues: Option[Seq[AllowableValueEntity]] = None,
    defaultValue: Option[String] = None,
    dependencies: Option[Seq[PropertyDependencyDTO]] = None,
    description: Option[String] = None,
    displayName: Option[String] = None,
    dynamic: Option[Boolean] = None,
    expressionLanguageScope: Option[String] = None,
    identifiesControllerService: Option[String] = None,
    identifiesControllerServiceBundle: Option[BundleDTO] = None,
    name: Option[String] = None,
    required: Option[Boolean] = None,
    sensitive: Option[Boolean] = None,
    supportsEl: Option[Boolean] = None
  )
  case class BundleDTO (
    artifact: Option[String] = None,
    group: Option[String] = None,
    version: Option[String] = None
  )
  case class AboutDTO (
    buildBranch: Option[String] = None,
    buildRevision: Option[String] = None,
    buildTag: Option[String] = None,
    buildTimestamp: Option[String] = None,
    contentViewerUrl: Option[String] = None,
    timezone: Option[String] = None,
    title: Option[String] = None,
    uri: Option[String] = None,
    version: Option[String] = None
  )
  case class ClusterDTO (
    generated: Option[String] = None,
    nodes: Option[Seq[NodeDTO]] = None
  )
  case class LineageEntity (
    lineage: Option[LineageDTO] = None
  )
  case class PropertyDescriptor (
    allowableValues: Option[Seq[PropertyAllowableValue]] = None,
    defaultValue: Option[String] = None,
    dependencies: Option[Seq[PropertyDependency]] = None,
    description: Option[String] = None,
    displayName: Option[String] = None,
    dynamic: Option[Boolean] = None,
    expressionLanguageScope: Option[PropertyDescriptorExpressionLanguageScope] = None,
    expressionLanguageScopeDescription: Option[String] = None,
    name: Option[String] = None,
    required: Option[Boolean] = None,
    resourceDefinition: Option[PropertyResourceDefinition] = None,
    sensitive: Option[Boolean] = None,
    typeProvidedByValue: Option[DefinedType] = None,
    validRegex: Option[String] = None,
    validator: Option[String] = None
  )
  
  sealed trait PropertyDescriptorExpressionLanguageScope extends enumeratum.EnumEntry
  object PropertyDescriptorExpressionLanguageScope extends enumeratum.Enum[PropertyDescriptorExpressionLanguageScope] with enumeratum.CirceEnum[PropertyDescriptorExpressionLanguageScope] {
    val values = findValues
    case object NONE extends PropertyDescriptorExpressionLanguageScope
    case object ENVIRONMENT extends PropertyDescriptorExpressionLanguageScope
    case object FLOWFILE_ATTRIBUTES extends PropertyDescriptorExpressionLanguageScope
  }
  case class ProvenanceRequestDTO (
    clusterNodeId: Option[String] = None,
    endDate: Option[String] = None,
    incrementalResults: Option[Boolean] = None,
    maxResults: Option[Int] = None,
    maximumFileSize: Option[String] = None,
    minimumFileSize: Option[String] = None,
    searchTerms: Option[Map[String, ProvenanceSearchValueDTO]] = None,
    startDate: Option[String] = None,
    summarize: Option[Boolean] = None
  )
  type DateTimeParameterDT = java.time.Instant
  case class VerifyConfigRequestEntity (
    request: Option[VerifyConfigRequestDTO] = None
  )
  case class ComponentStateDTO (
    clusterState: Option[StateMapDTO] = None,
    componentId: Option[String] = None,
    dropStateKeySupported: Option[Boolean] = None,
    localState: Option[StateMapDTO] = None,
    stateDescription: Option[String] = None
  )
  case class ResourceDTO (
    identifier: Option[String] = None,
    name: Option[String] = None
  )
  case class StatusDescriptorDTO (
    description: Option[String] = None,
    field: Option[String] = None,
    formatter: Option[String] = None,
    label: Option[String] = None
  )
  case class ControllerStatusEntity (
    controllerStatus: Option[ControllerStatusDTO] = None
  )
  case class AuthenticationConfigurationEntity (
    authenticationConfiguration: Option[AuthenticationConfigurationDTO] = None
  )
  case class FlowRegistryClientTypesEntity (
    flowRegistryClientTypes: Option[Set[DocumentedTypeDTO]] = None
  )
  case class FlowComparisonEntity (
    componentDifferences: Option[Set[ComponentDifferenceDTO]] = None
  )
  case class TransactionResultEntity (
    flowFileSent: Option[Int] = None,
    message: Option[String] = None,
    responseCode: Option[Int] = None
  )
  case class ComponentDifferenceDTO (
    componentId: Option[String] = None,
    componentName: Option[String] = None,
    componentType: Option[String] = None,
    differences: Option[Seq[DifferenceDTO]] = None,
    processGroupId: Option[String] = None
  )
  case class ConfigVerificationResultDTO (
    explanation: Option[String] = None,
    outcome: Option[ConfigVerificationResultDTOOutcome] = None,
    verificationStepName: Option[String] = None
  )
  
  sealed trait ConfigVerificationResultDTOOutcome extends enumeratum.EnumEntry
  object ConfigVerificationResultDTOOutcome extends enumeratum.Enum[ConfigVerificationResultDTOOutcome] with enumeratum.CirceEnum[ConfigVerificationResultDTOOutcome] {
    val values = findValues
    case object SUCCESSFUL extends ConfigVerificationResultDTOOutcome
    case object FAILED extends ConfigVerificationResultDTOOutcome
    case object SKIPPED extends ConfigVerificationResultDTOOutcome
  }
  case class SystemDiagnosticsEntity (
    systemDiagnostics: Option[SystemDiagnosticsDTO] = None
  )
  case class ProvenanceOptionsDTO (
    searchableFields: Option[Seq[ProvenanceSearchableFieldDTO]] = None
  )
  case class ConnectableDTO (
    comments: Option[String] = None,
    exists: Option[Boolean] = None,
    groupId: String,
    id: String,
    name: Option[String] = None,
    running: Option[Boolean] = None,
    transmitting: Option[Boolean] = None,
    `type`: ConnectableDTOType,
    versionedComponentId: Option[String] = None
  )
  
  sealed trait ConnectableDTOType extends enumeratum.EnumEntry
  object ConnectableDTOType extends enumeratum.Enum[ConnectableDTOType] with enumeratum.CirceEnum[ConnectableDTOType] {
    val values = findValues
    case object PROCESSOR extends ConnectableDTOType
    case object REMOTE_INPUT_PORT extends ConnectableDTOType
    case object REMOTE_OUTPUT_PORT extends ConnectableDTOType
    case object INPUT_PORT extends ConnectableDTOType
    case object OUTPUT_PORT extends ConnectableDTOType
    case object FUNNEL extends ConnectableDTOType
  }
  case class VersionInfoDTO (
    buildBranch: Option[String] = None,
    buildRevision: Option[String] = None,
    buildTag: Option[String] = None,
    buildTimestamp: Option[java.time.Instant] = None,
    javaVendor: Option[String] = None,
    javaVersion: Option[String] = None,
    niFiVersion: Option[String] = None,
    osArchitecture: Option[String] = None,
    osName: Option[String] = None,
    osVersion: Option[String] = None
  )
  case class DimensionsDTO (
    height: Option[Double] = None,
    width: Option[Double] = None
  )
  case class HistoryDTO (
    actions: Option[Seq[ActionEntity]] = None,
    lastRefreshed: Option[String] = None,
    total: Option[Int] = None
  )
  case class ProcessorConfiguration (
    configuration: Option[String] = None,
    processorClassName: Option[String] = None
  )
  case class ControllerServiceRunStatusEntity (
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    revision: Option[RevisionDTO] = None,
    state: Option[ControllerServiceRunStatusEntityState] = None,
    uiOnly: Option[Boolean] = None
  )
  
  sealed trait ControllerServiceRunStatusEntityState extends enumeratum.EnumEntry
  object ControllerServiceRunStatusEntityState extends enumeratum.Enum[ControllerServiceRunStatusEntityState] with enumeratum.CirceEnum[ControllerServiceRunStatusEntityState] {
    val values = findValues
    case object ENABLED extends ControllerServiceRunStatusEntityState
    case object DISABLED extends ControllerServiceRunStatusEntityState
  }
  case class BulletinDTO (
    category: Option[String] = None,
    groupId: Option[String] = None,
    id: Option[Long] = None,
    level: Option[String] = None,
    message: Option[String] = None,
    nodeAddress: Option[String] = None,
    sourceId: Option[String] = None,
    sourceName: Option[String] = None,
    sourceType: Option[String] = None,
    timestamp: Option[String] = None
  )
  case class FlowFileDTO (
    attributes: Option[Map[String, String]] = None,
    clusterNodeAddress: Option[String] = None,
    clusterNodeId: Option[String] = None,
    contentClaimContainer: Option[String] = None,
    contentClaimFileSize: Option[String] = None,
    contentClaimFileSizeBytes: Option[Long] = None,
    contentClaimIdentifier: Option[String] = None,
    contentClaimOffset: Option[Long] = None,
    contentClaimSection: Option[String] = None,
    filename: Option[String] = None,
    lineageDuration: Option[Long] = None,
    mimeType: Option[String] = None,
    penalized: Option[Boolean] = None,
    penaltyExpiresIn: Option[Long] = None,
    position: Option[Int] = None,
    queuedDuration: Option[Long] = None,
    size: Option[Long] = None,
    uri: Option[String] = None,
    uuid: Option[String] = None
  )
  case class ParameterProviderApplyParametersUpdateStepDTO (
    complete: Option[Boolean] = None,
    description: Option[String] = None,
    failureReason: Option[String] = None
  )
  case class RegisteredFlow (
    branch: Option[String] = None,
    bucketIdentifier: Option[String] = None,
    bucketName: Option[String] = None,
    createdTimestamp: Option[Long] = None,
    description: Option[String] = None,
    identifier: Option[String] = None,
    lastModifiedTimestamp: Option[Long] = None,
    name: Option[String] = None,
    permissions: Option[FlowRegistryPermissions] = None,
    versionCount: Option[Long] = None,
    versionInfo: Option[RegisteredFlowVersionInfo] = None
  )
  case class FlowRegistryBucketsEntity (
    buckets: Option[Set[FlowRegistryBucketEntity]] = None
  )
  case class ActionDTO (
    actionDetails: Option[ActionDetailsDTO] = None,
    componentDetails: Option[ComponentDetailsDTO] = None,
    id: Option[Int] = None,
    operation: Option[String] = None,
    sourceId: Option[String] = None,
    sourceName: Option[String] = None,
    sourceType: Option[String] = None,
    timestamp: Option[String] = None,
    userIdentity: Option[String] = None
  )
  case class UserDTO (
    accessPolicies: Option[Set[AccessPolicySummaryEntity]] = None,
    configurable: Option[Boolean] = None,
    id: Option[String] = None,
    identity: Option[String] = None,
    parentGroupId: Option[String] = None,
    position: Option[PositionDTO] = None,
    userGroups: Option[Set[TenantEntity]] = None,
    versionedComponentId: Option[String] = None
  )
  case class RemoteProcessGroupContentsDTO (
    inputPorts: Option[Set[RemoteProcessGroupPortDTO]] = None,
    outputPorts: Option[Set[RemoteProcessGroupPortDTO]] = None
  )
  case class VersionedFlowSnapshotEntity (
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    processGroupRevision: Option[RevisionDTO] = None,
    registryId: Option[String] = None,
    updateDescendantVersionedFlows: Option[Boolean] = None,
    versionedFlow: Option[RegisteredFlowSnapshot] = None,
    versionedFlowSnapshot: Option[RegisteredFlowSnapshot] = None
  )
  case class UpdateControllerServiceReferenceRequestEntity (
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    id: Option[String] = None,
    referencingComponentRevisions: Option[Map[String, RevisionDTO]] = None,
    state: Option[UpdateControllerServiceReferenceRequestEntityState] = None,
    uiOnly: Option[Boolean] = None
  )
  
  sealed trait UpdateControllerServiceReferenceRequestEntityState extends enumeratum.EnumEntry
  object UpdateControllerServiceReferenceRequestEntityState extends enumeratum.Enum[UpdateControllerServiceReferenceRequestEntityState] with enumeratum.CirceEnum[UpdateControllerServiceReferenceRequestEntityState] {
    val values = findValues
    case object ENABLED extends UpdateControllerServiceReferenceRequestEntityState
    case object DISABLED extends UpdateControllerServiceReferenceRequestEntityState
    case object RUNNING extends UpdateControllerServiceReferenceRequestEntityState
    case object STOPPED extends UpdateControllerServiceReferenceRequestEntityState
  }
  case class LatestProvenanceEventsDTO (
    componentId: Option[String] = None,
    provenanceEvents: Option[Seq[ProvenanceEventDTO]] = None
  )
  case class PropertyDependency (
    dependentValues: Option[Seq[String]] = None,
    propertyDisplayName: Option[String] = None,
    propertyName: Option[String] = None
  )
  case class ControllerServiceDefinition (
    additionalDetails: Option[Boolean] = None,
    artifact: Option[String] = None,
    buildInfo: Option[BuildInfo] = None,
    deprecated: Option[Boolean] = None,
    deprecationAlternatives: Option[Set[String]] = None,
    deprecationReason: Option[String] = None,
    dynamicProperties: Option[Seq[DynamicProperty]] = None,
    explicitRestrictions: Option[Set[Restriction]] = None,
    group: Option[String] = None,
    propertyDescriptors: Option[Map[String, PropertyDescriptor]] = None,
    providedApiImplementations: Option[Seq[DefinedType]] = None,
    restricted: Option[Boolean] = None,
    restrictedExplanation: Option[String] = None,
    seeAlso: Option[Set[String]] = None,
    stateful: Option[Stateful] = None,
    supportsDynamicProperties: Option[Boolean] = None,
    supportsSensitiveDynamicProperties: Option[Boolean] = None,
    systemResourceConsiderations: Option[Seq[SystemResourceConsideration]] = None,
    tags: Option[Set[String]] = None,
    `type`: Option[String] = None,
    typeDescription: Option[String] = None,
    version: Option[String] = None
  )
  case class ContentViewerDTO (
    displayName: Option[String] = None,
    supportedMimeTypes: Option[Seq[SupportedMimeTypesDTO]] = None,
    uri: Option[String] = None
  )
  case class PropertyDescriptorEntity (
    propertyDescriptor: Option[PropertyDescriptorDTO] = None
  )
  case class VersionControlInformationEntity (
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    processGroupRevision: Option[RevisionDTO] = None,
    versionControlInformation: Option[VersionControlInformationDTO] = None
  )
  case class JmxMetricsResultDTO (
    attributeName: Option[String] = None,
    attributeValue: Option[JmxMetricsResultDTOAttributeValue] = None,
    beanName: Option[String] = None
  )
  case class JmxMetricsResultDTOAttributeValue (
  
  )
  type BulletinBoardPatternParameterStr = String
  case class BulletinEntity (
    bulletin: Option[BulletinDTO] = None,
    canRead: Option[Boolean] = None,
    groupId: Option[String] = None,
    id: Option[Long] = None,
    nodeAddress: Option[String] = None,
    sourceId: Option[String] = None,
    timestamp: Option[String] = None
  )
  case class AccessPolicyDTO (
    action: Option[AccessPolicyDTOAction] = None,
    componentReference: Option[ComponentReferenceEntity] = None,
    configurable: Option[Boolean] = None,
    id: Option[String] = None,
    parentGroupId: Option[String] = None,
    position: Option[PositionDTO] = None,
    resource: Option[String] = None,
    userGroups: Option[Set[TenantEntity]] = None,
    users: Option[Set[TenantEntity]] = None,
    versionedComponentId: Option[String] = None
  )
  
  sealed trait AccessPolicyDTOAction extends enumeratum.EnumEntry
  object AccessPolicyDTOAction extends enumeratum.Enum[AccessPolicyDTOAction] with enumeratum.CirceEnum[AccessPolicyDTOAction] {
    val values = findValues
    case object read extends AccessPolicyDTOAction
  }
  case class ProcessGroupEntity (
    activeRemotePortCount: Option[Int] = None,
    bulletins: Option[Seq[BulletinEntity]] = None,
    component: Option[ProcessGroupDTO] = None,
    disabledCount: Option[Int] = None,
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    id: Option[String] = None,
    inactiveRemotePortCount: Option[Int] = None,
    inputPortCount: Option[Int] = None,
    invalidCount: Option[Int] = None,
    localInputPortCount: Option[Int] = None,
    localOutputPortCount: Option[Int] = None,
    locallyModifiedAndStaleCount: Option[Int] = None,
    locallyModifiedCount: Option[Int] = None,
    outputPortCount: Option[Int] = None,
    parameterContext: Option[ParameterContextReferenceEntity] = None,
    permissions: Option[PermissionsDTO] = None,
    position: Option[PositionDTO] = None,
    processGroupUpdateStrategy: Option[ProcessGroupEntityProcessGroupUpdateStrategy] = None,
    publicInputPortCount: Option[Int] = None,
    publicOutputPortCount: Option[Int] = None,
    revision: Option[RevisionDTO] = None,
    runningCount: Option[Int] = None,
    staleCount: Option[Int] = None,
    status: Option[ProcessGroupStatusDTO] = None,
    stoppedCount: Option[Int] = None,
    syncFailureCount: Option[Int] = None,
    upToDateCount: Option[Int] = None,
    uri: Option[String] = None,
    versionedFlowSnapshot: Option[RegisteredFlowSnapshot] = None,
    versionedFlowState: Option[ProcessGroupEntityVersionedFlowState] = None
  )
  
  sealed trait ProcessGroupEntityProcessGroupUpdateStrategy extends enumeratum.EnumEntry
  object ProcessGroupEntityProcessGroupUpdateStrategy extends enumeratum.Enum[ProcessGroupEntityProcessGroupUpdateStrategy] with enumeratum.CirceEnum[ProcessGroupEntityProcessGroupUpdateStrategy] {
    val values = findValues
    case object CURRENT_GROUP extends ProcessGroupEntityProcessGroupUpdateStrategy
    case object CURRENT_GROUP_WITH_CHILDREN extends ProcessGroupEntityProcessGroupUpdateStrategy
  }
  
  sealed trait ProcessGroupEntityVersionedFlowState extends enumeratum.EnumEntry
  object ProcessGroupEntityVersionedFlowState extends enumeratum.Enum[ProcessGroupEntityVersionedFlowState] with enumeratum.CirceEnum[ProcessGroupEntityVersionedFlowState] {
    val values = findValues
    case object LOCALLY_MODIFIED extends ProcessGroupEntityVersionedFlowState
    case object STALE extends ProcessGroupEntityVersionedFlowState
    case object LOCALLY_MODIFIED_AND_STALE extends ProcessGroupEntityVersionedFlowState
    case object UP_TO_DATE extends ProcessGroupEntityVersionedFlowState
    case object SYNC_FAILURE extends ProcessGroupEntityVersionedFlowState
  }
  case class ProvenanceDTO (
    expiration: Option[String] = None,
    finished: Option[Boolean] = None,
    id: Option[String] = None,
    percentCompleted: Option[Int] = None,
    request: Option[ProvenanceRequestDTO] = None,
    results: Option[ProvenanceResultsDTO] = None,
    submissionTime: Option[String] = None,
    uri: Option[String] = None
  )
  case class VersionedAsset (
    identifier: Option[String] = None,
    name: Option[String] = None
  )
  case class DropRequestDTO (
    current: Option[String] = None,
    currentCount: Option[Int] = None,
    currentSize: Option[Long] = None,
    dropped: Option[String] = None,
    droppedCount: Option[Int] = None,
    droppedSize: Option[Long] = None,
    failureReason: Option[String] = None,
    finished: Option[Boolean] = None,
    id: Option[String] = None,
    lastUpdated: Option[String] = None,
    original: Option[String] = None,
    originalCount: Option[Int] = None,
    originalSize: Option[Long] = None,
    percentCompleted: Option[Int] = None,
    state: Option[String] = None,
    submissionTime: Option[String] = None,
    uri: Option[String] = None
  )
  case class ProvenanceLinkDTO (
    flowFileUuid: Option[String] = None,
    millis: Option[Long] = None,
    sourceId: Option[String] = None,
    targetId: Option[String] = None,
    timestamp: Option[String] = None
  )
  case class DateTimeParameter (
    dateTime: Option[java.time.Instant] = None
  )
  case class ReportingTaskStatusDTO (
    activeThreadCount: Option[Int] = None,
    runStatus: Option[ReportingTaskStatusDTORunStatus] = None,
    validationStatus: Option[ReportingTaskStatusDTOValidationStatus] = None
  )
  
  sealed trait ReportingTaskStatusDTORunStatus extends enumeratum.EnumEntry
  object ReportingTaskStatusDTORunStatus extends enumeratum.Enum[ReportingTaskStatusDTORunStatus] with enumeratum.CirceEnum[ReportingTaskStatusDTORunStatus] {
    val values = findValues
    case object RUNNING extends ReportingTaskStatusDTORunStatus
    case object STOPPED extends ReportingTaskStatusDTORunStatus
    case object DISABLED extends ReportingTaskStatusDTORunStatus
  }
  
  sealed trait ReportingTaskStatusDTOValidationStatus extends enumeratum.EnumEntry
  object ReportingTaskStatusDTOValidationStatus extends enumeratum.Enum[ReportingTaskStatusDTOValidationStatus] with enumeratum.CirceEnum[ReportingTaskStatusDTOValidationStatus] {
    val values = findValues
    case object VALID extends ReportingTaskStatusDTOValidationStatus
    case object INVALID extends ReportingTaskStatusDTOValidationStatus
    case object VALIDATING extends ReportingTaskStatusDTOValidationStatus
  }
  case class ParameterStatusDTO (
    parameter: Option[ParameterEntity] = None,
    status: Option[ParameterStatusDTOStatus] = None
  )
  
  sealed trait ParameterStatusDTOStatus extends enumeratum.EnumEntry
  object ParameterStatusDTOStatus extends enumeratum.Enum[ParameterStatusDTOStatus] with enumeratum.CirceEnum[ParameterStatusDTOStatus] {
    val values = findValues
    case object NEW extends ParameterStatusDTOStatus
    case object CHANGED extends ParameterStatusDTOStatus
    case object REMOVED extends ParameterStatusDTOStatus
    case object MISSING_BUT_REFERENCED extends ParameterStatusDTOStatus
    case object UNCHANGED extends ParameterStatusDTOStatus
  }
  case class NarDetailsEntity (
    controllerServiceTypes: Option[Set[DocumentedTypeDTO]] = None,
    dependentCoordinates: Option[Set[NarCoordinateDTO]] = None,
    flowAnalysisRuleTypes: Option[Set[DocumentedTypeDTO]] = None,
    flowRegistryClientTypes: Option[Set[DocumentedTypeDTO]] = None,
    narSummary: Option[NarSummaryDTO] = None,
    parameterProviderTypes: Option[Set[DocumentedTypeDTO]] = None,
    processorTypes: Option[Set[DocumentedTypeDTO]] = None,
    reportingTaskTypes: Option[Set[DocumentedTypeDTO]] = None
  )
  case class ProcessGroupImportEntity (
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    processGroupRevision: Option[RevisionDTO] = None,
    versionedFlowSnapshot: Option[RegisteredFlowSnapshot] = None
  )
  case class ParameterProviderParameterApplicationEntity (
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    id: Option[String] = None,
    parameterGroupConfigurations: Option[Seq[ParameterGroupConfigurationEntity]] = None,
    revision: Option[RevisionDTO] = None
  )
  case class ProcessGroupDTO (
    activeRemotePortCount: Option[Int] = None,
    comments: Option[String] = None,
    contents: Option[FlowSnippetDTO] = None,
    defaultBackPressureDataSizeThreshold: Option[String] = None,
    defaultBackPressureObjectThreshold: Option[Long] = None,
    defaultFlowFileExpiration: Option[String] = None,
    disabledCount: Option[Int] = None,
    executionEngine: Option[ProcessGroupDTOExecutionEngine] = None,
    flowfileConcurrency: Option[ProcessGroupDTOFlowfileConcurrency] = None,
    flowfileOutboundPolicy: Option[ProcessGroupDTOFlowfileOutboundPolicy] = None,
    id: Option[String] = None,
    inactiveRemotePortCount: Option[Int] = None,
    inputPortCount: Option[Int] = None,
    invalidCount: Option[Int] = None,
    localInputPortCount: Option[Int] = None,
    localOutputPortCount: Option[Int] = None,
    locallyModifiedAndStaleCount: Option[Int] = None,
    locallyModifiedCount: Option[Int] = None,
    logFileSuffix: Option[String] = None,
    maxConcurrentTasks: Option[Int] = None,
    name: Option[String] = None,
    outputPortCount: Option[Int] = None,
    parameterContext: Option[ParameterContextReferenceEntity] = None,
    parentGroupId: Option[String] = None,
    position: Option[PositionDTO] = None,
    publicInputPortCount: Option[Int] = None,
    publicOutputPortCount: Option[Int] = None,
    runningCount: Option[Int] = None,
    staleCount: Option[Int] = None,
    statelessFlowTimeout: Option[String] = None,
    statelessGroupScheduledState: Option[ProcessGroupDTOStatelessGroupScheduledState] = None,
    stoppedCount: Option[Int] = None,
    syncFailureCount: Option[Int] = None,
    upToDateCount: Option[Int] = None,
    versionControlInformation: Option[VersionControlInformationDTO] = None,
    versionedComponentId: Option[String] = None
  )
  
  sealed trait ProcessGroupDTOExecutionEngine extends enumeratum.EnumEntry
  object ProcessGroupDTOExecutionEngine extends enumeratum.Enum[ProcessGroupDTOExecutionEngine] with enumeratum.CirceEnum[ProcessGroupDTOExecutionEngine] {
    val values = findValues
    case object STATELESS extends ProcessGroupDTOExecutionEngine
    case object STANDARD extends ProcessGroupDTOExecutionEngine
    case object INHERITED extends ProcessGroupDTOExecutionEngine
  }
  
  sealed trait ProcessGroupDTOFlowfileConcurrency extends enumeratum.EnumEntry
  object ProcessGroupDTOFlowfileConcurrency extends enumeratum.Enum[ProcessGroupDTOFlowfileConcurrency] with enumeratum.CirceEnum[ProcessGroupDTOFlowfileConcurrency] {
    val values = findValues
    case object UNBOUNDED extends ProcessGroupDTOFlowfileConcurrency
    case object SINGLE_FLOWFILE_PER_NODE extends ProcessGroupDTOFlowfileConcurrency
    case object SINGLE_BATCH_PER_NODE extends ProcessGroupDTOFlowfileConcurrency
  }
  
  sealed trait ProcessGroupDTOFlowfileOutboundPolicy extends enumeratum.EnumEntry
  object ProcessGroupDTOFlowfileOutboundPolicy extends enumeratum.Enum[ProcessGroupDTOFlowfileOutboundPolicy] with enumeratum.CirceEnum[ProcessGroupDTOFlowfileOutboundPolicy] {
    val values = findValues
    case object STREAM_WHEN_AVAILABLE extends ProcessGroupDTOFlowfileOutboundPolicy
    case object BATCH_OUTPUT extends ProcessGroupDTOFlowfileOutboundPolicy
  }
  
  sealed trait ProcessGroupDTOStatelessGroupScheduledState extends enumeratum.EnumEntry
  object ProcessGroupDTOStatelessGroupScheduledState extends enumeratum.Enum[ProcessGroupDTOStatelessGroupScheduledState] with enumeratum.CirceEnum[ProcessGroupDTOStatelessGroupScheduledState] {
    val values = findValues
    case object STOPPED extends ProcessGroupDTOStatelessGroupScheduledState
    case object RUNNING extends ProcessGroupDTOStatelessGroupScheduledState
  }
  case class NodeStatusSnapshotsDTO (
    address: Option[String] = None,
    apiPort: Option[Int] = None,
    nodeId: Option[String] = None,
    statusSnapshots: Option[Seq[StatusSnapshotDTO]] = None
  )
  case class ControllerServiceEntity (
    bulletins: Option[Seq[BulletinEntity]] = None,
    component: Option[ControllerServiceDTO] = None,
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    id: Option[String] = None,
    operatePermissions: Option[PermissionsDTO] = None,
    parentGroupId: Option[String] = None,
    permissions: Option[PermissionsDTO] = None,
    position: Option[PositionDTO] = None,
    revision: Option[RevisionDTO] = None,
    status: Option[ControllerServiceStatusDTO] = None,
    uri: Option[String] = None
  )
  case class NodeRemoteProcessGroupStatusSnapshotDTO (
    address: Option[String] = None,
    apiPort: Option[Int] = None,
    nodeId: Option[String] = None,
    statusSnapshot: Option[RemoteProcessGroupStatusSnapshotDTO] = None
  )
  case class CounterEntity (
    counter: Option[CounterDTO] = None
  )
  case class NodeProcessGroupStatusSnapshotDTO (
    address: Option[String] = None,
    apiPort: Option[Int] = None,
    nodeId: Option[String] = None,
    statusSnapshot: Option[ProcessGroupStatusSnapshotDTO] = None
  )
  case class PreviousValueDTO (
    previousValue: Option[String] = None,
    timestamp: Option[String] = None,
    userIdentity: Option[String] = None
  )
  case class BulletinBoardDTO (
    bulletins: Option[Seq[BulletinEntity]] = None,
    generated: Option[String] = None
  )
  case class RegisteredFlowSnapshotMetadata (
    author: Option[String] = None,
    branch: Option[String] = None,
    bucketIdentifier: Option[String] = None,
    comments: Option[String] = None,
    flowIdentifier: Option[String] = None,
    flowName: Option[String] = None,
    registryIdentifier: Option[String] = None,
    registryName: Option[String] = None,
    timestamp: Option[Long] = None,
    version: Option[String] = None
  )
  case class RuntimeManifestEntity (
    runtimeManifest: Option[RuntimeManifest] = None
  )
  case class ParameterContextUpdateEntity (
    parameterContext: Option[ParameterContextDTO] = None,
    parameterContextRevision: Option[RevisionDTO] = None,
    referencingComponents: Option[Set[AffectedComponentEntity]] = None
  )
  case class UsersEntity (
    generated: Option[String] = None,
    users: Option[Seq[UserEntity]] = None
  )
  case class FlowRegistryClientsEntity (
    currentTime: Option[String] = None,
    registries: Option[Set[FlowRegistryClientEntity]] = None
  )
  case class LabelsEntity (
    labels: Option[Set[LabelEntity]] = None
  )
  case class FlowAnalysisRuleViolationDTO (
    enabled: Option[Boolean] = None,
    enforcementPolicy: Option[String] = None,
    groupId: Option[String] = None,
    issueId: Option[String] = None,
    ruleId: Option[String] = None,
    scope: Option[String] = None,
    subjectComponentType: Option[String] = None,
    subjectDisplayName: Option[String] = None,
    subjectId: Option[String] = None,
    subjectPermissionDto: Option[PermissionsDTO] = None,
    violationMessage: Option[String] = None
  )
  case class PositionDTO (
    x: Option[Double] = None,
    y: Option[Double] = None
  )
  case class SnippetEntity (
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    snippet: Option[SnippetDTO] = None
  )
  case class ActionDetailsDTO (
  
  )
  case class SearchResultsDTO (
    connectionResults: Option[Seq[ComponentSearchResultDTO]] = None,
    controllerServiceNodeResults: Option[Seq[ComponentSearchResultDTO]] = None,
    funnelResults: Option[Seq[ComponentSearchResultDTO]] = None,
    inputPortResults: Option[Seq[ComponentSearchResultDTO]] = None,
    labelResults: Option[Seq[ComponentSearchResultDTO]] = None,
    outputPortResults: Option[Seq[ComponentSearchResultDTO]] = None,
    parameterContextResults: Option[Seq[ComponentSearchResultDTO]] = None,
    parameterProviderNodeResults: Option[Seq[ComponentSearchResultDTO]] = None,
    parameterResults: Option[Seq[ComponentSearchResultDTO]] = None,
    processGroupResults: Option[Seq[ComponentSearchResultDTO]] = None,
    processorResults: Option[Seq[ComponentSearchResultDTO]] = None,
    remoteProcessGroupResults: Option[Seq[ComponentSearchResultDTO]] = None
  )
  case class FlowAnalysisRulesEntity (
    currentTime: Option[String] = None,
    flowAnalysisRules: Option[Set[FlowAnalysisRuleEntity]] = None
  )
  case class VersionedParameter (
    description: Option[String] = None,
    name: Option[String] = None,
    provided: Option[Boolean] = None,
    referencedAssets: Option[Seq[VersionedAsset]] = None,
    sensitive: Option[Boolean] = None,
    value: Option[String] = None
  )
  case class ProvenanceOptionsEntity (
    provenanceOptions: Option[ProvenanceOptionsDTO] = None
  )
  case class NodeProcessorStatusSnapshotDTO (
    address: Option[String] = None,
    apiPort: Option[Int] = None,
    nodeId: Option[String] = None,
    statusSnapshot: Option[ProcessorStatusSnapshotDTO] = None
  )
  case class RevisionDTO (
    clientId: Option[String] = None,
    lastModifier: Option[String] = None,
    version: Option[Long] = None
  )
  case class NarSummaryEntity (
    narSummary: Option[NarSummaryDTO] = None
  )
  case class VersionControlComponentMappingEntity (
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    processGroupRevision: Option[RevisionDTO] = None,
    versionControlComponentMapping: Option[Map[String, String]] = None,
    versionControlInformation: Option[VersionControlInformationDTO] = None
  )
  case class AssetsEntity (
    assets: Option[Seq[AssetEntity]] = None
  )
  case class LabelEntity (
    bulletins: Option[Seq[BulletinEntity]] = None,
    component: Option[LabelDTO] = None,
    dimensions: Option[DimensionsDTO] = None,
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    getzIndex: Option[Long] = None,
    id: Option[String] = None,
    permissions: Option[PermissionsDTO] = None,
    position: Option[PositionDTO] = None,
    revision: Option[RevisionDTO] = None,
    uri: Option[String] = None
  )
  case class ContentViewerEntity (
    contentViewers: Option[Seq[ContentViewerDTO]] = None
  )
  case class ParameterProviderReferencingComponentEntity (
    bulletins: Option[Seq[BulletinEntity]] = None,
    component: Option[ParameterProviderReferencingComponentDTO] = None,
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    id: Option[String] = None,
    permissions: Option[PermissionsDTO] = None,
    position: Option[PositionDTO] = None,
    revision: Option[RevisionDTO] = None,
    uri: Option[String] = None
  )
  case class ConnectionsEntity (
    connections: Option[Set[ConnectionEntity]] = None
  )
  case class ReportingTasksEntity (
    currentTime: Option[String] = None,
    reportingTasks: Option[Set[ReportingTaskEntity]] = None
  )
  case class ReportingTaskTypesEntity (
    reportingTaskTypes: Option[Set[DocumentedTypeDTO]] = None
  )
  case class FlowAnalysisRuleTypesEntity (
    flowAnalysisRuleTypes: Option[Set[DocumentedTypeDTO]] = None
  )
  case class ProcessGroupReplaceRequestDTO (
    complete: Option[Boolean] = None,
    failureReason: Option[String] = None,
    lastUpdated: Option[String] = None,
    percentCompleted: Option[Int] = None,
    processGroupId: Option[String] = None,
    requestId: Option[String] = None,
    state: Option[String] = None,
    uri: Option[String] = None
  )
  case class ControllerServiceReferencingComponentsEntity (
    controllerServiceReferencingComponents: Option[Set[ControllerServiceReferencingComponentEntity]] = None
  )
  case class SystemDiagnosticsDTO (
    aggregateSnapshot: Option[SystemDiagnosticsSnapshotDTO] = None,
    nodeSnapshots: Option[Seq[NodeSystemDiagnosticsSnapshotDTO]] = None
  )
  case class ParameterProviderReferencingComponentDTO (
    id: Option[String] = None,
    name: Option[String] = None
  )
  case class ClusterSummaryDTO (
    clustered: Option[Boolean] = None,
    connectedNodeCount: Option[Int] = None,
    connectedNodes: Option[String] = None,
    connectedToCluster: Option[Boolean] = None,
    totalNodeCount: Option[Int] = None
  )
  case class ParameterContextsEntity (
    currentTime: Option[String] = None,
    parameterContexts: Option[Set[ParameterContextEntity]] = None
  )
  case class ConnectionStatisticsDTO (
    aggregateSnapshot: Option[ConnectionStatisticsSnapshotDTO] = None,
    id: Option[String] = None,
    nodeSnapshots: Option[Seq[NodeConnectionStatisticsSnapshotDTO]] = None,
    statsLastRefreshed: Option[String] = None
  )
  case class ControllerConfigurationEntity (
    component: Option[ControllerConfigurationDTO] = None,
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    permissions: Option[PermissionsDTO] = None,
    revision: Option[RevisionDTO] = None
  )
  case class CopySnippetRequestEntity (
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    originX: Option[Double] = None,
    originY: Option[Double] = None,
    snippetId: Option[String] = None
  )
  case class PasteRequestEntity (
    copyResponse: Option[CopyResponseEntity] = None,
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    revision: Option[RevisionDTO] = None
  )
  case class RegisteredFlowVersionInfo (
    version: Option[Long] = None
  )
  case class ParameterProviderConfigurationDTO (
    parameterGroupName: Option[String] = None,
    parameterProviderId: Option[String] = None,
    parameterProviderName: Option[String] = None,
    synchronized: Option[Boolean] = None
  )
  case class ReportingTaskDTO (
    activeThreadCount: Option[Int] = None,
    annotationData: Option[String] = None,
    bundle: Option[BundleDTO] = None,
    comments: Option[String] = None,
    customUiUrl: Option[String] = None,
    defaultSchedulingPeriod: Option[Map[String, String]] = None,
    deprecated: Option[Boolean] = None,
    descriptors: Option[Map[String, PropertyDescriptorDTO]] = None,
    extensionMissing: Option[Boolean] = None,
    id: Option[String] = None,
    multipleVersionsAvailable: Option[Boolean] = None,
    name: Option[String] = None,
    parentGroupId: Option[String] = None,
    persistsState: Option[Boolean] = None,
    position: Option[PositionDTO] = None,
    properties: Option[Map[String, String]] = None,
    restricted: Option[Boolean] = None,
    schedulingPeriod: Option[String] = None,
    schedulingStrategy: Option[String] = None,
    sensitiveDynamicPropertyNames: Option[Set[String]] = None,
    state: Option[ReportingTaskDTOState] = None,
    supportsSensitiveDynamicProperties: Option[Boolean] = None,
    `type`: Option[String] = None,
    validationErrors: Option[Seq[String]] = None,
    validationStatus: Option[ReportingTaskDTOValidationStatus] = None,
    versionedComponentId: Option[String] = None
  )
  
  sealed trait ReportingTaskDTOState extends enumeratum.EnumEntry
  object ReportingTaskDTOState extends enumeratum.Enum[ReportingTaskDTOState] with enumeratum.CirceEnum[ReportingTaskDTOState] {
    val values = findValues
    case object RUNNING extends ReportingTaskDTOState
    case object STOPPED extends ReportingTaskDTOState
    case object DISABLED extends ReportingTaskDTOState
  }
  
  sealed trait ReportingTaskDTOValidationStatus extends enumeratum.EnumEntry
  object ReportingTaskDTOValidationStatus extends enumeratum.Enum[ReportingTaskDTOValidationStatus] with enumeratum.CirceEnum[ReportingTaskDTOValidationStatus] {
    val values = findValues
    case object VALID extends ReportingTaskDTOValidationStatus
    case object INVALID extends ReportingTaskDTOValidationStatus
    case object VALIDATING extends ReportingTaskDTOValidationStatus
  }
  case class ReplayLastEventSnapshotDTO (
    eventAvailable: Option[Boolean] = None,
    eventsReplayed: Option[Seq[Long]] = None,
    failureExplanation: Option[String] = None
  )
  case class NodeConnectionStatusSnapshotDTO (
    address: Option[String] = None,
    apiPort: Option[Int] = None,
    nodeId: Option[String] = None,
    statusSnapshot: Option[ConnectionStatusSnapshotDTO] = None
  )
  case class LabelDTO (
    getzIndex: Option[Long] = None,
    height: Option[Double] = None,
    id: Option[String] = None,
    label: Option[String] = None,
    parentGroupId: Option[String] = None,
    position: Option[PositionDTO] = None,
    style: Option[Map[String, String]] = None,
    versionedComponentId: Option[String] = None,
    width: Option[Double] = None
  )
  case class Relationship (
    description: Option[String] = None,
    name: Option[String] = None
  )
  case class RemoteProcessGroupStatusSnapshotEntity (
    canRead: Option[Boolean] = None,
    id: Option[String] = None,
    remoteProcessGroupStatusSnapshot: Option[RemoteProcessGroupStatusSnapshotDTO] = None
  )
  case class FlowRegistryBucketEntity (
    bucket: Option[FlowRegistryBucketDTO] = None,
    id: Option[String] = None,
    permissions: Option[PermissionsDTO] = None
  )
  case class StreamingOutput (
  
  )
  case class ProcessGroupNameDTO (
    id: Option[String] = None,
    name: Option[String] = None
  )
  case class VersionedControllerService (
    annotationData: Option[String] = None,
    bulletinLevel: Option[String] = None,
    bundle: Option[Bundle] = None,
    comments: Option[String] = None,
    componentType: Option[VersionedControllerServiceComponentType] = None,
    controllerServiceApis: Option[Seq[ControllerServiceAPI]] = None,
    groupIdentifier: Option[String] = None,
    identifier: Option[String] = None,
    instanceIdentifier: Option[String] = None,
    name: Option[String] = None,
    position: Option[Position] = None,
    properties: Option[Map[String, String]] = None,
    propertyDescriptors: Option[Map[String, VersionedPropertyDescriptor]] = None,
    scheduledState: Option[VersionedControllerServiceScheduledState] = None,
    `type`: Option[String] = None
  )
  
  sealed trait VersionedControllerServiceComponentType extends enumeratum.EnumEntry
  object VersionedControllerServiceComponentType extends enumeratum.Enum[VersionedControllerServiceComponentType] with enumeratum.CirceEnum[VersionedControllerServiceComponentType] {
    val values = findValues
    case object CONNECTION extends VersionedControllerServiceComponentType
    case object PROCESSOR extends VersionedControllerServiceComponentType
    case object PROCESS_GROUP extends VersionedControllerServiceComponentType
    case object REMOTE_PROCESS_GROUP extends VersionedControllerServiceComponentType
    case object INPUT_PORT extends VersionedControllerServiceComponentType
    case object OUTPUT_PORT extends VersionedControllerServiceComponentType
    case object REMOTE_INPUT_PORT extends VersionedControllerServiceComponentType
    case object REMOTE_OUTPUT_PORT extends VersionedControllerServiceComponentType
    case object FUNNEL extends VersionedControllerServiceComponentType
    case object LABEL extends VersionedControllerServiceComponentType
    case object CONTROLLER_SERVICE extends VersionedControllerServiceComponentType
    case object REPORTING_TASK extends VersionedControllerServiceComponentType
    case object FLOW_ANALYSIS_RULE extends VersionedControllerServiceComponentType
    case object PARAMETER_CONTEXT extends VersionedControllerServiceComponentType
    case object PARAMETER_PROVIDER extends VersionedControllerServiceComponentType
    case object FLOW_REGISTRY_CLIENT extends VersionedControllerServiceComponentType
  }
  
  sealed trait VersionedControllerServiceScheduledState extends enumeratum.EnumEntry
  object VersionedControllerServiceScheduledState extends enumeratum.Enum[VersionedControllerServiceScheduledState] with enumeratum.CirceEnum[VersionedControllerServiceScheduledState] {
    val values = findValues
    case object ENABLED extends VersionedControllerServiceScheduledState
    case object DISABLED extends VersionedControllerServiceScheduledState
    case object RUNNING extends VersionedControllerServiceScheduledState
  }
  case class FlowAnalysisRuleDTO (
    bundle: Option[BundleDTO] = None,
    comments: Option[String] = None,
    deprecated: Option[Boolean] = None,
    descriptors: Option[Map[String, PropertyDescriptorDTO]] = None,
    enforcementPolicy: Option[String] = None,
    extensionMissing: Option[Boolean] = None,
    id: Option[String] = None,
    multipleVersionsAvailable: Option[Boolean] = None,
    name: Option[String] = None,
    parentGroupId: Option[String] = None,
    persistsState: Option[Boolean] = None,
    position: Option[PositionDTO] = None,
    properties: Option[Map[String, String]] = None,
    restricted: Option[Boolean] = None,
    sensitiveDynamicPropertyNames: Option[Set[String]] = None,
    state: Option[FlowAnalysisRuleDTOState] = None,
    supportsSensitiveDynamicProperties: Option[Boolean] = None,
    `type`: Option[String] = None,
    validationErrors: Option[Seq[String]] = None,
    validationStatus: Option[FlowAnalysisRuleDTOValidationStatus] = None,
    versionedComponentId: Option[String] = None
  )
  
  sealed trait FlowAnalysisRuleDTOState extends enumeratum.EnumEntry
  object FlowAnalysisRuleDTOState extends enumeratum.Enum[FlowAnalysisRuleDTOState] with enumeratum.CirceEnum[FlowAnalysisRuleDTOState] {
    val values = findValues
    case object ENABLED extends FlowAnalysisRuleDTOState
    case object DISABLED extends FlowAnalysisRuleDTOState
  }
  
  sealed trait FlowAnalysisRuleDTOValidationStatus extends enumeratum.EnumEntry
  object FlowAnalysisRuleDTOValidationStatus extends enumeratum.Enum[FlowAnalysisRuleDTOValidationStatus] with enumeratum.CirceEnum[FlowAnalysisRuleDTOValidationStatus] {
    val values = findValues
    case object VALID extends FlowAnalysisRuleDTOValidationStatus
    case object INVALID extends FlowAnalysisRuleDTOValidationStatus
    case object VALIDATING extends FlowAnalysisRuleDTOValidationStatus
  }
  case class ProcessorDefinition (
    additionalDetails: Option[Boolean] = None,
    artifact: Option[String] = None,
    buildInfo: Option[BuildInfo] = None,
    defaultBulletinLevel: Option[String] = None,
    defaultConcurrentTasksBySchedulingStrategy: Option[Map[String, Int]] = None,
    defaultPenaltyDuration: Option[String] = None,
    defaultSchedulingPeriodBySchedulingStrategy: Option[Map[String, String]] = None,
    defaultSchedulingStrategy: Option[String] = None,
    defaultYieldDuration: Option[String] = None,
    deprecated: Option[Boolean] = None,
    deprecationAlternatives: Option[Set[String]] = None,
    deprecationReason: Option[String] = None,
    dynamicProperties: Option[Seq[DynamicProperty]] = None,
    dynamicRelationship: Option[DynamicRelationship] = None,
    explicitRestrictions: Option[Set[Restriction]] = None,
    group: Option[String] = None,
    inputRequirement: Option[ProcessorDefinitionInputRequirement] = None,
    multiProcessorUseCases: Option[Seq[MultiProcessorUseCase]] = None,
    primaryNodeOnly: Option[Boolean] = None,
    propertyDescriptors: Option[Map[String, PropertyDescriptor]] = None,
    providedApiImplementations: Option[Seq[DefinedType]] = None,
    readsAttributes: Option[Seq[Attribute]] = None,
    restricted: Option[Boolean] = None,
    restrictedExplanation: Option[String] = None,
    seeAlso: Option[Set[String]] = None,
    sideEffectFree: Option[Boolean] = None,
    stateful: Option[Stateful] = None,
    supportedRelationships: Option[Seq[Relationship]] = None,
    supportedSchedulingStrategies: Option[Seq[String]] = None,
    supportsBatching: Option[Boolean] = None,
    supportsDynamicProperties: Option[Boolean] = None,
    supportsDynamicRelationships: Option[Boolean] = None,
    supportsSensitiveDynamicProperties: Option[Boolean] = None,
    systemResourceConsiderations: Option[Seq[SystemResourceConsideration]] = None,
    tags: Option[Set[String]] = None,
    triggerSerially: Option[Boolean] = None,
    triggerWhenAnyDestinationAvailable: Option[Boolean] = None,
    triggerWhenEmpty: Option[Boolean] = None,
    `type`: Option[String] = None,
    typeDescription: Option[String] = None,
    useCases: Option[Seq[UseCase]] = None,
    version: Option[String] = None,
    writesAttributes: Option[Seq[Attribute]] = None
  )
  
  sealed trait ProcessorDefinitionInputRequirement extends enumeratum.EnumEntry
  object ProcessorDefinitionInputRequirement extends enumeratum.Enum[ProcessorDefinitionInputRequirement] with enumeratum.CirceEnum[ProcessorDefinitionInputRequirement] {
    val values = findValues
    case object INPUT_REQUIRED extends ProcessorDefinitionInputRequirement
    case object INPUT_ALLOWED extends ProcessorDefinitionInputRequirement
    case object INPUT_FORBIDDEN extends ProcessorDefinitionInputRequirement
  }
  case class IntegerParameter (
    integer: Option[Int] = None
  )
  case class ReplayLastEventRequestEntity (
    componentId: Option[String] = None,
    nodes: Option[ReplayLastEventRequestEntityNodes] = None
  )
  
  sealed trait ReplayLastEventRequestEntityNodes extends enumeratum.EnumEntry
  object ReplayLastEventRequestEntityNodes extends enumeratum.Enum[ReplayLastEventRequestEntityNodes] with enumeratum.CirceEnum[ReplayLastEventRequestEntityNodes] {
    val values = findValues
    case object ALL extends ReplayLastEventRequestEntityNodes
    case object PRIMARY extends ReplayLastEventRequestEntityNodes
  }
  case class ProcessGroupReplaceRequestEntity (
    processGroupRevision: Option[RevisionDTO] = None,
    request: Option[ProcessGroupReplaceRequestDTO] = None,
    versionedFlowSnapshot: Option[RegisteredFlowSnapshot] = None
  )
  case class ComponentHistoryEntity (
    componentHistory: Option[ComponentHistoryDTO] = None
  )
  case class VersionedConnection (
    backPressureDataSizeThreshold: Option[String] = None,
    backPressureObjectThreshold: Option[Long] = None,
    bends: Option[Seq[Position]] = None,
    comments: Option[String] = None,
    componentType: Option[VersionedConnectionComponentType] = None,
    destination: Option[ConnectableComponent] = None,
    flowFileExpiration: Option[String] = None,
    groupIdentifier: Option[String] = None,
    identifier: Option[String] = None,
    instanceIdentifier: Option[String] = None,
    labelIndex: Option[Int] = None,
    loadBalanceCompression: Option[String] = None,
    loadBalanceStrategy: Option[String] = None,
    name: Option[String] = None,
    partitioningAttribute: Option[String] = None,
    position: Option[Position] = None,
    prioritizers: Option[Seq[String]] = None,
    selectedRelationships: Option[Set[String]] = None,
    source: Option[ConnectableComponent] = None,
    zIndex: Option[Long] = None
  )
  
  sealed trait VersionedConnectionComponentType extends enumeratum.EnumEntry
  object VersionedConnectionComponentType extends enumeratum.Enum[VersionedConnectionComponentType] with enumeratum.CirceEnum[VersionedConnectionComponentType] {
    val values = findValues
    case object CONNECTION extends VersionedConnectionComponentType
    case object PROCESSOR extends VersionedConnectionComponentType
    case object PROCESS_GROUP extends VersionedConnectionComponentType
    case object REMOTE_PROCESS_GROUP extends VersionedConnectionComponentType
    case object INPUT_PORT extends VersionedConnectionComponentType
    case object OUTPUT_PORT extends VersionedConnectionComponentType
    case object REMOTE_INPUT_PORT extends VersionedConnectionComponentType
    case object REMOTE_OUTPUT_PORT extends VersionedConnectionComponentType
    case object FUNNEL extends VersionedConnectionComponentType
    case object LABEL extends VersionedConnectionComponentType
    case object CONTROLLER_SERVICE extends VersionedConnectionComponentType
    case object REPORTING_TASK extends VersionedConnectionComponentType
    case object FLOW_ANALYSIS_RULE extends VersionedConnectionComponentType
    case object PARAMETER_CONTEXT extends VersionedConnectionComponentType
    case object PARAMETER_PROVIDER extends VersionedConnectionComponentType
    case object FLOW_REGISTRY_CLIENT extends VersionedConnectionComponentType
  }
  case class VersionedFlowEntity (
    versionedFlow: Option[VersionedFlowDTO] = None
  )
  case class ConfigurationAnalysisDTO (
    componentId: Option[String] = None,
    properties: Option[Map[String, String]] = None,
    referencedAttributes: Option[Map[String, String]] = None,
    supportsVerification: Option[Boolean] = None
  )
  case class AllowableValueDTO (
    description: Option[String] = None,
    displayName: Option[String] = None,
    value: Option[String] = None
  )
  case class ConnectionStatusEntity (
    canRead: Option[Boolean] = None,
    connectionStatus: Option[ConnectionStatusDTO] = None
  )
  case class FlowEntity (
    flow: Option[FlowDTO] = None
  )
  case class FlowFileSummaryDTO (
    clusterNodeAddress: Option[String] = None,
    clusterNodeId: Option[String] = None,
    filename: Option[String] = None,
    lineageDuration: Option[Long] = None,
    mimeType: Option[String] = None,
    penalized: Option[Boolean] = None,
    penaltyExpiresIn: Option[Long] = None,
    position: Option[Int] = None,
    queuedDuration: Option[Long] = None,
    size: Option[Long] = None,
    uri: Option[String] = None,
    uuid: Option[String] = None
  )
  case class ActivateControllerServicesEntity (
    components: Option[Map[String, RevisionDTO]] = None,
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    id: Option[String] = None,
    state: Option[ActivateControllerServicesEntityState] = None
  )
  
  sealed trait ActivateControllerServicesEntityState extends enumeratum.EnumEntry
  object ActivateControllerServicesEntityState extends enumeratum.Enum[ActivateControllerServicesEntityState] with enumeratum.CirceEnum[ActivateControllerServicesEntityState] {
    val values = findValues
    case object ENABLED extends ActivateControllerServicesEntityState
    case object DISABLED extends ActivateControllerServicesEntityState
  }
  case class ParameterProvidersEntity (
    currentTime: Option[String] = None,
    parameterProviders: Option[Set[ParameterProviderEntity]] = None
  )
  case class ComponentReferenceDTO (
    id: Option[String] = None,
    name: Option[String] = None,
    parentGroupId: Option[String] = None,
    position: Option[PositionDTO] = None,
    versionedComponentId: Option[String] = None
  )
  case class ProcessorTypesEntity (
    processorTypes: Option[Set[DocumentedTypeDTO]] = None
  )
  case class TenantDTO (
    configurable: Option[Boolean] = None,
    id: Option[String] = None,
    identity: Option[String] = None,
    parentGroupId: Option[String] = None,
    position: Option[PositionDTO] = None,
    versionedComponentId: Option[String] = None
  )
  case class ReportingTaskRunStatusEntity (
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    revision: Option[RevisionDTO] = None,
    state: Option[ReportingTaskRunStatusEntityState] = None
  )
  
  sealed trait ReportingTaskRunStatusEntityState extends enumeratum.EnumEntry
  object ReportingTaskRunStatusEntityState extends enumeratum.Enum[ReportingTaskRunStatusEntityState] with enumeratum.CirceEnum[ReportingTaskRunStatusEntityState] {
    val values = findValues
    case object RUNNING extends ReportingTaskRunStatusEntityState
    case object STOPPED extends ReportingTaskRunStatusEntityState
  }
  case class ProcessGroupStatusDTO (
    aggregateSnapshot: Option[ProcessGroupStatusSnapshotDTO] = None,
    id: Option[String] = None,
    name: Option[String] = None,
    nodeSnapshots: Option[Seq[NodeProcessGroupStatusSnapshotDTO]] = None,
    statsLastRefreshed: Option[String] = None
  )
  case class ParameterContextValidationRequestEntity (
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    request: Option[ParameterContextValidationRequestDTO] = None
  )
  case class NodePortStatusSnapshotDTO (
    address: Option[String] = None,
    apiPort: Option[Int] = None,
    nodeId: Option[String] = None,
    statusSnapshot: Option[PortStatusSnapshotDTO] = None
  )
  case class ProcessorConfigDTO (
    annotationData: Option[String] = None,
    autoTerminatedRelationships: Option[Set[String]] = None,
    backoffMechanism: Option[String] = None,
    bulletinLevel: Option[String] = None,
    comments: Option[String] = None,
    concurrentlySchedulableTaskCount: Option[Int] = None,
    customUiUrl: Option[String] = None,
    defaultConcurrentTasks: Option[Map[String, String]] = None,
    defaultSchedulingPeriod: Option[Map[String, String]] = None,
    descriptors: Option[Map[String, PropertyDescriptorDTO]] = None,
    executionNode: Option[String] = None,
    lossTolerant: Option[Boolean] = None,
    maxBackoffPeriod: Option[String] = None,
    penaltyDuration: Option[String] = None,
    properties: Option[Map[String, String]] = None,
    retriedRelationships: Option[Set[String]] = None,
    retryCount: Option[Int] = None,
    runDurationMillis: Option[Long] = None,
    schedulingPeriod: Option[String] = None,
    schedulingStrategy: Option[String] = None,
    sensitiveDynamicPropertyNames: Option[Set[String]] = None,
    yieldDuration: Option[String] = None
  )
  case class FlowRegistryBranchesEntity (
    branches: Option[Set[FlowRegistryBranchEntity]] = None
  )
  case class VersionedReportingTaskImportResponseEntity (
    controllerServices: Option[Set[ControllerServiceEntity]] = None,
    reportingTasks: Option[Set[ReportingTaskEntity]] = None
  )
  case class PortStatusSnapshotDTO (
    activeThreadCount: Option[Int] = None,
    bytesIn: Option[Long] = None,
    bytesOut: Option[Long] = None,
    flowFilesIn: Option[Int] = None,
    flowFilesOut: Option[Int] = None,
    groupId: Option[String] = None,
    id: Option[String] = None,
    input: Option[String] = None,
    name: Option[String] = None,
    output: Option[String] = None,
    runStatus: Option[PortStatusSnapshotDTORunStatus] = None,
    transmitting: Option[Boolean] = None
  )
  
  sealed trait PortStatusSnapshotDTORunStatus extends enumeratum.EnumEntry
  object PortStatusSnapshotDTORunStatus extends enumeratum.Enum[PortStatusSnapshotDTORunStatus] with enumeratum.CirceEnum[PortStatusSnapshotDTORunStatus] {
    val values = findValues
    case object Running extends PortStatusSnapshotDTORunStatus
    case object Stopped extends PortStatusSnapshotDTORunStatus
    case object Validating extends PortStatusSnapshotDTORunStatus
    case object Disabled extends PortStatusSnapshotDTORunStatus
    case object Invalid extends PortStatusSnapshotDTORunStatus
  }
  case class UserEntity (
    bulletins: Option[Seq[BulletinEntity]] = None,
    component: Option[UserDTO] = None,
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    id: Option[String] = None,
    permissions: Option[PermissionsDTO] = None,
    position: Option[PositionDTO] = None,
    revision: Option[RevisionDTO] = None,
    uri: Option[String] = None
  )
  case class RemoteProcessGroupPortEntity (
    bulletins: Option[Seq[BulletinEntity]] = None,
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    id: Option[String] = None,
    operatePermissions: Option[PermissionsDTO] = None,
    permissions: Option[PermissionsDTO] = None,
    position: Option[PositionDTO] = None,
    remoteProcessGroupPort: Option[RemoteProcessGroupPortDTO] = None,
    revision: Option[RevisionDTO] = None,
    uri: Option[String] = None
  )
  case class VersionedParameterContext (
    comments: Option[String] = None,
    componentType: Option[VersionedParameterContextComponentType] = None,
    description: Option[String] = None,
    groupIdentifier: Option[String] = None,
    identifier: Option[String] = None,
    inheritedParameterContexts: Option[Seq[String]] = None,
    instanceIdentifier: Option[String] = None,
    name: Option[String] = None,
    parameterGroupName: Option[String] = None,
    parameterProvider: Option[String] = None,
    parameters: Option[Set[VersionedParameter]] = None,
    position: Option[Position] = None,
    synchronized: Option[Boolean] = None
  )
  
  sealed trait VersionedParameterContextComponentType extends enumeratum.EnumEntry
  object VersionedParameterContextComponentType extends enumeratum.Enum[VersionedParameterContextComponentType] with enumeratum.CirceEnum[VersionedParameterContextComponentType] {
    val values = findValues
    case object CONNECTION extends VersionedParameterContextComponentType
    case object PROCESSOR extends VersionedParameterContextComponentType
    case object PROCESS_GROUP extends VersionedParameterContextComponentType
    case object REMOTE_PROCESS_GROUP extends VersionedParameterContextComponentType
    case object INPUT_PORT extends VersionedParameterContextComponentType
    case object OUTPUT_PORT extends VersionedParameterContextComponentType
    case object REMOTE_INPUT_PORT extends VersionedParameterContextComponentType
    case object REMOTE_OUTPUT_PORT extends VersionedParameterContextComponentType
    case object FUNNEL extends VersionedParameterContextComponentType
    case object LABEL extends VersionedParameterContextComponentType
    case object CONTROLLER_SERVICE extends VersionedParameterContextComponentType
    case object REPORTING_TASK extends VersionedParameterContextComponentType
    case object FLOW_ANALYSIS_RULE extends VersionedParameterContextComponentType
    case object PARAMETER_CONTEXT extends VersionedParameterContextComponentType
    case object PARAMETER_PROVIDER extends VersionedParameterContextComponentType
    case object FLOW_REGISTRY_CLIENT extends VersionedParameterContextComponentType
  }
  case class FlowRegistryBucketDTO (
    created: Option[Long] = None,
    description: Option[String] = None,
    id: Option[String] = None,
    name: Option[String] = None
  )
  type ClientIdParameterStr = String
  case class ListingRequestDTO (
    destinationRunning: Option[Boolean] = None,
    failureReason: Option[String] = None,
    finished: Option[Boolean] = None,
    flowFileSummaries: Option[Seq[FlowFileSummaryDTO]] = None,
    id: Option[String] = None,
    lastUpdated: Option[String] = None,
    maxResults: Option[Int] = None,
    percentCompleted: Option[Int] = None,
    queueSize: Option[QueueSizeDTO] = None,
    sourceRunning: Option[Boolean] = None,
    state: Option[String] = None,
    submissionTime: Option[String] = None,
    uri: Option[String] = None
  )
  case class ComponentRestrictionPermissionDTO (
    permissions: Option[PermissionsDTO] = None,
    requiredPermission: Option[RequiredPermissionDTO] = None
  )
  case class SnippetDTO (
    connections: Option[Map[String, RevisionDTO]] = None,
    funnels: Option[Map[String, RevisionDTO]] = None,
    id: Option[String] = None,
    inputPorts: Option[Map[String, RevisionDTO]] = None,
    labels: Option[Map[String, RevisionDTO]] = None,
    outputPorts: Option[Map[String, RevisionDTO]] = None,
    parentGroupId: Option[String] = None,
    processGroups: Option[Map[String, RevisionDTO]] = None,
    processors: Option[Map[String, RevisionDTO]] = None,
    remoteProcessGroups: Option[Map[String, RevisionDTO]] = None,
    uri: Option[String] = None
  )
  case class ControllerEntity (
    controller: Option[ControllerDTO] = None
  )
  case class ComponentValidationResultDTO (
    activeThreadCount: Option[Int] = None,
    currentlyValid: Option[Boolean] = None,
    id: Option[String] = None,
    name: Option[String] = None,
    processGroupId: Option[String] = None,
    referenceType: Option[ComponentValidationResultDTOReferenceType] = None,
    resultantValidationErrors: Option[Seq[String]] = None,
    resultsValid: Option[Boolean] = None,
    state: Option[String] = None,
    validationErrors: Option[Seq[String]] = None
  )
  
  sealed trait ComponentValidationResultDTOReferenceType extends enumeratum.EnumEntry
  object ComponentValidationResultDTOReferenceType extends enumeratum.Enum[ComponentValidationResultDTOReferenceType] with enumeratum.CirceEnum[ComponentValidationResultDTOReferenceType] {
    val values = findValues
    case object PROCESSOR extends ComponentValidationResultDTOReferenceType
    case object CONTROLLER_SERVICE extends ComponentValidationResultDTOReferenceType
    case object INPUT_PORT extends ComponentValidationResultDTOReferenceType
    case object OUTPUT_PORT extends ComponentValidationResultDTOReferenceType
    case object REMOTE_INPUT_PORT extends ComponentValidationResultDTOReferenceType
    case object REMOTE_OUTPUT_PORT extends ComponentValidationResultDTOReferenceType
    case object STATELESS_GROUP extends ComponentValidationResultDTOReferenceType
  }
  case class Attribute (
    description: Option[String] = None,
    name: Option[String] = None
  )
  case class MultiProcessorUseCase (
    configurations: Option[Seq[ProcessorConfiguration]] = None,
    description: Option[String] = None,
    keywords: Option[Seq[String]] = None,
    notes: Option[String] = None
  )
  case class ParameterContextUpdateRequestEntity (
    parameterContextRevision: Option[RevisionDTO] = None,
    request: Option[ParameterContextUpdateRequestDTO] = None
  )
  case class NodeReplayLastEventSnapshotDTO (
    address: Option[String] = None,
    apiPort: Option[Int] = None,
    nodeId: Option[String] = None,
    snapshot: Option[ReplayLastEventSnapshotDTO] = None
  )
  case class FunnelEntity (
    bulletins: Option[Seq[BulletinEntity]] = None,
    component: Option[FunnelDTO] = None,
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    id: Option[String] = None,
    permissions: Option[PermissionsDTO] = None,
    position: Option[PositionDTO] = None,
    revision: Option[RevisionDTO] = None,
    uri: Option[String] = None
  )
  case class ParameterProviderParameterFetchEntity (
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    id: Option[String] = None,
    revision: Option[RevisionDTO] = None
  )
  case class BatchSize (
    count: Option[Int] = None,
    duration: Option[String] = None,
    size: Option[String] = None
  )
  case class BannerEntity (
    banners: Option[BannerDTO] = None
  )
  case class ParameterContextReferenceDTO (
    id: Option[String] = None,
    name: Option[String] = None
  )
  case class VerifyConfigRequestDTO (
    attributes: Option[Map[String, String]] = None,
    complete: Option[Boolean] = None,
    componentId: Option[String] = None,
    failureReason: Option[String] = None,
    lastUpdated: Option[java.time.Instant] = None,
    percentCompleted: Option[Int] = None,
    properties: Option[Map[String, String]] = None,
    requestId: Option[String] = None,
    results: Option[Seq[ConfigVerificationResultDTO]] = None,
    state: Option[String] = None,
    submissionTime: Option[java.time.Instant] = None,
    updateSteps: Option[Seq[VerifyConfigUpdateStepDTO]] = None,
    uri: Option[String] = None
  )
  case class ClusterEntity (
    cluster: Option[ClusterDTO] = None
  )
  case class VersionedLabel (
    comments: Option[String] = None,
    componentType: Option[VersionedLabelComponentType] = None,
    groupIdentifier: Option[String] = None,
    height: Option[Double] = None,
    identifier: Option[String] = None,
    instanceIdentifier: Option[String] = None,
    label: Option[String] = None,
    name: Option[String] = None,
    position: Option[Position] = None,
    style: Option[Map[String, String]] = None,
    width: Option[Double] = None,
    zIndex: Option[Long] = None
  )
  
  sealed trait VersionedLabelComponentType extends enumeratum.EnumEntry
  object VersionedLabelComponentType extends enumeratum.Enum[VersionedLabelComponentType] with enumeratum.CirceEnum[VersionedLabelComponentType] {
    val values = findValues
    case object CONNECTION extends VersionedLabelComponentType
    case object PROCESSOR extends VersionedLabelComponentType
    case object PROCESS_GROUP extends VersionedLabelComponentType
    case object REMOTE_PROCESS_GROUP extends VersionedLabelComponentType
    case object INPUT_PORT extends VersionedLabelComponentType
    case object OUTPUT_PORT extends VersionedLabelComponentType
    case object REMOTE_INPUT_PORT extends VersionedLabelComponentType
    case object REMOTE_OUTPUT_PORT extends VersionedLabelComponentType
    case object FUNNEL extends VersionedLabelComponentType
    case object LABEL extends VersionedLabelComponentType
    case object CONTROLLER_SERVICE extends VersionedLabelComponentType
    case object REPORTING_TASK extends VersionedLabelComponentType
    case object FLOW_ANALYSIS_RULE extends VersionedLabelComponentType
    case object PARAMETER_CONTEXT extends VersionedLabelComponentType
    case object PARAMETER_PROVIDER extends VersionedLabelComponentType
    case object FLOW_REGISTRY_CLIENT extends VersionedLabelComponentType
  }
  case class PortStatusSnapshotEntity (
    canRead: Option[Boolean] = None,
    id: Option[String] = None,
    portStatusSnapshot: Option[PortStatusSnapshotDTO] = None
  )
  case class SupportedMimeTypesDTO (
    displayName: Option[String] = None,
    mimeTypes: Option[Seq[String]] = None
  )
  case class ParameterDTO (
    description: Option[String] = None,
    inherited: Option[Boolean] = None,
    name: Option[String] = None,
    parameterContext: Option[ParameterContextReferenceEntity] = None,
    provided: Option[Boolean] = None,
    referencedAssets: Option[Seq[AssetReferenceDTO]] = None,
    referencingComponents: Option[Set[AffectedComponentEntity]] = None,
    sensitive: Option[Boolean] = None,
    value: Option[String] = None,
    valueRemoved: Option[Boolean] = None
  )
  case class NarCoordinateDTO (
    artifact: Option[String] = None,
    group: Option[String] = None,
    version: Option[String] = None
  )
  case class SearchResultGroupDTO (
    id: String,
    name: Option[String] = None
  )
  case class ProvenanceResultsDTO (
    errors: Option[Set[String]] = None,
    generated: Option[String] = None,
    oldestEvent: Option[String] = None,
    provenanceEvents: Option[Seq[ProvenanceEventDTO]] = None,
    timeOffset: Option[Int] = None,
    total: Option[String] = None,
    totalCount: Option[Long] = None
  )
  case class CountersSnapshotDTO (
    counters: Option[Seq[CounterDTO]] = None,
    generated: Option[String] = None
  )
  case class FunnelsEntity (
    funnels: Option[Set[FunnelEntity]] = None
  )
  case class AdditionalDetailsEntity (
    additionalDetails: Option[String] = None
  )
  case class StatusSnapshotDTO (
    statusMetrics: Option[Map[String, Long]] = None,
    timestamp: Option[java.time.Instant] = None
  )
  case class RegisteredFlowSnapshot (
    bucket: Option[FlowRegistryBucket] = None,
    externalControllerServices: Option[Map[String, ExternalControllerServiceReference]] = None,
    flow: Option[RegisteredFlow] = None,
    flowContents: Option[VersionedProcessGroup] = None,
    flowEncodingVersion: Option[String] = None,
    latest: Option[Boolean] = None,
    parameterContexts: Option[Map[String, VersionedParameterContext]] = None,
    parameterProviders: Option[Map[String, ParameterProviderReference]] = None,
    snapshotMetadata: Option[RegisteredFlowSnapshotMetadata] = None
  )
  case class LineageResultsDTO (
    errors: Option[Set[String]] = None,
    links: Option[Seq[ProvenanceLinkDTO]] = None,
    nodes: Option[Seq[ProvenanceNodeDTO]] = None
  )
  case class FlowDTO (
    connections: Option[Set[ConnectionEntity]] = None,
    funnels: Option[Set[FunnelEntity]] = None,
    inputPorts: Option[Set[PortEntity]] = None,
    labels: Option[Set[LabelEntity]] = None,
    outputPorts: Option[Set[PortEntity]] = None,
    processGroups: Option[Set[ProcessGroupEntity]] = None,
    processors: Option[Set[ProcessorEntity]] = None,
    remoteProcessGroups: Option[Set[RemoteProcessGroupEntity]] = None
  )
  case class SchedulingDefaults (
    defaultConcurrentTasksBySchedulingStrategy: Option[Map[String, Int]] = None,
    defaultMaxConcurrentTasks: Option[String] = None,
    defaultRunDurationNanos: Option[Long] = None,
    defaultSchedulingPeriodMillis: Option[Long] = None,
    defaultSchedulingPeriodsBySchedulingStrategy: Option[Map[String, String]] = None,
    defaultSchedulingStrategy: Option[SchedulingDefaultsDefaultSchedulingStrategy] = None,
    penalizationPeriodMillis: Option[Long] = None,
    yieldDurationMillis: Option[Long] = None
  )
  
  sealed trait SchedulingDefaultsDefaultSchedulingStrategy extends enumeratum.EnumEntry
  object SchedulingDefaultsDefaultSchedulingStrategy extends enumeratum.Enum[SchedulingDefaultsDefaultSchedulingStrategy] with enumeratum.CirceEnum[SchedulingDefaultsDefaultSchedulingStrategy] {
    val values = findValues
    case object TIMER_DRIVEN extends SchedulingDefaultsDefaultSchedulingStrategy
    case object CRON_DRIVEN extends SchedulingDefaultsDefaultSchedulingStrategy
  }
  case class VersionedFlowSnapshotMetadataSetEntity (
    versionedFlowSnapshotMetadataSet: Option[Set[VersionedFlowSnapshotMetadataEntity]] = None
  )
  case class NarSummaryDTO (
    buildTime: Option[String] = None,
    coordinate: Option[NarCoordinateDTO] = None,
    createdBy: Option[String] = None,
    dependencyCoordinate: Option[NarCoordinateDTO] = None,
    digest: Option[String] = None,
    extensionCount: Option[Int] = None,
    failureMessage: Option[String] = None,
    identifier: Option[String] = None,
    installComplete: Option[Boolean] = None,
    sourceIdentifier: Option[String] = None,
    sourceType: Option[String] = None,
    state: Option[String] = None
  )
  case class ReportingTaskDefinition (
    additionalDetails: Option[Boolean] = None,
    artifact: Option[String] = None,
    buildInfo: Option[BuildInfo] = None,
    defaultSchedulingPeriodBySchedulingStrategy: Option[Map[String, String]] = None,
    defaultSchedulingStrategy: Option[String] = None,
    deprecated: Option[Boolean] = None,
    deprecationAlternatives: Option[Set[String]] = None,
    deprecationReason: Option[String] = None,
    dynamicProperties: Option[Seq[DynamicProperty]] = None,
    explicitRestrictions: Option[Set[Restriction]] = None,
    group: Option[String] = None,
    propertyDescriptors: Option[Map[String, PropertyDescriptor]] = None,
    providedApiImplementations: Option[Seq[DefinedType]] = None,
    restricted: Option[Boolean] = None,
    restrictedExplanation: Option[String] = None,
    seeAlso: Option[Set[String]] = None,
    stateful: Option[Stateful] = None,
    supportedSchedulingStrategies: Option[Seq[String]] = None,
    supportsDynamicProperties: Option[Boolean] = None,
    supportsSensitiveDynamicProperties: Option[Boolean] = None,
    systemResourceConsiderations: Option[Seq[SystemResourceConsideration]] = None,
    tags: Option[Set[String]] = None,
    `type`: Option[String] = None,
    typeDescription: Option[String] = None,
    version: Option[String] = None
  )
  case class ParameterContextUpdateStepDTO (
    complete: Option[Boolean] = None,
    description: Option[String] = None,
    failureReason: Option[String] = None
  )
  case class ProvenanceNodeDTO (
    childUuids: Option[Seq[String]] = None,
    clusterNodeIdentifier: Option[String] = None,
    eventType: Option[String] = None,
    flowFileUuid: Option[String] = None,
    id: Option[String] = None,
    millis: Option[Long] = None,
    parentUuids: Option[Seq[String]] = None,
    timestamp: Option[String] = None,
    `type`: Option[ProvenanceNodeDTOType] = None
  )
  
  sealed trait ProvenanceNodeDTOType extends enumeratum.EnumEntry
  object ProvenanceNodeDTOType extends enumeratum.Enum[ProvenanceNodeDTOType] with enumeratum.CirceEnum[ProvenanceNodeDTOType] {
    val values = findValues
    case object FLOWFILE extends ProvenanceNodeDTOType
    case object EVENT extends ProvenanceNodeDTOType
  }
  case class GarbageCollectionDTO (
    collectionCount: Option[Long] = None,
    collectionMillis: Option[Long] = None,
    collectionTime: Option[String] = None,
    name: Option[String] = None
  )
  case class ProcessGroupFlowDTO (
    breadcrumb: Option[FlowBreadcrumbEntity] = None,
    flow: Option[FlowDTO] = None,
    id: Option[String] = None,
    lastRefreshed: Option[String] = None,
    parameterContext: Option[ParameterContextReferenceEntity] = None,
    parentGroupId: Option[String] = None,
    uri: Option[String] = None
  )
  case class StateMapDTO (
    scope: Option[String] = None,
    state: Option[Seq[StateEntryDTO]] = None,
    totalEntryCount: Option[Int] = None
  )
  case class RemoteProcessGroupsEntity (
    remoteProcessGroups: Option[Set[RemoteProcessGroupEntity]] = None
  )
  case class RemoteProcessGroupDTO (
    activeRemoteInputPortCount: Option[Int] = None,
    activeRemoteOutputPortCount: Option[Int] = None,
    authorizationIssues: Option[Seq[String]] = None,
    comments: Option[String] = None,
    communicationsTimeout: Option[String] = None,
    contents: Option[RemoteProcessGroupContentsDTO] = None,
    flowRefreshed: Option[String] = None,
    id: Option[String] = None,
    inactiveRemoteInputPortCount: Option[Int] = None,
    inactiveRemoteOutputPortCount: Option[Int] = None,
    inputPortCount: Option[Int] = None,
    localNetworkInterface: Option[String] = None,
    name: Option[String] = None,
    outputPortCount: Option[Int] = None,
    parentGroupId: Option[String] = None,
    position: Option[PositionDTO] = None,
    proxyHost: Option[String] = None,
    proxyPassword: Option[String] = None,
    proxyPort: Option[Int] = None,
    proxyUser: Option[String] = None,
    targetSecure: Option[Boolean] = None,
    targetUri: Option[String] = None,
    targetUris: Option[String] = None,
    transmitting: Option[Boolean] = None,
    transportProtocol: Option[String] = None,
    validationErrors: Option[Seq[String]] = None,
    versionedComponentId: Option[String] = None,
    yieldDuration: Option[String] = None
  )
  case class ParameterProviderApplyParametersRequestEntity (
    request: Option[ParameterProviderApplyParametersRequestDTO] = None
  )
  case class VersionedReportingTaskImportRequestEntity (
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    reportingTaskSnapshot: Option[VersionedReportingTaskSnapshot] = None
  )
  case class PropertyAllowableValue (
    description: Option[String] = None,
    displayName: Option[String] = None,
    value: Option[String] = None
  )
  case class DynamicProperty (
    description: Option[String] = None,
    expressionLanguageScope: Option[DynamicPropertyExpressionLanguageScope] = None,
    name: Option[String] = None,
    value: Option[String] = None
  )
  
  sealed trait DynamicPropertyExpressionLanguageScope extends enumeratum.EnumEntry
  object DynamicPropertyExpressionLanguageScope extends enumeratum.Enum[DynamicPropertyExpressionLanguageScope] with enumeratum.CirceEnum[DynamicPropertyExpressionLanguageScope] {
    val values = findValues
    case object NONE extends DynamicPropertyExpressionLanguageScope
    case object ENVIRONMENT extends DynamicPropertyExpressionLanguageScope
    case object FLOWFILE_ATTRIBUTES extends DynamicPropertyExpressionLanguageScope
  }
  case class NodeCountersSnapshotDTO (
    address: Option[String] = None,
    apiPort: Option[Int] = None,
    nodeId: Option[String] = None,
    snapshot: Option[CountersSnapshotDTO] = None
  )
  case class FlowConfigurationEntity (
    flowConfiguration: Option[FlowConfigurationDTO] = None
  )
  case class VersionedPort (
    allowRemoteAccess: Option[Boolean] = None,
    comments: Option[String] = None,
    componentType: Option[VersionedPortComponentType] = None,
    concurrentlySchedulableTaskCount: Option[Int] = None,
    groupIdentifier: Option[String] = None,
    identifier: Option[String] = None,
    instanceIdentifier: Option[String] = None,
    name: Option[String] = None,
    portFunction: Option[VersionedPortPortFunction] = None,
    position: Option[Position] = None,
    scheduledState: Option[VersionedPortScheduledState] = None,
    `type`: Option[VersionedPortType] = None
  )
  
  sealed trait VersionedPortComponentType extends enumeratum.EnumEntry
  object VersionedPortComponentType extends enumeratum.Enum[VersionedPortComponentType] with enumeratum.CirceEnum[VersionedPortComponentType] {
    val values = findValues
    case object CONNECTION extends VersionedPortComponentType
    case object PROCESSOR extends VersionedPortComponentType
    case object PROCESS_GROUP extends VersionedPortComponentType
    case object REMOTE_PROCESS_GROUP extends VersionedPortComponentType
    case object INPUT_PORT extends VersionedPortComponentType
    case object OUTPUT_PORT extends VersionedPortComponentType
    case object REMOTE_INPUT_PORT extends VersionedPortComponentType
    case object REMOTE_OUTPUT_PORT extends VersionedPortComponentType
    case object FUNNEL extends VersionedPortComponentType
    case object LABEL extends VersionedPortComponentType
    case object CONTROLLER_SERVICE extends VersionedPortComponentType
    case object REPORTING_TASK extends VersionedPortComponentType
    case object FLOW_ANALYSIS_RULE extends VersionedPortComponentType
    case object PARAMETER_CONTEXT extends VersionedPortComponentType
    case object PARAMETER_PROVIDER extends VersionedPortComponentType
    case object FLOW_REGISTRY_CLIENT extends VersionedPortComponentType
  }
  
  sealed trait VersionedPortPortFunction extends enumeratum.EnumEntry
  object VersionedPortPortFunction extends enumeratum.Enum[VersionedPortPortFunction] with enumeratum.CirceEnum[VersionedPortPortFunction] {
    val values = findValues
    case object STANDARD extends VersionedPortPortFunction
    case object FAILURE extends VersionedPortPortFunction
  }
  
  sealed trait VersionedPortScheduledState extends enumeratum.EnumEntry
  object VersionedPortScheduledState extends enumeratum.Enum[VersionedPortScheduledState] with enumeratum.CirceEnum[VersionedPortScheduledState] {
    val values = findValues
    case object ENABLED extends VersionedPortScheduledState
    case object DISABLED extends VersionedPortScheduledState
    case object RUNNING extends VersionedPortScheduledState
  }
  
  sealed trait VersionedPortType extends enumeratum.EnumEntry
  object VersionedPortType extends enumeratum.Enum[VersionedPortType] with enumeratum.CirceEnum[VersionedPortType] {
    val values = findValues
    case object INPUT_PORT extends VersionedPortType
    case object OUTPUT_PORT extends VersionedPortType
  }
  case class LineageDTO (
    expiration: Option[String] = None,
    finished: Option[Boolean] = None,
    id: Option[String] = None,
    percentCompleted: Option[Int] = None,
    request: Option[LineageRequestDTO] = None,
    results: Option[LineageResultsDTO] = None,
    submissionTime: Option[String] = None,
    uri: Option[String] = None
  )
  case class NodeSystemDiagnosticsSnapshotDTO (
    address: Option[String] = None,
    apiPort: Option[Int] = None,
    nodeId: Option[String] = None,
    snapshot: Option[SystemDiagnosticsSnapshotDTO] = None
  )
  case class VersionedRemoteGroupPort (
    batchSize: Option[BatchSize] = None,
    comments: Option[String] = None,
    componentType: Option[VersionedRemoteGroupPortComponentType] = None,
    concurrentlySchedulableTaskCount: Option[Int] = None,
    groupIdentifier: Option[String] = None,
    identifier: Option[String] = None,
    instanceIdentifier: Option[String] = None,
    name: Option[String] = None,
    position: Option[Position] = None,
    remoteGroupId: Option[String] = None,
    scheduledState: Option[VersionedRemoteGroupPortScheduledState] = None,
    targetId: Option[String] = None,
    useCompression: Option[Boolean] = None
  )
  
  sealed trait VersionedRemoteGroupPortComponentType extends enumeratum.EnumEntry
  object VersionedRemoteGroupPortComponentType extends enumeratum.Enum[VersionedRemoteGroupPortComponentType] with enumeratum.CirceEnum[VersionedRemoteGroupPortComponentType] {
    val values = findValues
    case object CONNECTION extends VersionedRemoteGroupPortComponentType
    case object PROCESSOR extends VersionedRemoteGroupPortComponentType
    case object PROCESS_GROUP extends VersionedRemoteGroupPortComponentType
    case object REMOTE_PROCESS_GROUP extends VersionedRemoteGroupPortComponentType
    case object INPUT_PORT extends VersionedRemoteGroupPortComponentType
    case object OUTPUT_PORT extends VersionedRemoteGroupPortComponentType
    case object REMOTE_INPUT_PORT extends VersionedRemoteGroupPortComponentType
    case object REMOTE_OUTPUT_PORT extends VersionedRemoteGroupPortComponentType
    case object FUNNEL extends VersionedRemoteGroupPortComponentType
    case object LABEL extends VersionedRemoteGroupPortComponentType
    case object CONTROLLER_SERVICE extends VersionedRemoteGroupPortComponentType
    case object REPORTING_TASK extends VersionedRemoteGroupPortComponentType
    case object FLOW_ANALYSIS_RULE extends VersionedRemoteGroupPortComponentType
    case object PARAMETER_CONTEXT extends VersionedRemoteGroupPortComponentType
    case object PARAMETER_PROVIDER extends VersionedRemoteGroupPortComponentType
    case object FLOW_REGISTRY_CLIENT extends VersionedRemoteGroupPortComponentType
  }
  
  sealed trait VersionedRemoteGroupPortScheduledState extends enumeratum.EnumEntry
  object VersionedRemoteGroupPortScheduledState extends enumeratum.Enum[VersionedRemoteGroupPortScheduledState] with enumeratum.CirceEnum[VersionedRemoteGroupPortScheduledState] {
    val values = findValues
    case object ENABLED extends VersionedRemoteGroupPortScheduledState
    case object DISABLED extends VersionedRemoteGroupPortScheduledState
    case object RUNNING extends VersionedRemoteGroupPortScheduledState
  }
  case class AssetReferenceDTO (
    id: Option[String] = None,
    name: Option[String] = None
  )
  case class ProvenanceEventDTO (
    alternateIdentifierUri: Option[String] = None,
    attributes: Option[Seq[AttributeDTO]] = None,
    childUuids: Option[Seq[String]] = None,
    clusterNodeAddress: Option[String] = None,
    clusterNodeId: Option[String] = None,
    componentId: Option[String] = None,
    componentName: Option[String] = None,
    componentType: Option[String] = None,
    contentEqual: Option[Boolean] = None,
    details: Option[String] = None,
    eventDuration: Option[Long] = None,
    eventId: Option[Long] = None,
    eventTime: Option[String] = None,
    eventType: Option[String] = None,
    fileSize: Option[String] = None,
    fileSizeBytes: Option[Long] = None,
    flowFileUuid: Option[String] = None,
    groupId: Option[String] = None,
    id: Option[String] = None,
    inputContentAvailable: Option[Boolean] = None,
    inputContentClaimContainer: Option[String] = None,
    inputContentClaimFileSize: Option[String] = None,
    inputContentClaimFileSizeBytes: Option[Long] = None,
    inputContentClaimIdentifier: Option[String] = None,
    inputContentClaimOffset: Option[Long] = None,
    inputContentClaimSection: Option[String] = None,
    lineageDuration: Option[Long] = None,
    outputContentAvailable: Option[Boolean] = None,
    outputContentClaimContainer: Option[String] = None,
    outputContentClaimFileSize: Option[String] = None,
    outputContentClaimFileSizeBytes: Option[Long] = None,
    outputContentClaimIdentifier: Option[String] = None,
    outputContentClaimOffset: Option[Long] = None,
    outputContentClaimSection: Option[String] = None,
    parentUuids: Option[Seq[String]] = None,
    relationship: Option[String] = None,
    replayAvailable: Option[Boolean] = None,
    replayExplanation: Option[String] = None,
    sourceConnectionIdentifier: Option[String] = None,
    sourceSystemFlowFileId: Option[String] = None,
    transitUri: Option[String] = None
  )
  case class DropRequestEntity (
    dropRequest: Option[DropRequestDTO] = None
  )
  case class ProvenanceEventEntity (
    provenanceEvent: Option[ProvenanceEventDTO] = None
  )
  case class LatestProvenanceEventsEntity (
    latestProvenanceEvents: Option[LatestProvenanceEventsDTO] = None
  )
  case class ProcessorStatusEntity (
    canRead: Option[Boolean] = None,
    processorStatus: Option[ProcessorStatusDTO] = None
  )
  case class StateEntryDTO (
    clusterNodeAddress: Option[String] = None,
    clusterNodeId: Option[String] = None,
    key: Option[String] = None,
    value: Option[String] = None
  )
  case class FlowAnalysisRuleEntity (
    bulletins: Option[Seq[BulletinEntity]] = None,
    component: Option[FlowAnalysisRuleDTO] = None,
    disconnectedNodeAcknowledged: Option[Boolean] = None,
    id: Option[String] = None,
    operatePermissions: Option[PermissionsDTO] = None,
    permissions: Option[PermissionsDTO] = None,
    position: Option[PositionDTO] = None,
    revision: Option[RevisionDTO] = None,
    status: Option[FlowAnalysisRuleStatusDTO] = None,
    uri: Option[String] = None
  )
  case class CountersEntity (
    counters: Option[CountersDTO] = None
  )
  case class FlowConfigurationDTO (
    currentTime: Option[String] = None,
    defaultBackPressureDataSizeThreshold: Option[String] = None,
    defaultBackPressureObjectThreshold: Option[Long] = None,
    supportsConfigurableAuthorizer: Option[Boolean] = None,
    supportsConfigurableUsersAndGroups: Option[Boolean] = None,
    supportsManagedAuthorizer: Option[Boolean] = None,
    timeOffset: Option[Int] = None
  )
  case class ComponentStateEntity (
    componentState: Option[ComponentStateDTO] = None
  )
  case class VerifyConfigUpdateStepDTO (
    complete: Option[Boolean] = None,
    description: Option[String] = None,
    failureReason: Option[String] = None
  )
  case class RelationshipDTO (
    autoTerminate: Option[Boolean] = None,
    description: Option[String] = None,
    name: Option[String] = None,
    retry: Option[Boolean] = None
  )
  case class LongParameter (
    long: Option[Long] = None
  )
  case class ControllerServiceDTO (
    annotationData: Option[String] = None,
    bulletinLevel: Option[String] = None,
    bundle: Option[BundleDTO] = None,
    comments: Option[String] = None,
    controllerServiceApis: Option[Seq[ControllerServiceApiDTO]] = None,
    customUiUrl: Option[String] = None,
    deprecated: Option[Boolean] = None,
    descriptors: Option[Map[String, PropertyDescriptorDTO]] = None,
    extensionMissing: Option[Boolean] = None,
    id: Option[String] = None,
    multipleVersionsAvailable: Option[Boolean] = None,
    name: Option[String] = None,
    parentGroupId: Option[String] = None,
    persistsState: Option[Boolean] = None,
    position: Option[PositionDTO] = None,
    properties: Option[Map[String, String]] = None,
    referencingComponents: Option[Set[ControllerServiceReferencingComponentEntity]] = None,
    restricted: Option[Boolean] = None,
    sensitiveDynamicPropertyNames: Option[Set[String]] = None,
    state: Option[ControllerServiceDTOState] = None,
    supportsSensitiveDynamicProperties: Option[Boolean] = None,
    `type`: Option[String] = None,
    validationErrors: Option[Seq[String]] = None,
    validationStatus: Option[ControllerServiceDTOValidationStatus] = None,
    versionedComponentId: Option[String] = None
  )
  
  sealed trait ControllerServiceDTOState extends enumeratum.EnumEntry
  object ControllerServiceDTOState extends enumeratum.Enum[ControllerServiceDTOState] with enumeratum.CirceEnum[ControllerServiceDTOState] {
    val values = findValues
    case object ENABLED extends ControllerServiceDTOState
    case object ENABLING extends ControllerServiceDTOState
    case object DISABLED extends ControllerServiceDTOState
    case object DISABLING extends ControllerServiceDTOState
  }
  
  sealed trait ControllerServiceDTOValidationStatus extends enumeratum.EnumEntry
  object ControllerServiceDTOValidationStatus extends enumeratum.Enum[ControllerServiceDTOValidationStatus] with enumeratum.CirceEnum[ControllerServiceDTOValidationStatus] {
    val values = findValues
    case object VALID extends ControllerServiceDTOValidationStatus
    case object INVALID extends ControllerServiceDTOValidationStatus
    case object VALIDATING extends ControllerServiceDTOValidationStatus
  }
  case class VersionedResourceDefinition (
    cardinality: Option[VersionedResourceDefinitionCardinality] = None,
    resourceTypes: Option[Set[VersionedResourceDefinitionResourceTypesItem]] = None
  )
  
  sealed trait VersionedResourceDefinitionCardinality extends enumeratum.EnumEntry
  object VersionedResourceDefinitionCardinality extends enumeratum.Enum[VersionedResourceDefinitionCardinality] with enumeratum.CirceEnum[VersionedResourceDefinitionCardinality] {
    val values = findValues
    case object SINGLE extends VersionedResourceDefinitionCardinality
    case object MULTIPLE extends VersionedResourceDefinitionCardinality
  }
  
  sealed trait VersionedResourceDefinitionResourceTypesItem extends enumeratum.EnumEntry
  object VersionedResourceDefinitionResourceTypesItem extends enumeratum.Enum[VersionedResourceDefinitionResourceTypesItem] with enumeratum.CirceEnum[VersionedResourceDefinitionResourceTypesItem] {
    val values = findValues
    case object FILE extends VersionedResourceDefinitionResourceTypesItem
    case object DIRECTORY extends VersionedResourceDefinitionResourceTypesItem
    case object TEXT extends VersionedResourceDefinitionResourceTypesItem
    case object URL extends VersionedResourceDefinitionResourceTypesItem
  }
  case class SystemDiagnosticsSnapshotDTO (
    availableProcessors: Option[Int] = None,
    contentRepositoryStorageUsage: Option[Set[StorageUsageDTO]] = None,
    daemonThreads: Option[Int] = None,
    flowFileRepositoryStorageUsage: Option[StorageUsageDTO] = None,
    freeHeap: Option[String] = None,
    freeHeapBytes: Option[Long] = None,
    freeNonHeap: Option[String] = None,
    freeNonHeapBytes: Option[Long] = None,
    garbageCollection: Option[Set[GarbageCollectionDTO]] = None,
    heapUtilization: Option[String] = None,
    maxHeap: Option[String] = None,
    maxHeapBytes: Option[Long] = None,
    maxNonHeap: Option[String] = None,
    maxNonHeapBytes: Option[Long] = None,
    nonHeapUtilization: Option[String] = None,
    processorLoadAverage: Option[Double] = None,
    provenanceRepositoryStorageUsage: Option[Set[StorageUsageDTO]] = None,
    resourceClaimDetails: Option[Seq[ResourceClaimDetailsDTO]] = None,
    statsLastRefreshed: Option[String] = None,
    totalHeap: Option[String] = None,
    totalHeapBytes: Option[Long] = None,
    totalNonHeap: Option[String] = None,
    totalNonHeapBytes: Option[Long] = None,
    totalThreads: Option[Int] = None,
    uptime: Option[String] = None,
    usedHeap: Option[String] = None,
    usedHeapBytes: Option[Long] = None,
    usedNonHeap: Option[String] = None,
    usedNonHeapBytes: Option[Long] = None,
    versionInfo: Option[VersionInfoDTO] = None
  )
  case class DocumentedTypeDTO (
    bundle: Option[BundleDTO] = None,
    controllerServiceApis: Option[Seq[ControllerServiceApiDTO]] = None,
    deprecationReason: Option[String] = None,
    description: Option[String] = None,
    explicitRestrictions: Option[Set[ExplicitRestrictionDTO]] = None,
    restricted: Option[Boolean] = None,
    tags: Option[Set[String]] = None,
    `type`: Option[String] = None,
    usageRestriction: Option[String] = None
  )
  case class CreateAccessTokenRequest (
    password: Option[String] = None,
    username: Option[String] = None
  )
  
  sealed trait ClearState_1BodyIn extends Product with java.io.Serializable
  case class ClearState_1Body0In(value: Array[Byte]) extends ClearState_1BodyIn
  case class ClearState_1BodyOption_ComponentStateEntity_In(value: Option[ComponentStateEntity]) extends ClearState_1BodyIn
  
  
  sealed trait ClearStateBodyIn extends Product with java.io.Serializable
  case class ClearStateBody0In(value: Array[Byte]) extends ClearStateBodyIn
  case class ClearStateBodyOption_ComponentStateEntity_In(value: Option[ComponentStateEntity]) extends ClearStateBodyIn
  
  case class UploadNarRequest (
  
  )
  case class ExtendInputPortTransactionTTLRequest (
  
  )
  case class CommitInputPortTransactionRequest (
  
  )
  case class ReceiveFlowFilesRequest (
  
  )
  case class ExtendOutputPortTransactionTTLRequest (
  
  )
  case class CommitOutputPortTransactionRequest (
  
  )
  case class TransferFlowFilesRequest (
  
  )
  case class CreatePortTransactionRequest (
  
  )
  case class CreateAssetRequest (
  
  )
  
  sealed trait ClearState_2BodyIn extends Product with java.io.Serializable
  case class ClearState_2Body0In(value: Array[Byte]) extends ClearState_2BodyIn
  case class ClearState_2BodyOption_ComponentStateEntity_In(value: Option[ComponentStateEntity]) extends ClearState_2BodyIn
  
  case class UploadProcessGroupRequest (
    clientId: String,
    disconnectedNodeAcknowledged: Option[Boolean] = Some(false),
    file: Option[sttp.model.Part[java.io.File]] = None,
    groupName: String,
    positionX: Double,
    positionY: Double
  )
  
  sealed trait GetProcessorRunStatusDetailsBodyIn extends Product with java.io.Serializable
  case class GetProcessorRunStatusDetailsBody0In(value: Array[Byte]) extends GetProcessorRunStatusDetailsBodyIn
  case class GetProcessorRunStatusDetailsBodyOption_RunStatusDetailsRequestEntity_In(value: Option[RunStatusDetailsRequestEntity]) extends GetProcessorRunStatusDetailsBodyIn
  
  
  sealed trait ClearState_3BodyIn extends Product with java.io.Serializable
  case class ClearState_3Body0In(value: Array[Byte]) extends ClearState_3BodyIn
  case class ClearState_3BodyOption_ComponentStateEntity_In(value: Option[ComponentStateEntity]) extends ClearState_3BodyIn
  
  
  sealed trait ClearState_4BodyIn extends Product with java.io.Serializable
  case class ClearState_4Body0In(value: Array[Byte]) extends ClearState_4BodyIn
  case class ClearState_4BodyOption_ComponentStateEntity_In(value: Option[ComponentStateEntity]) extends ClearState_4BodyIn



  type LogOutEndpoint = Endpoint[String, Unit, Unit, Unit, Any]
  lazy val logOut: LogOutEndpoint =
    endpoint
      .name("logOut")
      .delete
      .in(("access" / "logout"))
      .securityIn(auth.apiKey(cookie[String]("__Secure-Authorization-Bearer")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Authentication token provided was empty or not in the correct JWT format."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(500), emptyOutput.description("Client failed to log out."))(())))
      .tags(List("Access"))
  
  type LogOutCompleteEndpoint = Endpoint[String, Unit, Unit, Unit, Any]
  lazy val logOutComplete: LogOutCompleteEndpoint =
    endpoint
      .name("logOutComplete")
      .get
      .in(("access" / "logout" / "complete"))
      .securityIn(auth.apiKey(cookie[String]("__Secure-Authorization-Bearer")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Authentication token provided was empty or not in the correct JWT format."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(500), emptyOutput.description("Client failed to log out."))(())))
      .out(statusCode(sttp.model.StatusCode(302)).description("User was logged out successfully."))
      .tags(List("Access"))
  
  type CreateAccessTokenEndpoint = Endpoint[Unit, sttp.capabilities.pekko.PekkoStreams.BinaryStream, Unit, String, sttp.capabilities.pekko.PekkoStreams]
  lazy val createAccessToken: CreateAccessTokenEndpoint =
    endpoint
      .name("createAccessToken")
      .post
      .in(("access" / "token"))
      .in(streamBody(sttp.capabilities.pekko.PekkoStreams)(Schema.binary[CreateAccessTokenRequest], CodecFormat.XWwwFormUrlencoded()))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(500), emptyOutput.description("Unable to create access token because an unexpected error occurred."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(())))
      .out(stringBody.description("").and(statusCode(sttp.model.StatusCode(201))))
      .tags(List("Access"))
  
  type GetAuthenticationConfigurationEndpoint = Endpoint[Unit, Unit, AuthenticationConfigurationEntity, Unit, Any]
  lazy val getAuthenticationConfiguration: GetAuthenticationConfigurationEndpoint =
    endpoint
      .name("getAuthenticationConfiguration")
      .get
      .in(("authentication" / "configuration"))
      .errorOut(jsonBody[AuthenticationConfigurationEntity].description(""))
      .tags(List("Authentication"))
  
  type GetConnectionEndpoint = Endpoint[Unit, String, Unit, ConnectionEntity, Any]
  lazy val getConnection: GetConnectionEndpoint =
    endpoint
      .name("getConnection")
      .get
      .in(("connections" / path[String]("id").description("The connection id.")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ConnectionEntity].description(""))
      .tags(List("Connections"))
  
  type UpdateConnectionEndpoint = Endpoint[Unit, (String, ConnectionEntity), Unit, ConnectionEntity, Any]
  lazy val updateConnection: UpdateConnectionEndpoint =
    endpoint
      .name("updateConnection")
      .put
      .in(("connections" / path[String]("id").description("The connection id.")))
      .in(jsonBody[ConnectionEntity].description("The connection configuration details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ConnectionEntity].description(""))
      .tags(List("Connections"))
  
  type DeleteConnectionEndpoint = Endpoint[Unit, (String, Option[LongParameterInt], Option[ClientIdParameterStr], Option[Boolean]), Unit, ConnectionEntity, Any]
  lazy val deleteConnection: DeleteConnectionEndpoint =
    endpoint
      .name("deleteConnection")
      .delete
      .in(("connections" / path[String]("id").description("The connection id.")))
      .in(query[Option[LongParameterInt]]("version").description("The revision is used to verify the client is working with the latest version of the flow."))
      .in(query[Option[ClientIdParameterStr]]("clientId").description("If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response."))
      .in(query[Option[Boolean]]("disconnectedNodeAcknowledged").description("Acknowledges that this node is disconnected to allow for mutable requests to proceed."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ConnectionEntity].description(""))
      .tags(List("Connections"))
  
  type GetControllerServiceEndpoint = Endpoint[Unit, (String, Option[Boolean]), Unit, ControllerServiceEntity, Any]
  lazy val getControllerService: GetControllerServiceEndpoint =
    endpoint
      .name("getControllerService")
      .get
      .in(("controller-services" / path[String]("id").description("The controller service id.")))
      .in(query[Option[Boolean]]("uiOnly"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ControllerServiceEntity].description(""))
      .tags(List("Controller Services"))
  
  type UpdateControllerServiceEndpoint = Endpoint[Unit, (String, ControllerServiceEntity), Unit, ControllerServiceEntity, Any]
  lazy val updateControllerService: UpdateControllerServiceEndpoint =
    endpoint
      .name("updateControllerService")
      .put
      .in(("controller-services" / path[String]("id").description("The controller service id.")))
      .in(jsonBody[ControllerServiceEntity].description("The controller service configuration details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ControllerServiceEntity].description(""))
      .tags(List("Controller Services"))
  
  type RemoveControllerServiceEndpoint = Endpoint[Unit, (String, Option[LongParameterInt], Option[ClientIdParameterStr], Option[Boolean]), Unit, ControllerServiceEntity, Any]
  lazy val removeControllerService: RemoveControllerServiceEndpoint =
    endpoint
      .name("removeControllerService")
      .delete
      .in(("controller-services" / path[String]("id").description("The controller service id.")))
      .in(query[Option[LongParameterInt]]("version").description("The revision is used to verify the client is working with the latest version of the flow."))
      .in(query[Option[ClientIdParameterStr]]("clientId").description("If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response."))
      .in(query[Option[Boolean]]("disconnectedNodeAcknowledged").description("Acknowledges that this node is disconnected to allow for mutable requests to proceed."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ControllerServiceEntity].description(""))
      .tags(List("Controller Services"))
  
  type AnalyzeConfigurationEndpoint = Endpoint[Unit, (String, ConfigurationAnalysisEntity), Unit, ConfigurationAnalysisEntity, Any]
  lazy val analyzeConfiguration: AnalyzeConfigurationEndpoint =
    endpoint
      .name("analyzeConfiguration")
      .post
      .in(("controller-services" / path[String]("id").description("The controller service id.") / "config" / "analysis"))
      .in(jsonBody[ConfigurationAnalysisEntity].description("The configuration analysis request."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ConfigurationAnalysisEntity].description(""))
      .tags(List("Controller Services"))
  
  type SubmitConfigVerificationRequestEndpoint = Endpoint[Unit, (String, VerifyConfigRequestEntity), Unit, VerifyConfigRequestEntity, Any]
  lazy val submitConfigVerificationRequest: SubmitConfigVerificationRequestEndpoint =
    endpoint
      .name("submitConfigVerificationRequest")
      .post
      .in(("controller-services" / path[String]("id").description("The controller service id.") / "config" / "verification-requests"))
      .in(jsonBody[VerifyConfigRequestEntity].description("The controller service configuration verification request."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[VerifyConfigRequestEntity].description(""))
      .tags(List("Controller Services"))
  
  type GetVerificationRequestEndpoint = Endpoint[Unit, (String, String), Unit, VerifyConfigRequestEntity, Any]
  lazy val getVerificationRequest: GetVerificationRequestEndpoint =
    endpoint
      .name("getVerificationRequest")
      .get
      .in(("controller-services" / path[String]("id").description("The ID of the Controller Service") / "config" / "verification-requests" / path[String]("requestId").description("The ID of the Verification Request")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[VerifyConfigRequestEntity].description(""))
      .tags(List("Controller Services"))
  
  type DeleteVerificationRequestEndpoint = Endpoint[Unit, (String, String), Unit, VerifyConfigRequestEntity, Any]
  lazy val deleteVerificationRequest: DeleteVerificationRequestEndpoint =
    endpoint
      .name("deleteVerificationRequest")
      .delete
      .in(("controller-services" / path[String]("id").description("The ID of the Controller Service") / "config" / "verification-requests" / path[String]("requestId").description("The ID of the Verification Request")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[VerifyConfigRequestEntity].description(""))
      .tags(List("Controller Services"))
  
  type GetPropertyDescriptor_1Endpoint = Endpoint[Unit, (String, String, Option[Boolean]), Unit, PropertyDescriptorEntity, Any]
  lazy val getPropertyDescriptor_1: GetPropertyDescriptor_1Endpoint =
    endpoint
      .name("getPropertyDescriptor_1")
      .get
      .in(("controller-services" / path[String]("id").description("The controller service id.") / "descriptors"))
      .in(query[String]("propertyName").description("The property name to return the descriptor for."))
      .in(query[Option[Boolean]]("sensitive").description("Property Descriptor requested sensitive status"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[PropertyDescriptorEntity].description(""))
      .tags(List("Controller Services"))
  
  type GetControllerServiceReferencesEndpoint = Endpoint[Unit, String, Unit, ControllerServiceReferencingComponentsEntity, Any]
  lazy val getControllerServiceReferences: GetControllerServiceReferencesEndpoint =
    endpoint
      .name("getControllerServiceReferences")
      .get
      .in(("controller-services" / path[String]("id").description("The controller service id.") / "references"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ControllerServiceReferencingComponentsEntity].description(""))
      .tags(List("Controller Services"))
  
  type UpdateControllerServiceReferencesEndpoint = Endpoint[Unit, (String, UpdateControllerServiceReferenceRequestEntity), Unit, ControllerServiceReferencingComponentsEntity, Any]
  lazy val updateControllerServiceReferences: UpdateControllerServiceReferencesEndpoint =
    endpoint
      .name("updateControllerServiceReferences")
      .put
      .in(("controller-services" / path[String]("id").description("The controller service id.") / "references"))
      .in(jsonBody[UpdateControllerServiceReferenceRequestEntity].description("The controller service request update request."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ControllerServiceReferencingComponentsEntity].description(""))
      .tags(List("Controller Services"))
  
  type UpdateRunStatus_1Endpoint = Endpoint[Unit, (String, ControllerServiceRunStatusEntity), Unit, ControllerServiceEntity, Any]
  lazy val updateRunStatus_1: UpdateRunStatus_1Endpoint =
    endpoint
      .name("updateRunStatus_1")
      .put
      .in(("controller-services" / path[String]("id").description("The controller service id.") / "run-status"))
      .in(jsonBody[ControllerServiceRunStatusEntity].description("The controller service run status."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ControllerServiceEntity].description(""))
      .tags(List("Controller Services"))
  
  type GetStateEndpoint = Endpoint[Unit, String, Unit, ComponentStateEntity, Any]
  lazy val getState: GetStateEndpoint =
    endpoint
      .name("getState")
      .get
      .in(("controller-services" / path[String]("id").description("The controller service id.") / "state"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ComponentStateEntity].description(""))
      .tags(List("Controller Services"))
  
  type ClearState_1Endpoint = Endpoint[Unit, (String, ClearState_1BodyIn), Unit, ComponentStateEntity, Any]
  lazy val clearState_1: ClearState_1Endpoint =
    endpoint
      .name("clearState_1")
      .post
      .in(("controller-services" / path[String]("id").description("The controller service id.") / "state" / "clear-requests"))
      .in(oneOfBody[ClearState_1BodyIn](
        EndpointIO.Body(RawBodyType.ByteArrayBody, Codec.id[Array[Byte], `*/*CodecFormat`](`*/*CodecFormat`(), Schema.schemaForByteArray), EndpointIO.Info.empty).map(ClearState_1Body0In(_))(_.value).widenBody[ClearState_1BodyIn].description("Optional component state to perform a selective key removal. If omitted, clears all state."),
        jsonBody[Option[ComponentStateEntity]].map(ClearState_1BodyOption_ComponentStateEntity_In(_))(_.value).widenBody[ClearState_1BodyIn].description("Optional component state to perform a selective key removal. If omitted, clears all state.")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ComponentStateEntity].description(""))
      .tags(List("Controller Services"))
  
  type CreateBulletinEndpoint = Endpoint[Unit, BulletinEntity, Unit, BulletinEntity, Any]
  lazy val createBulletin: CreateBulletinEndpoint =
    endpoint
      .name("createBulletin")
      .post
      .in(("controller" / "bulletin"))
      .in(jsonBody[BulletinEntity].description("The reporting task configuration details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[BulletinEntity].description(""))
      .tags(List("Controller"))
  
  type GetClusterEndpoint = Endpoint[Unit, Unit, Unit, ClusterEntity, Any]
  lazy val getCluster: GetClusterEndpoint =
    endpoint
      .name("getCluster")
      .get
      .in(("controller" / "cluster"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ClusterEntity].description(""))
      .tags(List("Controller"))
  
  type GetNodeEndpoint = Endpoint[Unit, String, Unit, NodeEntity, Any]
  lazy val getNode: GetNodeEndpoint =
    endpoint
      .name("getNode")
      .get
      .in(("controller" / "cluster" / "nodes" / path[String]("id").description("The node id.")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[NodeEntity].description(""))
      .tags(List("Controller"))
  
  type UpdateNodeEndpoint = Endpoint[Unit, (String, NodeEntity), Unit, NodeEntity, Any]
  lazy val updateNode: UpdateNodeEndpoint =
    endpoint
      .name("updateNode")
      .put
      .in(("controller" / "cluster" / "nodes" / path[String]("id").description("The node id.")))
      .in(jsonBody[NodeEntity].description("The node configuration. The only configuration that will be honored at this endpoint is the status."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[NodeEntity].description(""))
      .tags(List("Controller"))
  
  type DeleteNodeEndpoint = Endpoint[Unit, String, Unit, NodeEntity, Any]
  lazy val deleteNode: DeleteNodeEndpoint =
    endpoint
      .name("deleteNode")
      .delete
      .in(("controller" / "cluster" / "nodes" / path[String]("id").description("The node id.")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[NodeEntity].description(""))
      .tags(List("Controller"))
  
  type GetControllerConfigEndpoint = Endpoint[Unit, Unit, Unit, ControllerConfigurationEntity, Any]
  lazy val getControllerConfig: GetControllerConfigEndpoint =
    endpoint
      .name("getControllerConfig")
      .get
      .in(("controller" / "config"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ControllerConfigurationEntity].description(""))
      .tags(List("Controller"))
  
  type UpdateControllerConfigEndpoint = Endpoint[Unit, ControllerConfigurationEntity, Unit, ControllerConfigurationEntity, Any]
  lazy val updateControllerConfig: UpdateControllerConfigEndpoint =
    endpoint
      .name("updateControllerConfig")
      .put
      .in(("controller" / "config"))
      .in(jsonBody[ControllerConfigurationEntity].description("The controller configuration."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ControllerConfigurationEntity].description(""))
      .tags(List("Controller"))
  
  type CreateControllerServiceEndpoint = Endpoint[Unit, ControllerServiceEntity, Unit, ControllerServiceEntity, Any]
  lazy val createControllerService: CreateControllerServiceEndpoint =
    endpoint
      .name("createControllerService")
      .post
      .in(("controller" / "controller-services"))
      .in(jsonBody[ControllerServiceEntity].description("The controller service configuration details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ControllerServiceEntity].description("").and(statusCode(sttp.model.StatusCode(201))))
      .tags(List("Controller"))
  
  type GetFlowAnalysisRulesEndpoint = Endpoint[Unit, Unit, Unit, FlowAnalysisRulesEntity, Any]
  lazy val getFlowAnalysisRules: GetFlowAnalysisRulesEndpoint =
    endpoint
      .name("getFlowAnalysisRules")
      .get
      .in(("controller" / "flow-analysis-rules"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[FlowAnalysisRulesEntity].description(""))
      .tags(List("Controller"))
  
  type CreateFlowAnalysisRuleEndpoint = Endpoint[Unit, FlowAnalysisRuleEntity, Unit, FlowAnalysisRuleEntity, Any]
  lazy val createFlowAnalysisRule: CreateFlowAnalysisRuleEndpoint =
    endpoint
      .name("createFlowAnalysisRule")
      .post
      .in(("controller" / "flow-analysis-rules"))
      .in(jsonBody[FlowAnalysisRuleEntity].description("The flow analysis rule configuration details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[FlowAnalysisRuleEntity].description("").and(statusCode(sttp.model.StatusCode(201))))
      .tags(List("Controller"))
  
  type GetFlowAnalysisRuleEndpoint = Endpoint[Unit, String, Unit, FlowAnalysisRuleEntity, Any]
  lazy val getFlowAnalysisRule: GetFlowAnalysisRuleEndpoint =
    endpoint
      .name("getFlowAnalysisRule")
      .get
      .in(("controller" / "flow-analysis-rules" / path[String]("id").description("The flow analysis rule id.")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[FlowAnalysisRuleEntity].description(""))
      .tags(List("Controller"))
  
  type UpdateFlowAnalysisRuleEndpoint = Endpoint[Unit, (String, FlowAnalysisRuleEntity), Unit, FlowAnalysisRuleEntity, Any]
  lazy val updateFlowAnalysisRule: UpdateFlowAnalysisRuleEndpoint =
    endpoint
      .name("updateFlowAnalysisRule")
      .put
      .in(("controller" / "flow-analysis-rules" / path[String]("id").description("The flow analysis rule id.")))
      .in(jsonBody[FlowAnalysisRuleEntity].description("The flow analysis rule configuration details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[FlowAnalysisRuleEntity].description(""))
      .tags(List("Controller"))
  
  type RemoveFlowAnalysisRuleEndpoint = Endpoint[Unit, (String, Option[LongParameterInt], Option[ClientIdParameterStr], Option[Boolean]), Unit, FlowAnalysisRuleEntity, Any]
  lazy val removeFlowAnalysisRule: RemoveFlowAnalysisRuleEndpoint =
    endpoint
      .name("removeFlowAnalysisRule")
      .delete
      .in(("controller" / "flow-analysis-rules" / path[String]("id").description("The flow analysis rule id.")))
      .in(query[Option[LongParameterInt]]("version").description("The revision is used to verify the client is working with the latest version of the flow."))
      .in(query[Option[ClientIdParameterStr]]("clientId").description("If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response."))
      .in(query[Option[Boolean]]("disconnectedNodeAcknowledged").description("Acknowledges that this node is disconnected to allow for mutable requests to proceed."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[FlowAnalysisRuleEntity].description(""))
      .tags(List("Controller"))
  
  type AnalyzeFlowAnalysisRuleConfigurationEndpoint = Endpoint[Unit, (String, ConfigurationAnalysisEntity), Unit, ConfigurationAnalysisEntity, Any]
  lazy val analyzeFlowAnalysisRuleConfiguration: AnalyzeFlowAnalysisRuleConfigurationEndpoint =
    endpoint
      .name("analyzeFlowAnalysisRuleConfiguration")
      .post
      .in(("controller" / "flow-analysis-rules" / path[String]("id").description("The flow analysis rules id.") / "config" / "analysis"))
      .in(jsonBody[ConfigurationAnalysisEntity].description("The configuration analysis request."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ConfigurationAnalysisEntity].description(""))
      .tags(List("Controller"))
  
  type SubmitFlowAnalysisRuleConfigVerificationRequestEndpoint = Endpoint[Unit, (String, VerifyConfigRequestEntity), Unit, VerifyConfigRequestEntity, Any]
  lazy val submitFlowAnalysisRuleConfigVerificationRequest: SubmitFlowAnalysisRuleConfigVerificationRequestEndpoint =
    endpoint
      .name("submitFlowAnalysisRuleConfigVerificationRequest")
      .post
      .in(("controller" / "flow-analysis-rules" / path[String]("id").description("The flow analysis rules id.") / "config" / "verification-requests"))
      .in(jsonBody[VerifyConfigRequestEntity].description("The flow analysis rules configuration verification request."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[VerifyConfigRequestEntity].description(""))
      .tags(List("Controller"))
  
  type GetFlowAnalysisRuleVerificationRequestEndpoint = Endpoint[Unit, (String, String), Unit, VerifyConfigRequestEntity, Any]
  lazy val getFlowAnalysisRuleVerificationRequest: GetFlowAnalysisRuleVerificationRequestEndpoint =
    endpoint
      .name("getFlowAnalysisRuleVerificationRequest")
      .get
      .in(("controller" / "flow-analysis-rules" / path[String]("id").description("The ID of the Flow Analysis Rule") / "config" / "verification-requests" / path[String]("requestId").description("The ID of the Verification Request")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[VerifyConfigRequestEntity].description(""))
      .tags(List("Controller"))
  
  type DeleteFlowAnalysisRuleVerificationRequestEndpoint = Endpoint[Unit, (String, String), Unit, VerifyConfigRequestEntity, Any]
  lazy val deleteFlowAnalysisRuleVerificationRequest: DeleteFlowAnalysisRuleVerificationRequestEndpoint =
    endpoint
      .name("deleteFlowAnalysisRuleVerificationRequest")
      .delete
      .in(("controller" / "flow-analysis-rules" / path[String]("id").description("The ID of the Flow Analysis Rule") / "config" / "verification-requests" / path[String]("requestId").description("The ID of the Verification Request")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[VerifyConfigRequestEntity].description(""))
      .tags(List("Controller"))
  
  type GetFlowAnalysisRulePropertyDescriptorEndpoint = Endpoint[Unit, (String, String, Option[Boolean]), Unit, PropertyDescriptorEntity, Any]
  lazy val getFlowAnalysisRulePropertyDescriptor: GetFlowAnalysisRulePropertyDescriptorEndpoint =
    endpoint
      .name("getFlowAnalysisRulePropertyDescriptor")
      .get
      .in(("controller" / "flow-analysis-rules" / path[String]("id").description("The flow analysis rule id.") / "descriptors"))
      .in(query[String]("propertyName").description("The property name."))
      .in(query[Option[Boolean]]("sensitive").description("Property Descriptor requested sensitive status"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[PropertyDescriptorEntity].description(""))
      .tags(List("Controller"))
  
  type UpdateRunStatusEndpoint = Endpoint[Unit, (String, FlowAnalysisRuleRunStatusEntity), Unit, FlowAnalysisRuleEntity, Any]
  lazy val updateRunStatus: UpdateRunStatusEndpoint =
    endpoint
      .name("updateRunStatus")
      .put
      .in(("controller" / "flow-analysis-rules" / path[String]("id").description("The flow analysis rule id.") / "run-status"))
      .in(jsonBody[FlowAnalysisRuleRunStatusEntity].description("The flow analysis rule run status."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[FlowAnalysisRuleEntity].description(""))
      .tags(List("Controller"))
  
  type GetFlowAnalysisRuleStateEndpoint = Endpoint[Unit, String, Unit, ComponentStateEntity, Any]
  lazy val getFlowAnalysisRuleState: GetFlowAnalysisRuleStateEndpoint =
    endpoint
      .name("getFlowAnalysisRuleState")
      .get
      .in(("controller" / "flow-analysis-rules" / path[String]("id").description("The flow analysis rule id.") / "state"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ComponentStateEntity].description(""))
      .tags(List("Controller"))
  
  type ClearStateEndpoint = Endpoint[Unit, (String, ClearStateBodyIn), Unit, ComponentStateEntity, Any]
  lazy val clearState: ClearStateEndpoint =
    endpoint
      .name("clearState")
      .post
      .in(("controller" / "flow-analysis-rules" / path[String]("id").description("The flow analysis rule id.") / "state" / "clear-requests"))
      .in(oneOfBody[ClearStateBodyIn](
        EndpointIO.Body(RawBodyType.ByteArrayBody, Codec.id[Array[Byte], `*/*CodecFormat`](`*/*CodecFormat`(), Schema.schemaForByteArray), EndpointIO.Info.empty).map(ClearStateBody0In(_))(_.value).widenBody[ClearStateBodyIn].description("Optional component state to perform a selective key removal. If omitted, clears all state."),
        jsonBody[Option[ComponentStateEntity]].map(ClearStateBodyOption_ComponentStateEntity_In(_))(_.value).widenBody[ClearStateBodyIn].description("Optional component state to perform a selective key removal. If omitted, clears all state.")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ComponentStateEntity].description(""))
      .tags(List("Controller"))
  
  type DeleteHistoryEndpoint = Endpoint[Unit, DateTimeParameterDT, Unit, HistoryEntity, Any]
  lazy val deleteHistory: DeleteHistoryEndpoint =
    endpoint
      .name("deleteHistory")
      .delete
      .in(("controller" / "history"))
      .in(query[DateTimeParameterDT]("endDate").description("Purge actions before this date/time."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[HistoryEntity].description(""))
      .tags(List("Controller"))
  
  type GetNarSummariesEndpoint = Endpoint[Unit, Unit, Unit, NarSummariesEntity, Any]
  lazy val getNarSummaries: GetNarSummariesEndpoint =
    endpoint
      .name("getNarSummaries")
      .get
      .in(("controller" / "nar-manager" / "nars"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[NarSummariesEntity].description(""))
      .tags(List("Controller"))
  
  type UploadNarEndpoint = Endpoint[Unit, (Option[String], sttp.capabilities.pekko.PekkoStreams.BinaryStream), Unit, NarSummaryEntity, sttp.capabilities.pekko.PekkoStreams]
  lazy val uploadNar: UploadNarEndpoint =
    endpoint
      .name("uploadNar")
      .post
      .in(("controller" / "nar-manager" / "nars" / "content"))
      .in(header[Option[String]]("Filename"))
      .in(streamBody(sttp.capabilities.pekko.PekkoStreams)(Schema.binary[UploadNarRequest], CodecFormat.OctetStream()).description("The contents of the NAR file."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[NarSummaryEntity].description(""))
      .tags(List("Controller"))
  
  type GetNarSummaryEndpoint = Endpoint[Unit, String, Unit, NarDetailsEntity, Any]
  lazy val getNarSummary: GetNarSummaryEndpoint =
    endpoint
      .name("getNarSummary")
      .get
      .in(("controller" / "nar-manager" / "nars" / path[String]("id").description("The id of the NAR.")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[NarDetailsEntity].description(""))
      .tags(List("Controller"))
  
  type DeleteNarEndpoint = Endpoint[Unit, (String, Option[Boolean], Option[Boolean]), Unit, NarSummaryEntity, Any]
  lazy val deleteNar: DeleteNarEndpoint =
    endpoint
      .name("deleteNar")
      .delete
      .in(("controller" / "nar-manager" / "nars" / path[String]("id").description("The id of the NAR.")))
      .in(query[Option[Boolean]]("disconnectedNodeAcknowledged"))
      .in(query[Option[Boolean]]("force"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[NarSummaryEntity].description(""))
      .tags(List("Controller"))
  
  type DownloadNarEndpoint = Endpoint[Unit, String, Unit, sttp.capabilities.pekko.PekkoStreams.BinaryStream, sttp.capabilities.pekko.PekkoStreams]
  lazy val downloadNar: DownloadNarEndpoint =
    endpoint
      .name("downloadNar")
      .get
      .in(("controller" / "nar-manager" / "nars" / path[String]("id").description("The id of the NAR.") / "content"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(streamBody(sttp.capabilities.pekko.PekkoStreams)(Schema.binary[ByteString], CodecFormat.OctetStream()).description(""))
      .tags(List("Controller"))
  
  type GetNarDetailsEndpoint = Endpoint[Unit, String, Unit, NarDetailsEntity, Any]
  lazy val getNarDetails: GetNarDetailsEndpoint =
    endpoint
      .name("getNarDetails")
      .get
      .in(("controller" / "nar-manager" / "nars" / path[String]("id").description("The id of the NAR.") / "details"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[NarDetailsEntity].description(""))
      .tags(List("Controller"))
  
  type CreateParameterProviderEndpoint = Endpoint[Unit, ParameterProviderEntity, Unit, ParameterProviderEntity, Any]
  lazy val createParameterProvider: CreateParameterProviderEndpoint =
    endpoint
      .name("createParameterProvider")
      .post
      .in(("controller" / "parameter-providers"))
      .in(jsonBody[ParameterProviderEntity].description("The parameter provider configuration details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ParameterProviderEntity].description("").and(statusCode(sttp.model.StatusCode(201))))
      .tags(List("Controller"))
  
  type GetFlowRegistryClientsEndpoint = Endpoint[Unit, Unit, Unit, FlowRegistryClientsEntity, Any]
  lazy val getFlowRegistryClients: GetFlowRegistryClientsEndpoint =
    endpoint
      .name("getFlowRegistryClients")
      .get
      .in(("controller" / "registry-clients"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[FlowRegistryClientsEntity].description(""))
      .tags(List("Controller"))
  
  type CreateFlowRegistryClientEndpoint = Endpoint[Unit, FlowRegistryClientEntity, Unit, FlowRegistryClientEntity, Any]
  lazy val createFlowRegistryClient: CreateFlowRegistryClientEndpoint =
    endpoint
      .name("createFlowRegistryClient")
      .post
      .in(("controller" / "registry-clients"))
      .in(jsonBody[FlowRegistryClientEntity].description("The flow registry client configuration details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[FlowRegistryClientEntity].description("").and(statusCode(sttp.model.StatusCode(201))))
      .tags(List("Controller"))
  
  type GetFlowRegistryClientEndpoint = Endpoint[Unit, String, Unit, FlowRegistryClientEntity, Any]
  lazy val getFlowRegistryClient: GetFlowRegistryClientEndpoint =
    endpoint
      .name("getFlowRegistryClient")
      .get
      .in(("controller" / "registry-clients" / path[String]("id").description("The flow registry client id.")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[FlowRegistryClientEntity].description(""))
      .tags(List("Controller"))
  
  type UpdateFlowRegistryClientEndpoint = Endpoint[Unit, (String, FlowRegistryClientEntity), Unit, FlowRegistryClientEntity, Any]
  lazy val updateFlowRegistryClient: UpdateFlowRegistryClientEndpoint =
    endpoint
      .name("updateFlowRegistryClient")
      .put
      .in(("controller" / "registry-clients" / path[String]("id").description("The flow registry client id.")))
      .in(jsonBody[FlowRegistryClientEntity].description("The flow registry client configuration details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[FlowRegistryClientEntity].description(""))
      .tags(List("Controller"))
  
  type DeleteFlowRegistryClientEndpoint = Endpoint[Unit, (String, Option[LongParameterInt], Option[ClientIdParameterStr], Option[Boolean]), Unit, FlowRegistryClientEntity, Any]
  lazy val deleteFlowRegistryClient: DeleteFlowRegistryClientEndpoint =
    endpoint
      .name("deleteFlowRegistryClient")
      .delete
      .in(("controller" / "registry-clients" / path[String]("id").description("The flow registry client id.")))
      .in(query[Option[LongParameterInt]]("version").description("The revision is used to verify the client is working with the latest version of the flow."))
      .in(query[Option[ClientIdParameterStr]]("clientId").description("If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response."))
      .in(query[Option[Boolean]]("disconnectedNodeAcknowledged").description("Acknowledges that this node is disconnected to allow for mutable requests to proceed."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[FlowRegistryClientEntity].description(""))
      .tags(List("Controller"))
  
  type GetPropertyDescriptorEndpoint = Endpoint[Unit, (String, String, Option[Boolean]), Unit, PropertyDescriptorEntity, Any]
  lazy val getPropertyDescriptor: GetPropertyDescriptorEndpoint =
    endpoint
      .name("getPropertyDescriptor")
      .get
      .in(("controller" / "registry-clients" / path[String]("id").description("The flow registry client id.") / "descriptors"))
      .in(query[String]("propertyName").description("The property name."))
      .in(query[Option[Boolean]]("sensitive").description("Property Descriptor requested sensitive status"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[PropertyDescriptorEntity].description(""))
      .tags(List("Controller"))
  
  type GetRegistryClientTypesEndpoint = Endpoint[Unit, Unit, Unit, FlowRegistryClientTypesEntity, Any]
  lazy val getRegistryClientTypes: GetRegistryClientTypesEndpoint =
    endpoint
      .name("getRegistryClientTypes")
      .get
      .in(("controller" / "registry-types"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[FlowRegistryClientTypesEntity].description(""))
      .tags(List("Controller"))
  
  type CreateReportingTaskEndpoint = Endpoint[Unit, ReportingTaskEntity, Unit, ReportingTaskEntity, Any]
  lazy val createReportingTask: CreateReportingTaskEndpoint =
    endpoint
      .name("createReportingTask")
      .post
      .in(("controller" / "reporting-tasks"))
      .in(jsonBody[ReportingTaskEntity].description("The reporting task configuration details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ReportingTaskEntity].description("").and(statusCode(sttp.model.StatusCode(201))))
      .tags(List("Controller"))
  
  type ImportReportingTaskSnapshotEndpoint = Endpoint[Unit, VersionedReportingTaskImportRequestEntity, Unit, VersionedReportingTaskImportResponseEntity, Any]
  lazy val importReportingTaskSnapshot: ImportReportingTaskSnapshotEndpoint =
    endpoint
      .name("importReportingTaskSnapshot")
      .post
      .in(("controller" / "reporting-tasks" / "import"))
      .in(jsonBody[VersionedReportingTaskImportRequestEntity].description("The import request containing the reporting task snapshot to import."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[VersionedReportingTaskImportResponseEntity].description(""))
      .tags(List("Controller"))
  
  type GetNodeStatusHistoryEndpoint = Endpoint[Unit, Unit, Unit, ComponentHistoryEntity, Any]
  lazy val getNodeStatusHistory: GetNodeStatusHistoryEndpoint =
    endpoint
      .name("getNodeStatusHistory")
      .get
      .in(("controller" / "status" / "history"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ComponentHistoryEntity].description(""))
      .tags(List("Controller"))
  
  type GetCountersEndpoint = Endpoint[Unit, (Option[Boolean], Option[String]), Unit, CountersEntity, Any]
  lazy val getCounters: GetCountersEndpoint =
    endpoint
      .name("getCounters")
      .get
      .in(("counters"))
      .in(query[Option[Boolean]]("nodewise").description("Whether or not to include the breakdown per node. Optional, defaults to false"))
      .in(query[Option[String]]("clusterNodeId").description("The id of the node where to get the status."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[CountersEntity].description(""))
      .tags(List("Counters"))
  
  type UpdateAllCountersEndpoint = Endpoint[Unit, Unit, Unit, CountersEntity, Any]
  lazy val updateAllCounters: UpdateAllCountersEndpoint =
    endpoint
      .name("updateAllCounters")
      .put
      .in(("counters"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[CountersEntity].description(""))
      .tags(List("Counters"))
  
  type UpdateCounterEndpoint = Endpoint[Unit, String, Unit, CounterEntity, Any]
  lazy val updateCounter: UpdateCounterEndpoint =
    endpoint
      .name("updateCounter")
      .put
      .in(("counters" / path[String]("id").description("The id of the counter.")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[CounterEntity].description(""))
      .tags(List("Counters"))
  
  type ExtendInputPortTransactionTTLEndpoint = Endpoint[Unit, (String, String, sttp.capabilities.pekko.PekkoStreams.BinaryStream), Unit, TransactionResultEntity, sttp.capabilities.pekko.PekkoStreams]
  lazy val extendInputPortTransactionTTL: ExtendInputPortTransactionTTLEndpoint =
    endpoint
      .name("extendInputPortTransactionTTL")
      .put
      .in(("data-transfer" / "input-ports" / path[String]("portId") / "transactions" / path[String]("transactionId")))
      .in(streamBody(sttp.capabilities.pekko.PekkoStreams)(Schema.binary[ExtendInputPortTransactionTTLRequest], `*/*CodecFormat`()))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[TransactionResultEntity].description(""))
      .tags(List("DataTransfer"))
  
  type CommitInputPortTransactionEndpoint = Endpoint[Unit, (String, String, Int, sttp.capabilities.pekko.PekkoStreams.BinaryStream), Unit, TransactionResultEntity, sttp.capabilities.pekko.PekkoStreams]
  lazy val commitInputPortTransaction: CommitInputPortTransactionEndpoint =
    endpoint
      .name("commitInputPortTransaction")
      .delete
      .in(("data-transfer" / "input-ports" / path[String]("portId").description("The input port id.") / "transactions" / path[String]("transactionId").description("The transaction id.")))
      .in(query[Int]("responseCode").description("The response code. Available values are BAD_CHECKSUM(19), CONFIRM_TRANSACTION(12) or CANCEL_TRANSACTION(15)."))
      .in(streamBody(sttp.capabilities.pekko.PekkoStreams)(Schema.binary[CommitInputPortTransactionRequest], CodecFormat.OctetStream()))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(503), emptyOutput.description("NiFi instance is not ready for serving request, or temporarily overloaded. Retrying the same request later may be successful"))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[TransactionResultEntity].description(""))
      .tags(List("DataTransfer"))
  
  type ReceiveFlowFilesEndpoint = Endpoint[Unit, (String, String, sttp.capabilities.pekko.PekkoStreams.BinaryStream), Unit, String, sttp.capabilities.pekko.PekkoStreams]
  lazy val receiveFlowFiles: ReceiveFlowFilesEndpoint =
    endpoint
      .name("receiveFlowFiles")
      .post
      .in(("data-transfer" / "input-ports" / path[String]("portId").description("The input port id.") / "transactions" / path[String]("transactionId") / "flow-files"))
      .in(streamBody(sttp.capabilities.pekko.PekkoStreams)(Schema.binary[ReceiveFlowFilesRequest], CodecFormat.OctetStream()))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(503), emptyOutput.description("NiFi instance is not ready for serving request, or temporarily overloaded. Retrying the same request later may be successful"))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(stringBody.description("").and(statusCode(sttp.model.StatusCode(202))))
      .tags(List("DataTransfer"))
  
  type ExtendOutputPortTransactionTTLEndpoint = Endpoint[Unit, (String, String, sttp.capabilities.pekko.PekkoStreams.BinaryStream), Unit, TransactionResultEntity, sttp.capabilities.pekko.PekkoStreams]
  lazy val extendOutputPortTransactionTTL: ExtendOutputPortTransactionTTLEndpoint =
    endpoint
      .name("extendOutputPortTransactionTTL")
      .put
      .in(("data-transfer" / "output-ports" / path[String]("portId") / "transactions" / path[String]("transactionId")))
      .in(streamBody(sttp.capabilities.pekko.PekkoStreams)(Schema.binary[ExtendOutputPortTransactionTTLRequest], `*/*CodecFormat`()))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(503), emptyOutput.description("NiFi instance is not ready for serving request, or temporarily overloaded. Retrying the same request later may be successful"))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[TransactionResultEntity].description(""))
      .tags(List("DataTransfer"))
  
  type CommitOutputPortTransactionEndpoint = Endpoint[Unit, (String, String, Int, String, sttp.capabilities.pekko.PekkoStreams.BinaryStream), Unit, TransactionResultEntity, sttp.capabilities.pekko.PekkoStreams]
  lazy val commitOutputPortTransaction: CommitOutputPortTransactionEndpoint =
    endpoint
      .name("commitOutputPortTransaction")
      .delete
      .in(("data-transfer" / "output-ports" / path[String]("portId").description("The output port id.") / "transactions" / path[String]("transactionId").description("The transaction id.")))
      .in(query[Int]("responseCode").description("The response code. Available values are CONFIRM_TRANSACTION(12) or CANCEL_TRANSACTION(15)."))
      .in(query[String]("checksum").description("A checksum calculated at client side using CRC32 to check flow file content integrity. It must match with the value calculated at server side."))
      .in(streamBody(sttp.capabilities.pekko.PekkoStreams)(Schema.binary[CommitOutputPortTransactionRequest], CodecFormat.OctetStream()))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(503), emptyOutput.description("NiFi instance is not ready for serving request, or temporarily overloaded. Retrying the same request later may be successful"))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[TransactionResultEntity].description(""))
      .tags(List("DataTransfer"))
  
  type TransferFlowFilesEndpoint = Endpoint[Unit, (String, String, sttp.capabilities.pekko.PekkoStreams.BinaryStream), Unit, Option[sttp.capabilities.pekko.PekkoStreams.BinaryStream], sttp.capabilities.pekko.PekkoStreams]
  lazy val transferFlowFiles: TransferFlowFilesEndpoint =
    endpoint
      .name("transferFlowFiles")
      .get
      .in(("data-transfer" / "output-ports" / path[String]("portId").description("The output port id.") / "transactions" / path[String]("transactionId") / "flow-files"))
      .in(streamBody(sttp.capabilities.pekko.PekkoStreams)(Schema.binary[TransferFlowFilesRequest], `*/*CodecFormat`()))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(503), emptyOutput.description("NiFi instance is not ready for serving request, or temporarily overloaded. Retrying the same request later may be successful"))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(oneOf[Option[sttp.capabilities.pekko.PekkoStreams.BinaryStream]](
        oneOfVariantValueMatcher(sttp.model.StatusCode(202), streamBody(sttp.capabilities.pekko.PekkoStreams)(Schema.binary[StreamingOutput], CodecFormat.OctetStream()).description("").toEndpointIO.map(Some(_))(_.orNull)){ case Some(_: sttp.capabilities.pekko.PekkoStreams.BinaryStream) => true },
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(200), emptyOutput.description("There is no flow file to return."))(None)))
      .tags(List("DataTransfer"))
  
  type CreatePortTransactionEndpoint = Endpoint[Unit, (String, String, sttp.capabilities.pekko.PekkoStreams.BinaryStream), Unit, TransactionResultEntity, sttp.capabilities.pekko.PekkoStreams]
  lazy val createPortTransaction: CreatePortTransactionEndpoint =
    endpoint
      .name("createPortTransaction")
      .post
      .in(("data-transfer" / path[String]("portType").description("The port type.") / path[String]("portId") / "transactions"))
      .in(streamBody(sttp.capabilities.pekko.PekkoStreams)(Schema.binary[CreatePortTransactionRequest], `*/*CodecFormat`()))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(503), emptyOutput.description("NiFi instance is not ready for serving request, or temporarily overloaded. Retrying the same request later may be successful"))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[TransactionResultEntity].description("").and(statusCode(sttp.model.StatusCode(201))))
      .tags(List("DataTransfer"))
  
  type GetAboutInfoEndpoint = Endpoint[Unit, Unit, Unit, AboutEntity, Any]
  lazy val getAboutInfo: GetAboutInfoEndpoint =
    endpoint
      .name("getAboutInfo")
      .get
      .in(("flow" / "about"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[AboutEntity].description(""))
      .tags(List("Flow"))
  
  type GetAdditionalDetailsEndpoint = Endpoint[Unit, (String, String, String, String), Unit, AdditionalDetailsEntity, Any]
  lazy val getAdditionalDetails: GetAdditionalDetailsEndpoint =
    endpoint
      .name("getAdditionalDetails")
      .get
      .in(("flow" / "additional-details" / path[String]("group").description("The bundle group") / path[String]("artifact").description("The bundle artifact") / path[String]("version").description("The bundle version") / path[String]("type").description("The processor type")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The additional details for the coordinates could not be located."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[AdditionalDetailsEntity].description(""))
      .tags(List("Flow"))
  
  type GetBannersEndpoint = Endpoint[Unit, Unit, Unit, BannerEntity, Any]
  lazy val getBanners: GetBannersEndpoint =
    endpoint
      .name("getBanners")
      .get
      .in(("flow" / "banners"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[BannerEntity].description(""))
      .tags(List("Flow"))
  
  type GetBulletinBoardEndpoint = Endpoint[Unit, (Option[LongParameterInt], Option[BulletinBoardPatternParameterStr], Option[BulletinBoardPatternParameterStr], Option[BulletinBoardPatternParameterStr], Option[BulletinBoardPatternParameterStr], Option[IntegerParameterInt]), Unit, BulletinBoardEntity, Any]
  lazy val getBulletinBoard: GetBulletinBoardEndpoint =
    endpoint
      .name("getBulletinBoard")
      .get
      .in(("flow" / "bulletin-board"))
      .in(query[Option[LongParameterInt]]("after").description("Includes bulletins with an id after this value."))
      .in(query[Option[BulletinBoardPatternParameterStr]]("sourceName").description("Includes bulletins originating from this sources whose name match this regular expression."))
      .in(query[Option[BulletinBoardPatternParameterStr]]("message").description("Includes bulletins whose message that match this regular expression."))
      .in(query[Option[BulletinBoardPatternParameterStr]]("sourceId").description("Includes bulletins originating from this sources whose id match this regular expression."))
      .in(query[Option[BulletinBoardPatternParameterStr]]("groupId").description("Includes bulletins originating from this sources whose group id match this regular expression."))
      .in(query[Option[IntegerParameterInt]]("limit").description("The number of bulletins to limit the response to."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[BulletinBoardEntity].description(""))
      .tags(List("Flow"))
  
  type GenerateClientIdEndpoint = Endpoint[Unit, Unit, Unit, String, Any]
  lazy val generateClientId: GenerateClientIdEndpoint =
    endpoint
      .name("generateClientId")
      .get
      .in(("flow" / "client-id"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(stringBody.description(""))
      .tags(List("Flow"))
  
  type SearchClusterEndpoint = Endpoint[Unit, String, Unit, ClusterSearchResultsEntity, Any]
  lazy val searchCluster: SearchClusterEndpoint =
    endpoint
      .name("searchCluster")
      .get
      .in(("flow" / "cluster" / "search-results"))
      .in(query[String]("q").description("Node address to search for."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ClusterSearchResultsEntity].description(""))
      .tags(List("Flow"))
  
  type GetClusterSummaryEndpoint = Endpoint[Unit, Unit, Unit, ClusterSummaryEntity, Any]
  lazy val getClusterSummary: GetClusterSummaryEndpoint =
    endpoint
      .name("getClusterSummary")
      .get
      .in(("flow" / "cluster" / "summary"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ClusterSummaryEntity].description(""))
      .tags(List("Flow"))
  
  type GetFlowConfigEndpoint = Endpoint[Unit, Unit, Unit, FlowConfigurationEntity, Any]
  lazy val getFlowConfig: GetFlowConfigEndpoint =
    endpoint
      .name("getFlowConfig")
      .get
      .in(("flow" / "config"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[FlowConfigurationEntity].description(""))
      .tags(List("Flow"))
  
  type GetConnectionStatisticsEndpoint = Endpoint[Unit, (String, Option[Boolean], Option[String]), Unit, ConnectionStatisticsEntity, Any]
  lazy val getConnectionStatistics: GetConnectionStatisticsEndpoint =
    endpoint
      .name("getConnectionStatistics")
      .get
      .in(("flow" / "connections" / path[String]("id").description("The connection id.") / "statistics"))
      .in(query[Option[Boolean]]("nodewise").description("Whether or not to include the breakdown per node. Optional, defaults to false"))
      .in(query[Option[String]]("clusterNodeId").description("The id of the node where to get the statistics."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ConnectionStatisticsEntity].description(""))
      .tags(List("Flow"))
  
  type GetConnectionStatusEndpoint = Endpoint[Unit, (String, Option[Boolean], Option[String]), Unit, ConnectionStatusEntity, Any]
  lazy val getConnectionStatus: GetConnectionStatusEndpoint =
    endpoint
      .name("getConnectionStatus")
      .get
      .in(("flow" / "connections" / path[String]("id").description("The connection id.") / "status"))
      .in(query[Option[Boolean]]("nodewise").description("Whether or not to include the breakdown per node. Optional, defaults to false"))
      .in(query[Option[String]]("clusterNodeId").description("The id of the node where to get the status."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ConnectionStatusEntity].description(""))
      .tags(List("Flow"))
  
  type GetConnectionStatusHistoryEndpoint = Endpoint[Unit, String, Unit, StatusHistoryEntity, Any]
  lazy val getConnectionStatusHistory: GetConnectionStatusHistoryEndpoint =
    endpoint
      .name("getConnectionStatusHistory")
      .get
      .in(("flow" / "connections" / path[String]("id").description("The connection id.") / "status" / "history"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[StatusHistoryEntity].description(""))
      .tags(List("Flow"))
  
  type GetContentViewersEndpoint = Endpoint[Unit, Unit, Unit, ContentViewerEntity, Any]
  lazy val getContentViewers: GetContentViewersEndpoint =
    endpoint
      .name("getContentViewers")
      .get
      .in(("flow" / "content-viewers"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ContentViewerEntity].description(""))
      .tags(List("Flow"))
  
  type GetControllerServiceDefinitionEndpoint = Endpoint[Unit, (String, String, String, String), Unit, ControllerServiceDefinition, Any]
  lazy val getControllerServiceDefinition: GetControllerServiceDefinitionEndpoint =
    endpoint
      .name("getControllerServiceDefinition")
      .get
      .in(("flow" / "controller-service-definition" / path[String]("group").description("The bundle group") / path[String]("artifact").description("The bundle artifact") / path[String]("version").description("The bundle version") / path[String]("type").description("The controller service type")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The controller service definition for the coordinates could not be located."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ControllerServiceDefinition].description(""))
      .tags(List("Flow"))
  
  type GetControllerServiceTypesEndpoint = Endpoint[Unit, (Option[String], Option[String], Option[String], Option[String], Option[String], Option[String], Option[String]), Unit, ControllerServiceTypesEntity, Any]
  lazy val getControllerServiceTypes: GetControllerServiceTypesEndpoint =
    endpoint
      .name("getControllerServiceTypes")
      .get
      .in(("flow" / "controller-service-types"))
      .in(query[Option[String]]("serviceType").description("If specified, will only return controller services that are compatible with this type of service."))
      .in(query[Option[String]]("serviceBundleGroup").description("If serviceType specified, is the bundle group of the serviceType."))
      .in(query[Option[String]]("serviceBundleArtifact").description("If serviceType specified, is the bundle artifact of the serviceType."))
      .in(query[Option[String]]("serviceBundleVersion").description("If serviceType specified, is the bundle version of the serviceType."))
      .in(query[Option[String]]("bundleGroupFilter").description("If specified, will only return types that are a member of this bundle group."))
      .in(query[Option[String]]("bundleArtifactFilter").description("If specified, will only return types that are a member of this bundle artifact."))
      .in(query[Option[String]]("typeFilter").description("If specified, will only return types whose fully qualified classname matches."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ControllerServiceTypesEntity].description(""))
      .tags(List("Flow"))
  
  type GetBulletinsEndpoint = Endpoint[Unit, Unit, Unit, ControllerBulletinsEntity, Any]
  lazy val getBulletins: GetBulletinsEndpoint =
    endpoint
      .name("getBulletins")
      .get
      .in(("flow" / "controller" / "bulletins"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ControllerBulletinsEntity].description(""))
      .tags(List("Flow"))
  
  type GetControllerServicesFromControllerEndpoint = Endpoint[Unit, (Option[Boolean], Option[Boolean]), Unit, ControllerServicesEntity, Any]
  lazy val getControllerServicesFromController: GetControllerServicesFromControllerEndpoint =
    endpoint
      .name("getControllerServicesFromController")
      .get
      .in(("flow" / "controller" / "controller-services"))
      .in(query[Option[Boolean]]("uiOnly"))
      .in(query[Option[Boolean]]("includeReferencingComponents").description("Whether or not to include services' referencing components in the response"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ControllerServicesEntity].description(""))
      .tags(List("Flow"))
  
  type GetCurrentUserEndpoint = Endpoint[Unit, Unit, CurrentUserEntity, Unit, Any]
  lazy val getCurrentUser: GetCurrentUserEndpoint =
    endpoint
      .name("getCurrentUser")
      .get
      .in(("flow" / "current-user"))
      .errorOut(jsonBody[CurrentUserEntity].description(""))
      .tags(List("Flow"))
  
  type GetFlowAnalysisRuleDefinitionEndpoint = Endpoint[Unit, (String, String, String, String), Unit, FlowAnalysisRuleDefinition, Any]
  lazy val getFlowAnalysisRuleDefinition: GetFlowAnalysisRuleDefinitionEndpoint =
    endpoint
      .name("getFlowAnalysisRuleDefinition")
      .get
      .in(("flow" / "flow-analysis-rule-definition" / path[String]("group").description("The bundle group") / path[String]("artifact").description("The bundle artifact") / path[String]("version").description("The bundle version") / path[String]("type").description("The flow analysis rule type")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The flow analysis rule definition for the coordinates could not be located."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[FlowAnalysisRuleDefinition].description(""))
      .tags(List("Flow"))
  
  type GetFlowAnalysisRuleTypesEndpoint = Endpoint[Unit, (Option[String], Option[String], Option[String]), Unit, FlowAnalysisRuleTypesEntity, Any]
  lazy val getFlowAnalysisRuleTypes: GetFlowAnalysisRuleTypesEndpoint =
    endpoint
      .name("getFlowAnalysisRuleTypes")
      .get
      .in(("flow" / "flow-analysis-rule-types"))
      .in(query[Option[String]]("bundleGroupFilter").description("If specified, will only return types that are a member of this bundle group."))
      .in(query[Option[String]]("bundleArtifactFilter").description("If specified, will only return types that are a member of this bundle artifact."))
      .in(query[Option[String]]("type").description("If specified, will only return types whose fully qualified classname matches."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[FlowAnalysisRuleTypesEntity].description(""))
      .tags(List("Flow"))
  
  type GetAllFlowAnalysisResultsEndpoint = Endpoint[Unit, Unit, Unit, FlowAnalysisResultEntity, Any]
  lazy val getAllFlowAnalysisResults: GetAllFlowAnalysisResultsEndpoint =
    endpoint
      .name("getAllFlowAnalysisResults")
      .get
      .in(("flow" / "flow-analysis" / "results"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[FlowAnalysisResultEntity].description(""))
      .tags(List("Flow"))
  
  type GetFlowAnalysisResultsEndpoint = Endpoint[Unit, String, Unit, FlowAnalysisResultEntity, Any]
  lazy val getFlowAnalysisResults: GetFlowAnalysisResultsEndpoint =
    endpoint
      .name("getFlowAnalysisResults")
      .get
      .in(("flow" / "flow-analysis" / "results" / path[String]("processGroupId").description("The id of the process group representing (a part of) the flow to be analyzed.")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[FlowAnalysisResultEntity].description(""))
      .tags(List("Flow"))
  
  type QueryHistoryEndpoint = Endpoint[Unit, (IntegerParameterInt, IntegerParameterInt, Option[String], Option[String], Option[DateTimeParameterDT], Option[DateTimeParameterDT], Option[String], Option[String]), Unit, HistoryEntity, Any]
  lazy val queryHistory: QueryHistoryEndpoint =
    endpoint
      .name("queryHistory")
      .get
      .in(("flow" / "history"))
      .in(query[IntegerParameterInt]("offset").description("The offset into the result set."))
      .in(query[IntegerParameterInt]("count").description("The number of actions to return."))
      .in(query[Option[String]]("sortColumn").description("The field to sort on."))
      .in(query[Option[String]]("sortOrder").description("The direction to sort."))
      .in(query[Option[DateTimeParameterDT]]("startDate").description("Include actions after this date."))
      .in(query[Option[DateTimeParameterDT]]("endDate").description("Include actions before this date."))
      .in(query[Option[String]]("userIdentity").description("Include actions performed by this user."))
      .in(query[Option[String]]("sourceId").description("Include actions on this component."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[HistoryEntity].description(""))
      .tags(List("Flow"))
  
  type GetComponentHistoryEndpoint = Endpoint[Unit, String, Unit, ComponentHistoryEntity, Any]
  lazy val getComponentHistory: GetComponentHistoryEndpoint =
    endpoint
      .name("getComponentHistory")
      .get
      .in(("flow" / "history" / "components" / path[String]("componentId").description("The component id.")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ComponentHistoryEntity].description(""))
      .tags(List("Flow"))
  
  type GetActionEndpoint = Endpoint[Unit, IntegerParameterInt, Unit, ActionEntity, Any]
  lazy val getAction: GetActionEndpoint =
    endpoint
      .name("getAction")
      .get
      .in(("flow" / "history" / path[IntegerParameterInt]("id").description("The action id.")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ActionEntity].description(""))
      .tags(List("Flow"))
  
  type GetInputPortStatusEndpoint = Endpoint[Unit, (String, Option[Boolean], Option[String]), Unit, PortStatusEntity, Any]
  lazy val getInputPortStatus: GetInputPortStatusEndpoint =
    endpoint
      .name("getInputPortStatus")
      .get
      .in(("flow" / "input-ports" / path[String]("id").description("The input port id.") / "status"))
      .in(query[Option[Boolean]]("nodewise").description("Whether or not to include the breakdown per node. Optional, defaults to false"))
      .in(query[Option[String]]("clusterNodeId").description("The id of the node where to get the status."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[PortStatusEntity].description(""))
      .tags(List("Flow"))
  
  type GetFlowMetricsEndpoint = Endpoint[Unit, (String, Option[GetFlowMetricsIncludedRegistries], Option[String], Option[String], Option[String]), Unit, sttp.capabilities.pekko.PekkoStreams.BinaryStream, sttp.capabilities.pekko.PekkoStreams]
  lazy val getFlowMetrics: GetFlowMetricsEndpoint =
    endpoint
      .name("getFlowMetrics")
      .get
      .in(("flow" / "metrics" / path[String]("producer").description("The producer for flow file metrics. Each producer may have its own output format.")))
      .in(query[Option[GetFlowMetricsIncludedRegistries]]("includedRegistries").description("Set of included metrics registries. Duplicate the parameter to include multiple registries. All registries are included by default."))
      .in(query[Option[String]]("sampleName").description("Regular Expression Pattern to be applied against the sample name field"))
      .in(query[Option[String]]("sampleLabelValue").description("Regular Expression Pattern to be applied against the sample label value field"))
      .in(query[Option[String]]("rootFieldName").description("Name of the first field of JSON object. Applicable for JSON producer only."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(streamBody(sttp.capabilities.pekko.PekkoStreams)(Schema.binary[StreamingOutput], `*/*CodecFormat`()).description(""))
      .tags(List("Flow"))
  
  sealed trait GetFlowMetricsIncludedRegistries extends enumeratum.EnumEntry
  object GetFlowMetricsIncludedRegistries extends enumeratum.Enum[GetFlowMetricsIncludedRegistries] with enumeratum.CirceEnum[GetFlowMetricsIncludedRegistries] {
    val values = findValues
    case object NIFI extends GetFlowMetricsIncludedRegistries
    case object JVM extends GetFlowMetricsIncludedRegistries
    case object BULLETIN extends GetFlowMetricsIncludedRegistries
    case object CONNECTION extends GetFlowMetricsIncludedRegistries
    case object CLUSTER extends GetFlowMetricsIncludedRegistries
    implicit val enumCodecSupportGetFlowMetricsIncludedRegistries: ExtraParamSupport[GetFlowMetricsIncludedRegistries] =
      extraCodecSupport[GetFlowMetricsIncludedRegistries]("GetFlowMetricsIncludedRegistries", GetFlowMetricsIncludedRegistries)
  }
  
  type GetOutputPortStatusEndpoint = Endpoint[Unit, (String, Option[Boolean], Option[String]), Unit, PortStatusEntity, Any]
  lazy val getOutputPortStatus: GetOutputPortStatusEndpoint =
    endpoint
      .name("getOutputPortStatus")
      .get
      .in(("flow" / "output-ports" / path[String]("id").description("The output port id.") / "status"))
      .in(query[Option[Boolean]]("nodewise").description("Whether or not to include the breakdown per node. Optional, defaults to false"))
      .in(query[Option[String]]("clusterNodeId").description("The id of the node where to get the status."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[PortStatusEntity].description(""))
      .tags(List("Flow"))
  
  type GetParameterContextsEndpoint = Endpoint[Unit, Unit, Unit, ParameterContextsEntity, Any]
  lazy val getParameterContexts: GetParameterContextsEndpoint =
    endpoint
      .name("getParameterContexts")
      .get
      .in(("flow" / "parameter-contexts"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ParameterContextsEntity].description(""))
      .tags(List("Flow"))
  
  type GetParameterProviderDefinitionEndpoint = Endpoint[Unit, (String, String, String, String), Unit, ParameterProviderDefinition, Any]
  lazy val getParameterProviderDefinition: GetParameterProviderDefinitionEndpoint =
    endpoint
      .name("getParameterProviderDefinition")
      .get
      .in(("flow" / "parameter-provider-definition" / path[String]("group").description("The bundle group") / path[String]("artifact").description("The bundle artifact") / path[String]("version").description("The bundle version") / path[String]("type").description("The parameter provider type")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The reporting task definition for the coordinates could not be located."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ParameterProviderDefinition].description(""))
      .tags(List("Flow"))
  
  type GetParameterProviderTypesEndpoint = Endpoint[Unit, (Option[String], Option[String], Option[String]), Unit, ParameterProviderTypesEntity, Any]
  lazy val getParameterProviderTypes: GetParameterProviderTypesEndpoint =
    endpoint
      .name("getParameterProviderTypes")
      .get
      .in(("flow" / "parameter-provider-types"))
      .in(query[Option[String]]("bundleGroupFilter").description("If specified, will only return types that are a member of this bundle group."))
      .in(query[Option[String]]("bundleArtifactFilter").description("If specified, will only return types that are a member of this bundle artifact."))
      .in(query[Option[String]]("type").description("If specified, will only return types whose fully qualified classname matches."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ParameterProviderTypesEntity].description(""))
      .tags(List("Flow"))
  
  type GetParameterProvidersEndpoint = Endpoint[Unit, Unit, Unit, ParameterProvidersEntity, Any]
  lazy val getParameterProviders: GetParameterProvidersEndpoint =
    endpoint
      .name("getParameterProviders")
      .get
      .in(("flow" / "parameter-providers"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ParameterProvidersEntity].description(""))
      .tags(List("Flow"))
  
  type GetPrioritizersEndpoint = Endpoint[Unit, Unit, Unit, PrioritizerTypesEntity, Any]
  lazy val getPrioritizers: GetPrioritizersEndpoint =
    endpoint
      .name("getPrioritizers")
      .get
      .in(("flow" / "prioritizers"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[PrioritizerTypesEntity].description(""))
      .tags(List("Flow"))
  
  type GetFlowEndpoint = Endpoint[Unit, (String, Option[Boolean]), Unit, ProcessGroupFlowEntity, Any]
  lazy val getFlow: GetFlowEndpoint =
    endpoint
      .name("getFlow")
      .get
      .in(("flow" / "process-groups" / path[String]("id").description("The process group id.")))
      .in(query[Option[Boolean]]("uiOnly"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ProcessGroupFlowEntity].description(""))
      .tags(List("Flow"))
  
  type ScheduleComponentsEndpoint = Endpoint[Unit, (String, ScheduleComponentsEntity), Unit, ScheduleComponentsEntity, Any]
  lazy val scheduleComponents: ScheduleComponentsEndpoint =
    endpoint
      .name("scheduleComponents")
      .put
      .in(("flow" / "process-groups" / path[String]("id").description("The process group id.")))
      .in(jsonBody[ScheduleComponentsEntity].description("The request to schedule or unschedule. If the components in the request are not specified, all authorized components will be considered."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ScheduleComponentsEntity].description(""))
      .tags(List("Flow"))
  
  type GetBreadcrumbsEndpoint = Endpoint[Unit, String, Unit, FlowBreadcrumbEntity, Any]
  lazy val getBreadcrumbs: GetBreadcrumbsEndpoint =
    endpoint
      .name("getBreadcrumbs")
      .get
      .in(("flow" / "process-groups" / path[String]("id").description("The process group id.") / "breadcrumbs"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[FlowBreadcrumbEntity].description(""))
      .tags(List("Flow"))
  
  type GetControllerServicesFromGroupEndpoint = Endpoint[Unit, (String, Option[Boolean], Option[Boolean], Option[Boolean], Option[Boolean]), Unit, ControllerServicesEntity, Any]
  lazy val getControllerServicesFromGroup: GetControllerServicesFromGroupEndpoint =
    endpoint
      .name("getControllerServicesFromGroup")
      .get
      .in(("flow" / "process-groups" / path[String]("id").description("The process group id.") / "controller-services"))
      .in(query[Option[Boolean]]("includeAncestorGroups").description("Whether or not to include parent/ancestor process groups"))
      .in(query[Option[Boolean]]("includeDescendantGroups").description("Whether or not to include descendant process groups"))
      .in(query[Option[Boolean]]("includeReferencingComponents").description("Whether or not to include services' referencing components in the response"))
      .in(query[Option[Boolean]]("uiOnly"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ControllerServicesEntity].description(""))
      .tags(List("Flow"))
  
  type ActivateControllerServicesEndpoint = Endpoint[Unit, (String, ActivateControllerServicesEntity), Unit, ActivateControllerServicesEntity, Any]
  lazy val activateControllerServices: ActivateControllerServicesEndpoint =
    endpoint
      .name("activateControllerServices")
      .put
      .in(("flow" / "process-groups" / path[String]("id").description("The process group id.") / "controller-services"))
      .in(jsonBody[ActivateControllerServicesEntity].description("The request to schedule or unschedule. If the comopnents in the request are not specified, all authorized components will be considered."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ActivateControllerServicesEntity].description(""))
      .tags(List("Flow"))
  
  type GetProcessGroupStatusEndpoint = Endpoint[Unit, (String, Option[Boolean], Option[Boolean], Option[String]), Unit, ProcessGroupStatusEntity, Any]
  lazy val getProcessGroupStatus: GetProcessGroupStatusEndpoint =
    endpoint
      .name("getProcessGroupStatus")
      .get
      .in(("flow" / "process-groups" / path[String]("id").description("The process group id.") / "status"))
      .in(query[Option[Boolean]]("recursive").description("Whether all descendant groups and the status of their content will be included. Optional, defaults to false"))
      .in(query[Option[Boolean]]("nodewise").description("Whether or not to include the breakdown per node. Optional, defaults to false"))
      .in(query[Option[String]]("clusterNodeId").description("The id of the node where to get the status."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ProcessGroupStatusEntity].description(""))
      .tags(List("Flow"))
  
  type GetProcessGroupStatusHistoryEndpoint = Endpoint[Unit, String, Unit, StatusHistoryEntity, Any]
  lazy val getProcessGroupStatusHistory: GetProcessGroupStatusHistoryEndpoint =
    endpoint
      .name("getProcessGroupStatusHistory")
      .get
      .in(("flow" / "process-groups" / path[String]("id").description("The process group id.") / "status" / "history"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[StatusHistoryEntity].description(""))
      .tags(List("Flow"))
  
  type GetProcessorDefinitionEndpoint = Endpoint[Unit, (String, String, String, String), Unit, ProcessorDefinition, Any]
  lazy val getProcessorDefinition: GetProcessorDefinitionEndpoint =
    endpoint
      .name("getProcessorDefinition")
      .get
      .in(("flow" / "processor-definition" / path[String]("group").description("The bundle group") / path[String]("artifact").description("The bundle artifact") / path[String]("version").description("The bundle version") / path[String]("type").description("The processor type")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The processor definition for the coordinates could not be located."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ProcessorDefinition].description(""))
      .tags(List("Flow"))
  
  type GetProcessorTypesEndpoint = Endpoint[Unit, (Option[String], Option[String], Option[String]), Unit, ProcessorTypesEntity, Any]
  lazy val getProcessorTypes: GetProcessorTypesEndpoint =
    endpoint
      .name("getProcessorTypes")
      .get
      .in(("flow" / "processor-types"))
      .in(query[Option[String]]("bundleGroupFilter").description("If specified, will only return types that are a member of this bundle group."))
      .in(query[Option[String]]("bundleArtifactFilter").description("If specified, will only return types that are a member of this bundle artifact."))
      .in(query[Option[String]]("type").description("If specified, will only return types whose fully qualified classname matches."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ProcessorTypesEntity].description(""))
      .tags(List("Flow"))
  
  type GetProcessorStatusEndpoint = Endpoint[Unit, (String, Option[Boolean], Option[String]), Unit, ProcessorStatusEntity, Any]
  lazy val getProcessorStatus: GetProcessorStatusEndpoint =
    endpoint
      .name("getProcessorStatus")
      .get
      .in(("flow" / "processors" / path[String]("id").description("The processor id.") / "status"))
      .in(query[Option[Boolean]]("nodewise").description("Whether or not to include the breakdown per node. Optional, defaults to false"))
      .in(query[Option[String]]("clusterNodeId").description("The id of the node where to get the status."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ProcessorStatusEntity].description(""))
      .tags(List("Flow"))
  
  type GetProcessorStatusHistoryEndpoint = Endpoint[Unit, String, Unit, StatusHistoryEntity, Any]
  lazy val getProcessorStatusHistory: GetProcessorStatusHistoryEndpoint =
    endpoint
      .name("getProcessorStatusHistory")
      .get
      .in(("flow" / "processors" / path[String]("id").description("The processor id.") / "status" / "history"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[StatusHistoryEntity].description(""))
      .tags(List("Flow"))
  
  type GetRegistryClientsEndpoint = Endpoint[Unit, Unit, Unit, FlowRegistryClientsEntity, Any]
  lazy val getRegistryClients: GetRegistryClientsEndpoint =
    endpoint
      .name("getRegistryClients")
      .get
      .in(("flow" / "registries"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[FlowRegistryClientsEntity].description(""))
      .tags(List("Flow"))
  
  type GetBranchesEndpoint = Endpoint[Unit, String, Unit, FlowRegistryBranchesEntity, Any]
  lazy val getBranches: GetBranchesEndpoint =
    endpoint
      .name("getBranches")
      .get
      .in(("flow" / "registries" / path[String]("id").description("The registry id.") / "branches"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[FlowRegistryBranchesEntity].description(""))
      .tags(List("Flow"))
  
  type GetBucketsEndpoint = Endpoint[Unit, (String, Option[String]), Unit, FlowRegistryBucketsEntity, Any]
  lazy val getBuckets: GetBucketsEndpoint =
    endpoint
      .name("getBuckets")
      .get
      .in(("flow" / "registries" / path[String]("id").description("The registry id.") / "buckets"))
      .in(query[Option[String]]("branch").description("The name of a branch to get the buckets from. If not specified the default branch of the registry client will be used."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[FlowRegistryBucketsEntity].description(""))
      .tags(List("Flow"))
  
  type GetVersionDifferencesEndpoint = Endpoint[Unit, (String, String, String, String, String, String, String, String, String, Option[Int], Option[Int]), Unit, FlowComparisonEntity, Any]
  lazy val getVersionDifferences: GetVersionDifferencesEndpoint =
    endpoint
      .name("getVersionDifferences")
      .get
      .in(("flow" / "registries" / path[String]("registry-id").description("The registry client id.") / "branches" / path[String]("branch-id-a").description("The branch id for the base version.") / "buckets" / path[String]("bucket-id-a").description("The bucket id for the base version.") / "flows" / path[String]("flow-id-a").description("The flow id for the base version.") / path[String]("version-a").description("The base version.") / "diff" / "branches" / path[String]("branch-id-b").description("The branch id for the compared version.") / "buckets" / path[String]("bucket-id-b").description("The bucket id for the compared version.") / "flows" / path[String]("flow-id-b").description("The flow id for the compared version.") / path[String]("version-b").description("The compared version.")))
      .in(query[Option[Int]]("offset").description("Must be a non-negative number. Specifies the starting point of the listing. 0 means start from the beginning."))
      .in(query[Option[Int]]("limit").description("Limits the number of differences listed. This might lead to partial result. 0 means no limitation is applied."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[FlowComparisonEntity].description(""))
      .tags(List("Flow"))
  
  type GetFlowsEndpoint = Endpoint[Unit, (String, String, Option[String]), Unit, VersionedFlowsEntity, Any]
  lazy val getFlows: GetFlowsEndpoint =
    endpoint
      .name("getFlows")
      .get
      .in(("flow" / "registries" / path[String]("registry-id").description("The registry client id.") / "buckets" / path[String]("bucket-id").description("The bucket id.") / "flows"))
      .in(query[Option[String]]("branch").description("The name of a branch to get the flows from. If not specified the default branch of the registry client will be used."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[VersionedFlowsEntity].description(""))
      .tags(List("Flow"))
  
  type GetDetailsEndpoint = Endpoint[Unit, (String, String, String, Option[String]), Unit, VersionedFlowEntity, Any]
  lazy val getDetails: GetDetailsEndpoint =
    endpoint
      .name("getDetails")
      .get
      .in(("flow" / "registries" / path[String]("registry-id").description("The registry client id.") / "buckets" / path[String]("bucket-id").description("The bucket id.") / "flows" / path[String]("flow-id").description("The flow id.") / "details"))
      .in(query[Option[String]]("branch").description("The name of a branch to get the flow from. If not specified the default branch of the registry client will be used."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[VersionedFlowEntity].description(""))
      .tags(List("Flow"))
  
  type GetVersionsEndpoint = Endpoint[Unit, (String, String, String, Option[String]), Unit, VersionedFlowSnapshotMetadataSetEntity, Any]
  lazy val getVersions: GetVersionsEndpoint =
    endpoint
      .name("getVersions")
      .get
      .in(("flow" / "registries" / path[String]("registry-id").description("The registry client id.") / "buckets" / path[String]("bucket-id").description("The bucket id.") / "flows" / path[String]("flow-id").description("The flow id.") / "versions"))
      .in(query[Option[String]]("branch").description("The name of a branch to get the flow versions from. If not specified the default branch of the registry client will be used."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[VersionedFlowSnapshotMetadataSetEntity].description(""))
      .tags(List("Flow"))
  
  type GetRemoteProcessGroupStatusEndpoint = Endpoint[Unit, (String, Option[Boolean], Option[String]), Unit, RemoteProcessGroupStatusEntity, Any]
  lazy val getRemoteProcessGroupStatus: GetRemoteProcessGroupStatusEndpoint =
    endpoint
      .name("getRemoteProcessGroupStatus")
      .get
      .in(("flow" / "remote-process-groups" / path[String]("id").description("The remote process group id.") / "status"))
      .in(query[Option[Boolean]]("nodewise").description("Whether or not to include the breakdown per node. Optional, defaults to false"))
      .in(query[Option[String]]("clusterNodeId").description("The id of the node where to get the status."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[RemoteProcessGroupStatusEntity].description(""))
      .tags(List("Flow"))
  
  type GetRemoteProcessGroupStatusHistoryEndpoint = Endpoint[Unit, String, Unit, StatusHistoryEntity, Any]
  lazy val getRemoteProcessGroupStatusHistory: GetRemoteProcessGroupStatusHistoryEndpoint =
    endpoint
      .name("getRemoteProcessGroupStatusHistory")
      .get
      .in(("flow" / "remote-process-groups" / path[String]("id").description("The remote process group id.") / "status" / "history"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[StatusHistoryEntity].description(""))
      .tags(List("Flow"))
  
  type GetReportingTaskDefinitionEndpoint = Endpoint[Unit, (String, String, String, String), Unit, ReportingTaskDefinition, Any]
  lazy val getReportingTaskDefinition: GetReportingTaskDefinitionEndpoint =
    endpoint
      .name("getReportingTaskDefinition")
      .get
      .in(("flow" / "reporting-task-definition" / path[String]("group").description("The bundle group") / path[String]("artifact").description("The bundle artifact") / path[String]("version").description("The bundle version") / path[String]("type").description("The reporting task type")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The reporting task definition for the coordinates could not be located."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ReportingTaskDefinition].description(""))
      .tags(List("Flow"))
  
  type GetReportingTaskTypesEndpoint = Endpoint[Unit, (Option[String], Option[String], Option[String]), Unit, ReportingTaskTypesEntity, Any]
  lazy val getReportingTaskTypes: GetReportingTaskTypesEndpoint =
    endpoint
      .name("getReportingTaskTypes")
      .get
      .in(("flow" / "reporting-task-types"))
      .in(query[Option[String]]("bundleGroupFilter").description("If specified, will only return types that are a member of this bundle group."))
      .in(query[Option[String]]("bundleArtifactFilter").description("If specified, will only return types that are a member of this bundle artifact."))
      .in(query[Option[String]]("type").description("If specified, will only return types whose fully qualified classname matches."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ReportingTaskTypesEntity].description(""))
      .tags(List("Flow"))
  
  type GetReportingTasksEndpoint = Endpoint[Unit, Unit, Unit, ReportingTasksEntity, Any]
  lazy val getReportingTasks: GetReportingTasksEndpoint =
    endpoint
      .name("getReportingTasks")
      .get
      .in(("flow" / "reporting-tasks"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ReportingTasksEntity].description(""))
      .tags(List("Flow"))
  
  type DownloadReportingTaskSnapshotEndpoint = Endpoint[Unit, Option[String], Unit, ByteString, Any]
  lazy val downloadReportingTaskSnapshot: DownloadReportingTaskSnapshotEndpoint =
    endpoint
      .name("downloadReportingTaskSnapshot")
      .get
      .in(("flow" / "reporting-tasks" / "download"))
      .in(query[Option[String]]("reportingTaskId").description("Specifies a reporting task id to export. If not specified, all reporting tasks will be exported."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(())))
      .out(jsonBody[ByteString].description(""))
      .tags(List("Flow"))
  
  type GetReportingTaskSnapshotEndpoint = Endpoint[Unit, Option[String], Unit, VersionedReportingTaskSnapshot, Any]
  lazy val getReportingTaskSnapshot: GetReportingTaskSnapshotEndpoint =
    endpoint
      .name("getReportingTaskSnapshot")
      .get
      .in(("flow" / "reporting-tasks" / "snapshot"))
      .in(query[Option[String]]("reportingTaskId").description("Specifies a reporting task id to export. If not specified, all reporting tasks will be exported."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(())))
      .out(jsonBody[VersionedReportingTaskSnapshot].description(""))
      .tags(List("Flow"))
  
  type GetRuntimeManifestEndpoint = Endpoint[Unit, Unit, Unit, RuntimeManifestEntity, Any]
  lazy val getRuntimeManifest: GetRuntimeManifestEndpoint =
    endpoint
      .name("getRuntimeManifest")
      .get
      .in(("flow" / "runtime-manifest"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[RuntimeManifestEntity].description(""))
      .tags(List("Flow"))
  
  type SearchFlowEndpoint = Endpoint[Unit, (Option[String], Option[String]), Unit, SearchResultsEntity, Any]
  lazy val searchFlow: SearchFlowEndpoint =
    endpoint
      .name("searchFlow")
      .get
      .in(("flow" / "search-results"))
      .in(query[Option[String]]("q"))
      .in(query[Option[String]]("a"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[SearchResultsEntity].description(""))
      .tags(List("Flow"))
  
  type GetControllerStatusEndpoint = Endpoint[Unit, Unit, Unit, ControllerStatusEntity, Any]
  lazy val getControllerStatus: GetControllerStatusEndpoint =
    endpoint
      .name("getControllerStatus")
      .get
      .in(("flow" / "status"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ControllerStatusEntity].description(""))
      .tags(List("Flow"))
  
  type CreateDropRequestEndpoint = Endpoint[Unit, String, Unit, DropRequestEntity, Any]
  lazy val createDropRequest: CreateDropRequestEndpoint =
    endpoint
      .name("createDropRequest")
      .post
      .in(("flowfile-queues" / path[String]("id").description("The connection id.") / "drop-requests"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[DropRequestEntity].description("The request has been accepted. A HTTP response header will contain the URI where the response can be polled.").and(statusCode(sttp.model.StatusCode(202))))
      .tags(List("FlowFileQueues"))
  
  type GetDropRequestEndpoint = Endpoint[Unit, (String, String), Unit, DropRequestEntity, Any]
  lazy val getDropRequest: GetDropRequestEndpoint =
    endpoint
      .name("getDropRequest")
      .get
      .in(("flowfile-queues" / path[String]("id").description("The connection id.") / "drop-requests" / path[String]("drop-request-id").description("The drop request id.")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[DropRequestEntity].description(""))
      .tags(List("FlowFileQueues"))
  
  type RemoveDropRequestEndpoint = Endpoint[Unit, (String, String), Unit, DropRequestEntity, Any]
  lazy val removeDropRequest: RemoveDropRequestEndpoint =
    endpoint
      .name("removeDropRequest")
      .delete
      .in(("flowfile-queues" / path[String]("id").description("The connection id.") / "drop-requests" / path[String]("drop-request-id").description("The drop request id.")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[DropRequestEntity].description(""))
      .tags(List("FlowFileQueues"))
  
  type GetFlowFileEndpoint = Endpoint[Unit, (String, String, Option[String]), Unit, FlowFileEntity, Any]
  lazy val getFlowFile: GetFlowFileEndpoint =
    endpoint
      .name("getFlowFile")
      .get
      .in(("flowfile-queues" / path[String]("id").description("The connection id.") / "flowfiles" / path[String]("flowfile-uuid").description("The flowfile uuid.")))
      .in(query[Option[String]]("clusterNodeId").description("The id of the node where the content exists if clustered."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[FlowFileEntity].description(""))
      .tags(List("FlowFileQueues"))
  
  type DownloadFlowFileContentEndpoint = Endpoint[Unit, (String, String, Option[String], Option[ClientIdParameterStr], Option[String]), Unit, Option[sttp.capabilities.pekko.PekkoStreams.BinaryStream], sttp.capabilities.pekko.PekkoStreams]
  lazy val downloadFlowFileContent: DownloadFlowFileContentEndpoint =
    endpoint
      .name("downloadFlowFileContent")
      .get
      .in(("flowfile-queues" / path[String]("id").description("The connection id.") / "flowfiles" / path[String]("flowfile-uuid").description("The flowfile uuid.") / "content"))
      .in(header[Option[String]]("Range").description("Range of bytes requested"))
      .in(query[Option[ClientIdParameterStr]]("clientId").description("If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response."))
      .in(query[Option[String]]("clusterNodeId").description("The id of the node where the content exists if clustered."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(416), emptyOutput.description("Requested Range Not Satisfiable based on bytes requested"))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(oneOf[Option[sttp.capabilities.pekko.PekkoStreams.BinaryStream]](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(206), emptyOutput.description("Partial Content with range of bytes requested"))(None),
        oneOfVariantValueMatcher(sttp.model.StatusCode(200), streamBody(sttp.capabilities.pekko.PekkoStreams)(Schema.binary[StreamingOutput], `*/*CodecFormat`()).description("").toEndpointIO.map(Some(_))(_.orNull)){ case Some(_: sttp.capabilities.pekko.PekkoStreams.BinaryStream) => true }))
      .tags(List("FlowFileQueues"))
  
  type CreateFlowFileListingEndpoint = Endpoint[Unit, String, Unit, ListingRequestEntity, Any]
  lazy val createFlowFileListing: CreateFlowFileListingEndpoint =
    endpoint
      .name("createFlowFileListing")
      .post
      .in(("flowfile-queues" / path[String]("id").description("The connection id.") / "listing-requests"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ListingRequestEntity].description("The request has been accepted. A HTTP response header will contain the URI where the response can be polled.").and(statusCode(sttp.model.StatusCode(202))))
      .tags(List("FlowFileQueues"))
  
  type GetListingRequestEndpoint = Endpoint[Unit, (String, String), Unit, ListingRequestEntity, Any]
  lazy val getListingRequest: GetListingRequestEndpoint =
    endpoint
      .name("getListingRequest")
      .get
      .in(("flowfile-queues" / path[String]("id").description("The connection id.") / "listing-requests" / path[String]("listing-request-id").description("The listing request id.")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ListingRequestEntity].description(""))
      .tags(List("FlowFileQueues"))
  
  type DeleteListingRequestEndpoint = Endpoint[Unit, (String, String), Unit, ListingRequestEntity, Any]
  lazy val deleteListingRequest: DeleteListingRequestEndpoint =
    endpoint
      .name("deleteListingRequest")
      .delete
      .in(("flowfile-queues" / path[String]("id").description("The connection id.") / "listing-requests" / path[String]("listing-request-id").description("The listing request id.")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ListingRequestEntity].description(""))
      .tags(List("FlowFileQueues"))
  
  type GetFunnelEndpoint = Endpoint[Unit, String, Unit, FunnelEntity, Any]
  lazy val getFunnel: GetFunnelEndpoint =
    endpoint
      .name("getFunnel")
      .get
      .in(("funnels" / path[String]("id").description("The funnel id.")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[FunnelEntity].description(""))
      .tags(List("Funnels"))
  
  type UpdateFunnelEndpoint = Endpoint[Unit, (String, FunnelEntity), Unit, FunnelEntity, Any]
  lazy val updateFunnel: UpdateFunnelEndpoint =
    endpoint
      .name("updateFunnel")
      .put
      .in(("funnels" / path[String]("id").description("The funnel id.")))
      .in(jsonBody[FunnelEntity].description("The funnel configuration details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[FunnelEntity].description(""))
      .tags(List("Funnels"))
  
  type RemoveFunnelEndpoint = Endpoint[Unit, (String, Option[LongParameterInt], Option[ClientIdParameterStr], Option[Boolean]), Unit, FunnelEntity, Any]
  lazy val removeFunnel: RemoveFunnelEndpoint =
    endpoint
      .name("removeFunnel")
      .delete
      .in(("funnels" / path[String]("id").description("The funnel id.")))
      .in(query[Option[LongParameterInt]]("version").description("The revision is used to verify the client is working with the latest version of the flow."))
      .in(query[Option[ClientIdParameterStr]]("clientId").description("If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response."))
      .in(query[Option[Boolean]]("disconnectedNodeAcknowledged").description("Acknowledges that this node is disconnected to allow for mutable requests to proceed."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[FunnelEntity].description(""))
      .tags(List("Funnels"))
  
  type GetInputPortEndpoint = Endpoint[Unit, String, Unit, PortEntity, Any]
  lazy val getInputPort: GetInputPortEndpoint =
    endpoint
      .name("getInputPort")
      .get
      .in(("input-ports" / path[String]("id").description("The input port id.")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[PortEntity].description(""))
      .tags(List("InputPorts"))
  
  type UpdateInputPortEndpoint = Endpoint[Unit, (String, PortEntity), Unit, PortEntity, Any]
  lazy val updateInputPort: UpdateInputPortEndpoint =
    endpoint
      .name("updateInputPort")
      .put
      .in(("input-ports" / path[String]("id").description("The input port id.")))
      .in(jsonBody[PortEntity].description("The input port configuration details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[PortEntity].description(""))
      .tags(List("InputPorts"))
  
  type RemoveInputPortEndpoint = Endpoint[Unit, (String, Option[LongParameterInt], Option[ClientIdParameterStr], Option[Boolean]), Unit, PortEntity, Any]
  lazy val removeInputPort: RemoveInputPortEndpoint =
    endpoint
      .name("removeInputPort")
      .delete
      .in(("input-ports" / path[String]("id").description("The input port id.")))
      .in(query[Option[LongParameterInt]]("version").description("The revision is used to verify the client is working with the latest version of the flow."))
      .in(query[Option[ClientIdParameterStr]]("clientId").description("If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response."))
      .in(query[Option[Boolean]]("disconnectedNodeAcknowledged").description("Acknowledges that this node is disconnected to allow for mutable requests to proceed."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[PortEntity].description(""))
      .tags(List("InputPorts"))
  
  type UpdateRunStatus_2Endpoint = Endpoint[Unit, (String, PortRunStatusEntity), Unit, ProcessorEntity, Any]
  lazy val updateRunStatus_2: UpdateRunStatus_2Endpoint =
    endpoint
      .name("updateRunStatus_2")
      .put
      .in(("input-ports" / path[String]("id").description("The port id.") / "run-status"))
      .in(jsonBody[PortRunStatusEntity].description("The port run status."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ProcessorEntity].description(""))
      .tags(List("InputPorts"))
  
  type GetLabelEndpoint = Endpoint[Unit, String, Unit, LabelEntity, Any]
  lazy val getLabel: GetLabelEndpoint =
    endpoint
      .name("getLabel")
      .get
      .in(("labels" / path[String]("id").description("The label id.")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[LabelEntity].description(""))
      .tags(List("Labels"))
  
  type UpdateLabelEndpoint = Endpoint[Unit, (String, LabelEntity), Unit, LabelEntity, Any]
  lazy val updateLabel: UpdateLabelEndpoint =
    endpoint
      .name("updateLabel")
      .put
      .in(("labels" / path[String]("id").description("The label id.")))
      .in(jsonBody[LabelEntity].description("The label configuration details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[LabelEntity].description(""))
      .tags(List("Labels"))
  
  type RemoveLabelEndpoint = Endpoint[Unit, (String, Option[LongParameterInt], Option[ClientIdParameterStr], Option[Boolean]), Unit, LabelEntity, Any]
  lazy val removeLabel: RemoveLabelEndpoint =
    endpoint
      .name("removeLabel")
      .delete
      .in(("labels" / path[String]("id").description("The label id.")))
      .in(query[Option[LongParameterInt]]("version").description("The revision is used to verify the client is working with the latest version of the flow."))
      .in(query[Option[ClientIdParameterStr]]("clientId").description("If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response."))
      .in(query[Option[Boolean]]("disconnectedNodeAcknowledged").description("Acknowledges that this node is disconnected to allow for mutable requests to proceed."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[LabelEntity].description(""))
      .tags(List("Labels"))
  
  type GetOutputPortEndpoint = Endpoint[Unit, String, Unit, PortEntity, Any]
  lazy val getOutputPort: GetOutputPortEndpoint =
    endpoint
      .name("getOutputPort")
      .get
      .in(("output-ports" / path[String]("id").description("The output port id.")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[PortEntity].description(""))
      .tags(List("OutputPorts"))
  
  type UpdateOutputPortEndpoint = Endpoint[Unit, (String, PortEntity), Unit, PortEntity, Any]
  lazy val updateOutputPort: UpdateOutputPortEndpoint =
    endpoint
      .name("updateOutputPort")
      .put
      .in(("output-ports" / path[String]("id").description("The output port id.")))
      .in(jsonBody[PortEntity].description("The output port configuration details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[PortEntity].description(""))
      .tags(List("OutputPorts"))
  
  type RemoveOutputPortEndpoint = Endpoint[Unit, (String, Option[LongParameterInt], Option[ClientIdParameterStr], Option[Boolean]), Unit, PortEntity, Any]
  lazy val removeOutputPort: RemoveOutputPortEndpoint =
    endpoint
      .name("removeOutputPort")
      .delete
      .in(("output-ports" / path[String]("id").description("The output port id.")))
      .in(query[Option[LongParameterInt]]("version").description("The revision is used to verify the client is working with the latest version of the flow."))
      .in(query[Option[ClientIdParameterStr]]("clientId").description("If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response."))
      .in(query[Option[Boolean]]("disconnectedNodeAcknowledged").description("Acknowledges that this node is disconnected to allow for mutable requests to proceed."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[PortEntity].description(""))
      .tags(List("OutputPorts"))
  
  type UpdateRunStatus_3Endpoint = Endpoint[Unit, (String, PortRunStatusEntity), Unit, ProcessorEntity, Any]
  lazy val updateRunStatus_3: UpdateRunStatus_3Endpoint =
    endpoint
      .name("updateRunStatus_3")
      .put
      .in(("output-ports" / path[String]("id").description("The port id.") / "run-status"))
      .in(jsonBody[PortRunStatusEntity].description("The port run status."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ProcessorEntity].description(""))
      .tags(List("OutputPorts"))
  
  type CreateParameterContextEndpoint = Endpoint[Unit, ParameterContextEntity, Unit, ParameterContextEntity, Any]
  lazy val createParameterContext: CreateParameterContextEndpoint =
    endpoint
      .name("createParameterContext")
      .post
      .in(("parameter-contexts"))
      .in(jsonBody[ParameterContextEntity].description("The Parameter Context."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ParameterContextEntity].description("").and(statusCode(sttp.model.StatusCode(201))))
      .tags(List("ParameterContexts"))
  
  type GetAssetsEndpoint = Endpoint[Unit, String, Unit, AssetsEntity, Any]
  lazy val getAssets: GetAssetsEndpoint =
    endpoint
      .name("getAssets")
      .get
      .in(("parameter-contexts" / path[String]("contextId").description("The ID of the Parameter Context") / "assets"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[AssetsEntity].description(""))
      .tags(List("ParameterContexts"))
  
  type CreateAssetEndpoint = Endpoint[Unit, (String, Option[String], sttp.capabilities.pekko.PekkoStreams.BinaryStream), Unit, AssetEntity, sttp.capabilities.pekko.PekkoStreams]
  lazy val createAsset: CreateAssetEndpoint =
    endpoint
      .name("createAsset")
      .post
      .in(("parameter-contexts" / path[String]("contextId") / "assets"))
      .in(header[Option[String]]("Filename"))
      .in(streamBody(sttp.capabilities.pekko.PekkoStreams)(Schema.binary[CreateAssetRequest], CodecFormat.OctetStream()).description("The contents of the asset."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[AssetEntity].description(""))
      .tags(List("ParameterContexts"))
  
  type GetAssetContentEndpoint = Endpoint[Unit, (String, String), Unit, sttp.capabilities.pekko.PekkoStreams.BinaryStream, sttp.capabilities.pekko.PekkoStreams]
  lazy val getAssetContent: GetAssetContentEndpoint =
    endpoint
      .name("getAssetContent")
      .get
      .in(("parameter-contexts" / path[String]("contextId").description("The ID of the Parameter Context") / "assets" / path[String]("assetId").description("The ID of the Asset")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(streamBody(sttp.capabilities.pekko.PekkoStreams)(Schema.binary[ByteString], CodecFormat.OctetStream()).description(""))
      .tags(List("ParameterContexts"))
  
  type DeleteAssetEndpoint = Endpoint[Unit, (String, String, Option[Boolean]), Unit, AssetEntity, Any]
  lazy val deleteAsset: DeleteAssetEndpoint =
    endpoint
      .name("deleteAsset")
      .delete
      .in(("parameter-contexts" / path[String]("contextId").description("The ID of the Parameter Context") / "assets" / path[String]("assetId").description("The ID of the Asset")))
      .in(query[Option[Boolean]]("disconnectedNodeAcknowledged"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[AssetEntity].description(""))
      .tags(List("ParameterContexts"))
  
  type SubmitParameterContextUpdateEndpoint = Endpoint[Unit, (String, ParameterContextEntity), Unit, ParameterContextUpdateRequestEntity, Any]
  lazy val submitParameterContextUpdate: SubmitParameterContextUpdateEndpoint =
    endpoint
      .name("submitParameterContextUpdate")
      .post
      .in(("parameter-contexts" / path[String]("contextId") / "update-requests"))
      .in(jsonBody[ParameterContextEntity].description("The updated version of the parameter context."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ParameterContextUpdateRequestEntity].description(""))
      .tags(List("ParameterContexts"))
  
  type GetParameterContextUpdateEndpoint = Endpoint[Unit, (String, String), Unit, ParameterContextUpdateRequestEntity, Any]
  lazy val getParameterContextUpdate: GetParameterContextUpdateEndpoint =
    endpoint
      .name("getParameterContextUpdate")
      .get
      .in(("parameter-contexts" / path[String]("contextId").description("The ID of the Parameter Context") / "update-requests" / path[String]("requestId").description("The ID of the Update Request")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ParameterContextUpdateRequestEntity].description(""))
      .tags(List("ParameterContexts"))
  
  type DeleteUpdateRequestEndpoint = Endpoint[Unit, (String, String, Option[Boolean]), Unit, ParameterContextUpdateRequestEntity, Any]
  lazy val deleteUpdateRequest: DeleteUpdateRequestEndpoint =
    endpoint
      .name("deleteUpdateRequest")
      .delete
      .in(("parameter-contexts" / path[String]("contextId").description("The ID of the ParameterContext") / "update-requests" / path[String]("requestId").description("The ID of the Update Request")))
      .in(query[Option[Boolean]]("disconnectedNodeAcknowledged").description("Acknowledges that this node is disconnected to allow for mutable requests to proceed."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ParameterContextUpdateRequestEntity].description(""))
      .tags(List("ParameterContexts"))
  
  type SubmitValidationRequestEndpoint = Endpoint[Unit, (String, ParameterContextValidationRequestEntity), Unit, ParameterContextValidationRequestEntity, Any]
  lazy val submitValidationRequest: SubmitValidationRequestEndpoint =
    endpoint
      .name("submitValidationRequest")
      .post
      .in(("parameter-contexts" / path[String]("contextId") / "validation-requests"))
      .in(jsonBody[ParameterContextValidationRequestEntity].description("The validation request"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ParameterContextValidationRequestEntity].description(""))
      .tags(List("ParameterContexts"))
  
  type GetValidationRequestEndpoint = Endpoint[Unit, (String, String), Unit, ParameterContextValidationRequestEntity, Any]
  lazy val getValidationRequest: GetValidationRequestEndpoint =
    endpoint
      .name("getValidationRequest")
      .get
      .in(("parameter-contexts" / path[String]("contextId").description("The ID of the Parameter Context") / "validation-requests" / path[String]("id").description("The ID of the Validation Request")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ParameterContextValidationRequestEntity].description(""))
      .tags(List("ParameterContexts"))
  
  type DeleteValidationRequestEndpoint = Endpoint[Unit, (String, String, Option[Boolean]), Unit, ParameterContextValidationRequestEntity, Any]
  lazy val deleteValidationRequest: DeleteValidationRequestEndpoint =
    endpoint
      .name("deleteValidationRequest")
      .delete
      .in(("parameter-contexts" / path[String]("contextId").description("The ID of the Parameter Context") / "validation-requests" / path[String]("id").description("The ID of the Update Request")))
      .in(query[Option[Boolean]]("disconnectedNodeAcknowledged").description("Acknowledges that this node is disconnected to allow for mutable requests to proceed."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ParameterContextValidationRequestEntity].description(""))
      .tags(List("ParameterContexts"))
  
  type GetParameterContextEndpoint = Endpoint[Unit, (String, Option[Boolean]), Unit, ParameterContextEntity, Any]
  lazy val getParameterContext: GetParameterContextEndpoint =
    endpoint
      .name("getParameterContext")
      .get
      .in(("parameter-contexts" / path[String]("id").description("The ID of the Parameter Context")))
      .in(query[Option[Boolean]]("includeInheritedParameters").description("Whether or not to include inherited parameters from other parameter contexts, and therefore also overridden values.  If true, the result will be the 'effective' parameter context."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ParameterContextEntity].description(""))
      .tags(List("ParameterContexts"))
  
  type UpdateParameterContextEndpoint = Endpoint[Unit, (String, ParameterContextEntity), Unit, ParameterContextEntity, Any]
  lazy val updateParameterContext: UpdateParameterContextEndpoint =
    endpoint
      .name("updateParameterContext")
      .put
      .in(("parameter-contexts" / path[String]("id")))
      .in(jsonBody[ParameterContextEntity].description("The updated Parameter Context"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ParameterContextEntity].description(""))
      .tags(List("ParameterContexts"))
  
  type DeleteParameterContextEndpoint = Endpoint[Unit, (String, Option[LongParameterInt], Option[ClientIdParameterStr], Option[Boolean]), Unit, ParameterContextEntity, Any]
  lazy val deleteParameterContext: DeleteParameterContextEndpoint =
    endpoint
      .name("deleteParameterContext")
      .delete
      .in(("parameter-contexts" / path[String]("id").description("The Parameter Context ID.")))
      .in(query[Option[LongParameterInt]]("version").description("The version is used to verify the client is working with the latest version of the flow."))
      .in(query[Option[ClientIdParameterStr]]("clientId").description("If the client id is not specified, a new one will be generated. This value (whether specified or generated) is included in the response."))
      .in(query[Option[Boolean]]("disconnectedNodeAcknowledged").description("Acknowledges that this node is disconnected to allow for mutable requests to proceed."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ParameterContextEntity].description(""))
      .tags(List("ParameterContexts"))
  
  type GetParameterProviderEndpoint = Endpoint[Unit, String, Unit, ParameterProviderEntity, Any]
  lazy val getParameterProvider: GetParameterProviderEndpoint =
    endpoint
      .name("getParameterProvider")
      .get
      .in(("parameter-providers" / path[String]("id").description("The parameter provider id.")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ParameterProviderEntity].description(""))
      .tags(List("ParameterProviders"))
  
  type UpdateParameterProviderEndpoint = Endpoint[Unit, (String, ParameterProviderEntity), Unit, ParameterProviderEntity, Any]
  lazy val updateParameterProvider: UpdateParameterProviderEndpoint =
    endpoint
      .name("updateParameterProvider")
      .put
      .in(("parameter-providers" / path[String]("id").description("The parameter provider id.")))
      .in(jsonBody[ParameterProviderEntity].description("The parameter provider configuration details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ParameterProviderEntity].description(""))
      .tags(List("ParameterProviders"))
  
  type RemoveParameterProviderEndpoint = Endpoint[Unit, (String, Option[LongParameterInt], Option[ClientIdParameterStr], Option[Boolean]), Unit, ParameterProviderEntity, Any]
  lazy val removeParameterProvider: RemoveParameterProviderEndpoint =
    endpoint
      .name("removeParameterProvider")
      .delete
      .in(("parameter-providers" / path[String]("id").description("The parameter provider id.")))
      .in(query[Option[LongParameterInt]]("version").description("The revision is used to verify the client is working with the latest version of the flow."))
      .in(query[Option[ClientIdParameterStr]]("clientId").description("If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response."))
      .in(query[Option[Boolean]]("disconnectedNodeAcknowledged").description("Acknowledges that this node is disconnected to allow for mutable requests to proceed."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ParameterProviderEntity].description(""))
      .tags(List("ParameterProviders"))
  
  type AnalyzeConfiguration_1Endpoint = Endpoint[Unit, (String, ConfigurationAnalysisEntity), Unit, ConfigurationAnalysisEntity, Any]
  lazy val analyzeConfiguration_1: AnalyzeConfiguration_1Endpoint =
    endpoint
      .name("analyzeConfiguration_1")
      .post
      .in(("parameter-providers" / path[String]("id").description("The parameter provider id.") / "config" / "analysis"))
      .in(jsonBody[ConfigurationAnalysisEntity].description("The configuration analysis request."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ConfigurationAnalysisEntity].description(""))
      .tags(List("ParameterProviders"))
  
  type SubmitConfigVerificationRequest_1Endpoint = Endpoint[Unit, (String, VerifyConfigRequestEntity), Unit, VerifyConfigRequestEntity, Any]
  lazy val submitConfigVerificationRequest_1: SubmitConfigVerificationRequest_1Endpoint =
    endpoint
      .name("submitConfigVerificationRequest_1")
      .post
      .in(("parameter-providers" / path[String]("id").description("The parameter provider id.") / "config" / "verification-requests"))
      .in(jsonBody[VerifyConfigRequestEntity].description("The parameter provider configuration verification request."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[VerifyConfigRequestEntity].description(""))
      .tags(List("ParameterProviders"))
  
  type GetVerificationRequest_1Endpoint = Endpoint[Unit, (String, String), Unit, VerifyConfigRequestEntity, Any]
  lazy val getVerificationRequest_1: GetVerificationRequest_1Endpoint =
    endpoint
      .name("getVerificationRequest_1")
      .get
      .in(("parameter-providers" / path[String]("id").description("The ID of the Parameter Provider") / "config" / "verification-requests" / path[String]("requestId").description("The ID of the Verification Request")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[VerifyConfigRequestEntity].description(""))
      .tags(List("ParameterProviders"))
  
  type DeleteVerificationRequest_1Endpoint = Endpoint[Unit, (String, String), Unit, VerifyConfigRequestEntity, Any]
  lazy val deleteVerificationRequest_1: DeleteVerificationRequest_1Endpoint =
    endpoint
      .name("deleteVerificationRequest_1")
      .delete
      .in(("parameter-providers" / path[String]("id").description("The ID of the Parameter Provider") / "config" / "verification-requests" / path[String]("requestId").description("The ID of the Verification Request")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[VerifyConfigRequestEntity].description(""))
      .tags(List("ParameterProviders"))
  
  type GetPropertyDescriptor_2Endpoint = Endpoint[Unit, (String, String), Unit, PropertyDescriptorEntity, Any]
  lazy val getPropertyDescriptor_2: GetPropertyDescriptor_2Endpoint =
    endpoint
      .name("getPropertyDescriptor_2")
      .get
      .in(("parameter-providers" / path[String]("id").description("The parameter provider id.") / "descriptors"))
      .in(query[String]("propertyName").description("The property name."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[PropertyDescriptorEntity].description(""))
      .tags(List("ParameterProviders"))
  
  type FetchParametersEndpoint = Endpoint[Unit, (String, ParameterProviderParameterFetchEntity), Unit, ParameterProviderEntity, Any]
  lazy val fetchParameters: FetchParametersEndpoint =
    endpoint
      .name("fetchParameters")
      .post
      .in(("parameter-providers" / path[String]("id").description("The parameter provider id.") / "parameters" / "fetch-requests"))
      .in(jsonBody[ParameterProviderParameterFetchEntity].description("The parameter fetch request."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ParameterProviderEntity].description(""))
      .tags(List("ParameterProviders"))
  
  type GetParameterProviderReferencesEndpoint = Endpoint[Unit, String, Unit, ParameterProviderReferencingComponentsEntity, Any]
  lazy val getParameterProviderReferences: GetParameterProviderReferencesEndpoint =
    endpoint
      .name("getParameterProviderReferences")
      .get
      .in(("parameter-providers" / path[String]("id").description("The parameter provider id.") / "references"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ParameterProviderReferencingComponentsEntity].description(""))
      .tags(List("ParameterProviders"))
  
  type GetState_1Endpoint = Endpoint[Unit, String, Unit, ComponentStateEntity, Any]
  lazy val getState_1: GetState_1Endpoint =
    endpoint
      .name("getState_1")
      .get
      .in(("parameter-providers" / path[String]("id").description("The parameter provider id.") / "state"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ComponentStateEntity].description(""))
      .tags(List("ParameterProviders"))
  
  type ClearState_2Endpoint = Endpoint[Unit, (String, ClearState_2BodyIn), Unit, ComponentStateEntity, Any]
  lazy val clearState_2: ClearState_2Endpoint =
    endpoint
      .name("clearState_2")
      .post
      .in(("parameter-providers" / path[String]("id").description("The parameter provider id.") / "state" / "clear-requests"))
      .in(oneOfBody[ClearState_2BodyIn](
        EndpointIO.Body(RawBodyType.ByteArrayBody, Codec.id[Array[Byte], `*/*CodecFormat`](`*/*CodecFormat`(), Schema.schemaForByteArray), EndpointIO.Info.empty).map(ClearState_2Body0In(_))(_.value).widenBody[ClearState_2BodyIn].description("Optional component state to perform a selective key removal. If omitted, clears all state."),
        jsonBody[Option[ComponentStateEntity]].map(ClearState_2BodyOption_ComponentStateEntity_In(_))(_.value).widenBody[ClearState_2BodyIn].description("Optional component state to perform a selective key removal. If omitted, clears all state.")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ComponentStateEntity].description(""))
      .tags(List("ParameterProviders"))
  
  type SubmitApplyParametersEndpoint = Endpoint[Unit, (String, ParameterProviderParameterApplicationEntity), Unit, ParameterProviderApplyParametersRequestEntity, Any]
  lazy val submitApplyParameters: SubmitApplyParametersEndpoint =
    endpoint
      .name("submitApplyParameters")
      .post
      .in(("parameter-providers" / path[String]("providerId") / "apply-parameters-requests"))
      .in(jsonBody[ParameterProviderParameterApplicationEntity].description("The apply parameters request."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ParameterProviderApplyParametersRequestEntity].description(""))
      .tags(List("ParameterProviders"))
  
  type GetParameterProviderApplyParametersRequestEndpoint = Endpoint[Unit, (String, String), Unit, ParameterProviderApplyParametersRequestEntity, Any]
  lazy val getParameterProviderApplyParametersRequest: GetParameterProviderApplyParametersRequestEndpoint =
    endpoint
      .name("getParameterProviderApplyParametersRequest")
      .get
      .in(("parameter-providers" / path[String]("providerId").description("The ID of the Parameter Provider") / "apply-parameters-requests" / path[String]("requestId").description("The ID of the Apply Parameters Request")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ParameterProviderApplyParametersRequestEntity].description(""))
      .tags(List("ParameterProviders"))
  
  type DeleteApplyParametersRequestEndpoint = Endpoint[Unit, (String, String, Option[Boolean]), Unit, ParameterProviderApplyParametersRequestEntity, Any]
  lazy val deleteApplyParametersRequest: DeleteApplyParametersRequestEndpoint =
    endpoint
      .name("deleteApplyParametersRequest")
      .delete
      .in(("parameter-providers" / path[String]("providerId").description("The ID of the Parameter Provider") / "apply-parameters-requests" / path[String]("requestId").description("The ID of the Apply Parameters Request")))
      .in(query[Option[Boolean]]("disconnectedNodeAcknowledged").description("Acknowledges that this node is disconnected to allow for mutable requests to proceed."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ParameterProviderApplyParametersRequestEntity].description(""))
      .tags(List("ParameterProviders"))
  
  type CreateAccessPolicyEndpoint = Endpoint[Unit, AccessPolicyEntity, Unit, AccessPolicyEntity, Any]
  lazy val createAccessPolicy: CreateAccessPolicyEndpoint =
    endpoint
      .name("createAccessPolicy")
      .post
      .in(("policies"))
      .in(jsonBody[AccessPolicyEntity].description("The access policy configuration details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[AccessPolicyEntity].description("").and(statusCode(sttp.model.StatusCode(201))))
      .tags(List("Policies"))
  
  type GetAccessPolicyForResourceEndpoint = Endpoint[Unit, (String, String), Unit, AccessPolicyEntity, Any]
  lazy val getAccessPolicyForResource: GetAccessPolicyForResourceEndpoint =
    endpoint
      .name("getAccessPolicyForResource")
      .get
      .in(("policies" / path[String]("action").description("The request action.") / path[String]("resource").validate(Validator.pattern(".+")).description("The resource of the policy.")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[AccessPolicyEntity].description(""))
      .tags(List("Policies"))
  
  type GetAccessPolicyEndpoint = Endpoint[Unit, String, Unit, AccessPolicyEntity, Any]
  lazy val getAccessPolicy: GetAccessPolicyEndpoint =
    endpoint
      .name("getAccessPolicy")
      .get
      .in(("policies" / path[String]("id").description("The access policy id.")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[AccessPolicyEntity].description(""))
      .tags(List("Policies"))
  
  type UpdateAccessPolicyEndpoint = Endpoint[Unit, (String, AccessPolicyEntity), Unit, AccessPolicyEntity, Any]
  lazy val updateAccessPolicy: UpdateAccessPolicyEndpoint =
    endpoint
      .name("updateAccessPolicy")
      .put
      .in(("policies" / path[String]("id").description("The access policy id.")))
      .in(jsonBody[AccessPolicyEntity].description("The access policy configuration details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[AccessPolicyEntity].description(""))
      .tags(List("Policies"))
  
  type RemoveAccessPolicyEndpoint = Endpoint[Unit, (String, Option[LongParameterInt], Option[ClientIdParameterStr], Option[Boolean]), Unit, AccessPolicyEntity, Any]
  lazy val removeAccessPolicy: RemoveAccessPolicyEndpoint =
    endpoint
      .name("removeAccessPolicy")
      .delete
      .in(("policies" / path[String]("id").description("The access policy id.")))
      .in(query[Option[LongParameterInt]]("version").description("The revision is used to verify the client is working with the latest version of the flow."))
      .in(query[Option[ClientIdParameterStr]]("clientId").description("If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response."))
      .in(query[Option[Boolean]]("disconnectedNodeAcknowledged").description("Acknowledges that this node is disconnected to allow for mutable requests to proceed."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[AccessPolicyEntity].description(""))
      .tags(List("Policies"))
  
  type GetReplaceProcessGroupRequestEndpoint = Endpoint[Unit, String, Unit, ProcessGroupReplaceRequestEntity, Any]
  lazy val getReplaceProcessGroupRequest: GetReplaceProcessGroupRequestEndpoint =
    endpoint
      .name("getReplaceProcessGroupRequest")
      .get
      .in(("process-groups" / "replace-requests" / path[String]("id").description("The ID of the Replace Request")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ProcessGroupReplaceRequestEntity].description(""))
      .tags(List("ProcessGroups"))
  
  type DeleteReplaceProcessGroupRequestEndpoint = Endpoint[Unit, (String, Option[Boolean]), Unit, ProcessGroupReplaceRequestEntity, Any]
  lazy val deleteReplaceProcessGroupRequest: DeleteReplaceProcessGroupRequestEndpoint =
    endpoint
      .name("deleteReplaceProcessGroupRequest")
      .delete
      .in(("process-groups" / "replace-requests" / path[String]("id").description("The ID of the Update Request")))
      .in(query[Option[Boolean]]("disconnectedNodeAcknowledged").description("Acknowledges that this node is disconnected to allow for mutable requests to proceed."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ProcessGroupReplaceRequestEntity].description(""))
      .tags(List("ProcessGroups"))
  
  type GetProcessGroupEndpoint = Endpoint[Unit, String, Unit, ProcessGroupEntity, Any]
  lazy val getProcessGroup: GetProcessGroupEndpoint =
    endpoint
      .name("getProcessGroup")
      .get
      .in(("process-groups" / path[String]("id").description("The process group id.")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ProcessGroupEntity].description(""))
      .tags(List("ProcessGroups"))
  
  type UpdateProcessGroupEndpoint = Endpoint[Unit, (String, ProcessGroupEntity), Unit, ProcessGroupEntity, Any]
  lazy val updateProcessGroup: UpdateProcessGroupEndpoint =
    endpoint
      .name("updateProcessGroup")
      .put
      .in(("process-groups" / path[String]("id").description("The process group id.")))
      .in(jsonBody[ProcessGroupEntity].description("The process group configuration details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ProcessGroupEntity].description(""))
      .tags(List("ProcessGroups"))
  
  type RemoveProcessGroupEndpoint = Endpoint[Unit, (String, Option[LongParameterInt], Option[ClientIdParameterStr], Option[Boolean]), Unit, ProcessGroupEntity, Any]
  lazy val removeProcessGroup: RemoveProcessGroupEndpoint =
    endpoint
      .name("removeProcessGroup")
      .delete
      .in(("process-groups" / path[String]("id").description("The process group id.")))
      .in(query[Option[LongParameterInt]]("version").description("The revision is used to verify the client is working with the latest version of the flow."))
      .in(query[Option[ClientIdParameterStr]]("clientId").description("If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response."))
      .in(query[Option[Boolean]]("disconnectedNodeAcknowledged").description("Acknowledges that this node is disconnected to allow for mutable requests to proceed."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ProcessGroupEntity].description(""))
      .tags(List("ProcessGroups"))
  
  type GetConnectionsEndpoint = Endpoint[Unit, String, Unit, ConnectionsEntity, Any]
  lazy val getConnections: GetConnectionsEndpoint =
    endpoint
      .name("getConnections")
      .get
      .in(("process-groups" / path[String]("id").description("The process group id.") / "connections"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ConnectionsEntity].description(""))
      .tags(List("ProcessGroups"))
  
  type CreateConnectionEndpoint = Endpoint[Unit, (String, ConnectionEntity), Unit, ConnectionEntity, Any]
  lazy val createConnection: CreateConnectionEndpoint =
    endpoint
      .name("createConnection")
      .post
      .in(("process-groups" / path[String]("id").description("The process group id.") / "connections"))
      .in(jsonBody[ConnectionEntity].description("The connection configuration details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ConnectionEntity].description("").and(statusCode(sttp.model.StatusCode(201))))
      .tags(List("ProcessGroups"))
  
  type CreateControllerService_1Endpoint = Endpoint[Unit, (String, ControllerServiceEntity), Unit, ControllerServiceEntity, Any]
  lazy val createControllerService_1: CreateControllerService_1Endpoint =
    endpoint
      .name("createControllerService_1")
      .post
      .in(("process-groups" / path[String]("id").description("The process group id.") / "controller-services"))
      .in(jsonBody[ControllerServiceEntity].description("The controller service configuration details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ControllerServiceEntity].description("").and(statusCode(sttp.model.StatusCode(201))))
      .tags(List("ProcessGroups"))
  
  type CopyEndpoint = Endpoint[Unit, (String, CopyRequestEntity), Unit, CopyResponseEntity, Any]
  lazy val copy: CopyEndpoint =
    endpoint
      .name("copy")
      .post
      .in(("process-groups" / path[String]("id").description("The process group id.") / "copy"))
      .in(jsonBody[CopyRequestEntity].description("The request including the components to be copied from the specified Process Group."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[CopyResponseEntity].description(""))
      .tags(List("ProcessGroups"))
  
  type ExportProcessGroupEndpoint = Endpoint[Unit, (String, Option[Boolean]), Unit, String, Any]
  lazy val exportProcessGroup: ExportProcessGroupEndpoint =
    endpoint
      .name("exportProcessGroup")
      .get
      .in(("process-groups" / path[String]("id").description("The process group id.") / "download"))
      .in(query[Option[Boolean]]("includeReferencedServices").description("If referenced services from outside the target group should be included"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[String].description(""))
      .tags(List("ProcessGroups"))
  
  type CreateEmptyAllConnectionsRequestEndpoint = Endpoint[Unit, String, Unit, DropRequestEntity, Any]
  lazy val createEmptyAllConnectionsRequest: CreateEmptyAllConnectionsRequestEndpoint =
    endpoint
      .name("createEmptyAllConnectionsRequest")
      .post
      .in(("process-groups" / path[String]("id").description("The process group id.") / "empty-all-connections-requests"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[DropRequestEntity].description("The request has been accepted. An HTTP response header will contain the URI where the status can be polled.").and(statusCode(sttp.model.StatusCode(202))))
      .tags(List("ProcessGroups"))
  
  type GetDropAllFlowfilesRequestEndpoint = Endpoint[Unit, (String, String), Unit, DropRequestEntity, Any]
  lazy val getDropAllFlowfilesRequest: GetDropAllFlowfilesRequestEndpoint =
    endpoint
      .name("getDropAllFlowfilesRequest")
      .get
      .in(("process-groups" / path[String]("id").description("The process group id.") / "empty-all-connections-requests" / path[String]("drop-request-id").description("The drop request id.")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[DropRequestEntity].description(""))
      .tags(List("ProcessGroups"))
  
  type RemoveDropRequest_1Endpoint = Endpoint[Unit, (String, String), Unit, DropRequestEntity, Any]
  lazy val removeDropRequest_1: RemoveDropRequest_1Endpoint =
    endpoint
      .name("removeDropRequest_1")
      .delete
      .in(("process-groups" / path[String]("id").description("The process group id.") / "empty-all-connections-requests" / path[String]("drop-request-id").description("The drop request id.")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[DropRequestEntity].description(""))
      .tags(List("ProcessGroups"))
  
  type ReplaceProcessGroupEndpoint = Endpoint[Unit, (String, ProcessGroupImportEntity), Unit, ProcessGroupImportEntity, Any]
  lazy val replaceProcessGroup: ReplaceProcessGroupEndpoint =
    endpoint
      .name("replaceProcessGroup")
      .put
      .in(("process-groups" / path[String]("id").description("The process group id.") / "flow-contents"))
      .in(jsonBody[ProcessGroupImportEntity].description("The process group replace request entity."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ProcessGroupImportEntity].description(""))
      .tags(List("ProcessGroups"))
  
  type GetFunnelsEndpoint = Endpoint[Unit, String, Unit, FunnelsEntity, Any]
  lazy val getFunnels: GetFunnelsEndpoint =
    endpoint
      .name("getFunnels")
      .get
      .in(("process-groups" / path[String]("id").description("The process group id.") / "funnels"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[FunnelsEntity].description(""))
      .tags(List("ProcessGroups"))
  
  type CreateFunnelEndpoint = Endpoint[Unit, (String, FunnelEntity), Unit, FunnelEntity, Any]
  lazy val createFunnel: CreateFunnelEndpoint =
    endpoint
      .name("createFunnel")
      .post
      .in(("process-groups" / path[String]("id").description("The process group id.") / "funnels"))
      .in(jsonBody[FunnelEntity].description("The funnel configuration details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[FunnelEntity].description("").and(statusCode(sttp.model.StatusCode(201))))
      .tags(List("ProcessGroups"))
  
  type GetInputPortsEndpoint = Endpoint[Unit, String, Unit, InputPortsEntity, Any]
  lazy val getInputPorts: GetInputPortsEndpoint =
    endpoint
      .name("getInputPorts")
      .get
      .in(("process-groups" / path[String]("id").description("The process group id.") / "input-ports"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[InputPortsEntity].description(""))
      .tags(List("ProcessGroups"))
  
  type CreateInputPortEndpoint = Endpoint[Unit, (String, PortEntity), Unit, PortEntity, Any]
  lazy val createInputPort: CreateInputPortEndpoint =
    endpoint
      .name("createInputPort")
      .post
      .in(("process-groups" / path[String]("id").description("The process group id.") / "input-ports"))
      .in(jsonBody[PortEntity].description("The input port configuration details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[PortEntity].description("").and(statusCode(sttp.model.StatusCode(201))))
      .tags(List("ProcessGroups"))
  
  type GetLabelsEndpoint = Endpoint[Unit, String, Unit, LabelsEntity, Any]
  lazy val getLabels: GetLabelsEndpoint =
    endpoint
      .name("getLabels")
      .get
      .in(("process-groups" / path[String]("id").description("The process group id.") / "labels"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[LabelsEntity].description(""))
      .tags(List("ProcessGroups"))
  
  type CreateLabelEndpoint = Endpoint[Unit, (String, LabelEntity), Unit, LabelEntity, Any]
  lazy val createLabel: CreateLabelEndpoint =
    endpoint
      .name("createLabel")
      .post
      .in(("process-groups" / path[String]("id").description("The process group id.") / "labels"))
      .in(jsonBody[LabelEntity].description("The label configuration details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[LabelEntity].description("").and(statusCode(sttp.model.StatusCode(201))))
      .tags(List("ProcessGroups"))
  
  type GetLocalModificationsEndpoint = Endpoint[Unit, String, Unit, FlowComparisonEntity, Any]
  lazy val getLocalModifications: GetLocalModificationsEndpoint =
    endpoint
      .name("getLocalModifications")
      .get
      .in(("process-groups" / path[String]("id").description("The process group id.") / "local-modifications"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[FlowComparisonEntity].description(""))
      .tags(List("ProcessGroups"))
  
  type GetOutputPortsEndpoint = Endpoint[Unit, String, Unit, OutputPortsEntity, Any]
  lazy val getOutputPorts: GetOutputPortsEndpoint =
    endpoint
      .name("getOutputPorts")
      .get
      .in(("process-groups" / path[String]("id").description("The process group id.") / "output-ports"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[OutputPortsEntity].description(""))
      .tags(List("ProcessGroups"))
  
  type CreateOutputPortEndpoint = Endpoint[Unit, (String, PortEntity), Unit, PortEntity, Any]
  lazy val createOutputPort: CreateOutputPortEndpoint =
    endpoint
      .name("createOutputPort")
      .post
      .in(("process-groups" / path[String]("id").description("The process group id.") / "output-ports"))
      .in(jsonBody[PortEntity].description("The output port configuration."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[PortEntity].description("").and(statusCode(sttp.model.StatusCode(201))))
      .tags(List("ProcessGroups"))
  
  type PasteEndpoint = Endpoint[Unit, (String, PasteRequestEntity), Unit, PasteResponseEntity, Any]
  lazy val paste: PasteEndpoint =
    endpoint
      .name("paste")
      .put
      .in(("process-groups" / path[String]("id").description("The process group id.") / "paste"))
      .in(jsonBody[PasteRequestEntity].description("The request including the components to be pasted into the specified Process Group."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[PasteResponseEntity].description(""))
      .tags(List("ProcessGroups"))
  
  type GetProcessGroupsEndpoint = Endpoint[Unit, String, Unit, ProcessGroupsEntity, Any]
  lazy val getProcessGroups: GetProcessGroupsEndpoint =
    endpoint
      .name("getProcessGroups")
      .get
      .in(("process-groups" / path[String]("id").description("The process group id.") / "process-groups"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ProcessGroupsEntity].description(""))
      .tags(List("ProcessGroups"))
  
  type CreateProcessGroupEndpoint = Endpoint[Unit, (String, Option[CreateProcessGroupParameterContextHandlingStrategy], ProcessGroupEntity), Unit, ProcessGroupEntity, Any]
  lazy val createProcessGroup: CreateProcessGroupEndpoint =
    endpoint
      .name("createProcessGroup")
      .post
      .in(("process-groups" / path[String]("id").description("The process group id.") / "process-groups"))
      .in(query[Option[CreateProcessGroupParameterContextHandlingStrategy]]("parameterContextHandlingStrategy").description("Handling Strategy controls whether to keep or replace Parameter Contexts"))
      .in(jsonBody[ProcessGroupEntity].description("The process group configuration details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ProcessGroupEntity].description("").and(statusCode(sttp.model.StatusCode(201))))
      .tags(List("ProcessGroups"))
  
  sealed trait CreateProcessGroupParameterContextHandlingStrategy extends enumeratum.EnumEntry
  object CreateProcessGroupParameterContextHandlingStrategy extends enumeratum.Enum[CreateProcessGroupParameterContextHandlingStrategy] with enumeratum.CirceEnum[CreateProcessGroupParameterContextHandlingStrategy] {
    val values = findValues
    case object KEEP_EXISTING extends CreateProcessGroupParameterContextHandlingStrategy
    case object REPLACE extends CreateProcessGroupParameterContextHandlingStrategy
    implicit val enumCodecSupportCreateProcessGroupParameterContextHandlingStrategy: ExtraParamSupport[CreateProcessGroupParameterContextHandlingStrategy] =
      extraCodecSupport[CreateProcessGroupParameterContextHandlingStrategy]("CreateProcessGroupParameterContextHandlingStrategy", CreateProcessGroupParameterContextHandlingStrategy)
  }
  
  type ImportProcessGroupEndpoint = Endpoint[Unit, (String, Option[ProcessGroupUploadEntity]), Unit, ProcessGroupEntity, Any]
  lazy val importProcessGroup: ImportProcessGroupEndpoint =
    endpoint
      .name("importProcessGroup")
      .post
      .in(("process-groups" / path[String]("id").description("The process group id.") / "process-groups" / "import"))
      .in(jsonBody[Option[ProcessGroupUploadEntity]])
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ProcessGroupEntity].description("").and(statusCode(sttp.model.StatusCode(201))))
      .tags(List("ProcessGroups"))
  
  type UploadProcessGroupEndpoint = Endpoint[Unit, (String, UploadProcessGroupRequest), Unit, ProcessGroupEntity, Any]
  lazy val uploadProcessGroup: UploadProcessGroupEndpoint =
    endpoint
      .name("uploadProcessGroup")
      .post
      .in(("process-groups" / path[String]("id").description("The process group id.") / "process-groups" / "upload"))
      .in(multipartBody[UploadProcessGroupRequest])
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ProcessGroupEntity].description("").and(statusCode(sttp.model.StatusCode(201))))
      .tags(List("ProcessGroups"))
  
  type GetProcessorsEndpoint = Endpoint[Unit, (String, Option[Boolean]), Unit, ProcessorsEntity, Any]
  lazy val getProcessors: GetProcessorsEndpoint =
    endpoint
      .name("getProcessors")
      .get
      .in(("process-groups" / path[String]("id").description("The process group id.") / "processors"))
      .in(query[Option[Boolean]]("includeDescendantGroups").description("Whether or not to include processors from descendant process groups"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ProcessorsEntity].description(""))
      .tags(List("ProcessGroups"))
  
  type CreateProcessorEndpoint = Endpoint[Unit, (String, ProcessorEntity), Unit, ProcessorEntity, Any]
  lazy val createProcessor: CreateProcessorEndpoint =
    endpoint
      .name("createProcessor")
      .post
      .in(("process-groups" / path[String]("id").description("The process group id.") / "processors"))
      .in(jsonBody[ProcessorEntity].description("The processor configuration details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ProcessorEntity].description("").and(statusCode(sttp.model.StatusCode(201))))
      .tags(List("ProcessGroups"))
  
  type GetRemoteProcessGroupsEndpoint = Endpoint[Unit, String, Unit, RemoteProcessGroupsEntity, Any]
  lazy val getRemoteProcessGroups: GetRemoteProcessGroupsEndpoint =
    endpoint
      .name("getRemoteProcessGroups")
      .get
      .in(("process-groups" / path[String]("id").description("The process group id.") / "remote-process-groups"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[RemoteProcessGroupsEntity].description(""))
      .tags(List("ProcessGroups"))
  
  type CreateRemoteProcessGroupEndpoint = Endpoint[Unit, (String, RemoteProcessGroupEntity), Unit, RemoteProcessGroupEntity, Any]
  lazy val createRemoteProcessGroup: CreateRemoteProcessGroupEndpoint =
    endpoint
      .name("createRemoteProcessGroup")
      .post
      .in(("process-groups" / path[String]("id").description("The process group id.") / "remote-process-groups"))
      .in(jsonBody[RemoteProcessGroupEntity].description("The remote process group configuration details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[RemoteProcessGroupEntity].description("").and(statusCode(sttp.model.StatusCode(201))))
      .tags(List("ProcessGroups"))
  
  type InitiateReplaceProcessGroupEndpoint = Endpoint[Unit, (String, ProcessGroupImportEntity), Unit, ProcessGroupReplaceRequestEntity, Any]
  lazy val initiateReplaceProcessGroup: InitiateReplaceProcessGroupEndpoint =
    endpoint
      .name("initiateReplaceProcessGroup")
      .post
      .in(("process-groups" / path[String]("id").description("The process group id.") / "replace-requests"))
      .in(jsonBody[ProcessGroupImportEntity].description("The process group replace request entity"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ProcessGroupReplaceRequestEntity].description(""))
      .tags(List("ProcessGroups"))
  
  type CopySnippetEndpoint = Endpoint[Unit, (String, CopySnippetRequestEntity), Unit, FlowEntity, Any]
  lazy val copySnippet: CopySnippetEndpoint =
    endpoint
      .name("copySnippet")
      .post
      .in(("process-groups" / path[String]("id").description("The process group id.") / "snippet-instance"))
      .in(jsonBody[CopySnippetRequestEntity].description("The copy snippet request."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[FlowEntity].description("").and(statusCode(sttp.model.StatusCode(201))))
      .tags(List("ProcessGroups"))
  
  type GetProcessorRunStatusDetailsEndpoint = Endpoint[Unit, GetProcessorRunStatusDetailsBodyIn, Unit, ProcessorsRunStatusDetailsEntity, Any]
  lazy val getProcessorRunStatusDetails: GetProcessorRunStatusDetailsEndpoint =
    endpoint
      .name("getProcessorRunStatusDetails")
      .post
      .in(("processors" / "run-status-details" / "queries"))
      .in(oneOfBody[GetProcessorRunStatusDetailsBodyIn](
        EndpointIO.Body(RawBodyType.ByteArrayBody, Codec.id[Array[Byte], `*/*CodecFormat`](`*/*CodecFormat`(), Schema.schemaForByteArray), EndpointIO.Info.empty).map(GetProcessorRunStatusDetailsBody0In(_))(_.value).widenBody[GetProcessorRunStatusDetailsBodyIn].description("The request for the processors that should be included in the results"),
        jsonBody[Option[RunStatusDetailsRequestEntity]].map(GetProcessorRunStatusDetailsBodyOption_RunStatusDetailsRequestEntity_In(_))(_.value).widenBody[GetProcessorRunStatusDetailsBodyIn].description("The request for the processors that should be included in the results")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ProcessorsRunStatusDetailsEntity].description(""))
      .tags(List("Processors"))
  
  type GetProcessorEndpoint = Endpoint[Unit, String, Unit, ProcessorEntity, Any]
  lazy val getProcessor: GetProcessorEndpoint =
    endpoint
      .name("getProcessor")
      .get
      .in(("processors" / path[String]("id").description("The processor id.")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ProcessorEntity].description(""))
      .tags(List("Processors"))
  
  type UpdateProcessorEndpoint = Endpoint[Unit, (String, ProcessorEntity), Unit, ProcessorEntity, Any]
  lazy val updateProcessor: UpdateProcessorEndpoint =
    endpoint
      .name("updateProcessor")
      .put
      .in(("processors" / path[String]("id").description("The processor id.")))
      .in(jsonBody[ProcessorEntity].description("The processor configuration details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ProcessorEntity].description(""))
      .tags(List("Processors"))
  
  type DeleteProcessorEndpoint = Endpoint[Unit, (String, Option[LongParameterInt], Option[ClientIdParameterStr], Option[Boolean]), Unit, ProcessorEntity, Any]
  lazy val deleteProcessor: DeleteProcessorEndpoint =
    endpoint
      .name("deleteProcessor")
      .delete
      .in(("processors" / path[String]("id").description("The processor id.")))
      .in(query[Option[LongParameterInt]]("version").description("The revision is used to verify the client is working with the latest version of the flow."))
      .in(query[Option[ClientIdParameterStr]]("clientId").description("If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response."))
      .in(query[Option[Boolean]]("disconnectedNodeAcknowledged").description("Acknowledges that this node is disconnected to allow for mutable requests to proceed."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ProcessorEntity].description(""))
      .tags(List("Processors"))
  
  type AnalyzeConfiguration_2Endpoint = Endpoint[Unit, (String, ConfigurationAnalysisEntity), Unit, ConfigurationAnalysisEntity, Any]
  lazy val analyzeConfiguration_2: AnalyzeConfiguration_2Endpoint =
    endpoint
      .name("analyzeConfiguration_2")
      .post
      .in(("processors" / path[String]("id").description("The processor id.") / "config" / "analysis"))
      .in(jsonBody[ConfigurationAnalysisEntity].description("The processor configuration analysis request."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ConfigurationAnalysisEntity].description(""))
      .tags(List("Processors"))
  
  type SubmitProcessorVerificationRequestEndpoint = Endpoint[Unit, (String, VerifyConfigRequestEntity), Unit, VerifyConfigRequestEntity, Any]
  lazy val submitProcessorVerificationRequest: SubmitProcessorVerificationRequestEndpoint =
    endpoint
      .name("submitProcessorVerificationRequest")
      .post
      .in(("processors" / path[String]("id").description("The processor id.") / "config" / "verification-requests"))
      .in(jsonBody[VerifyConfigRequestEntity].description("The processor configuration verification request."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[VerifyConfigRequestEntity].description(""))
      .tags(List("Processors"))
  
  type GetVerificationRequest_2Endpoint = Endpoint[Unit, (String, String), Unit, VerifyConfigRequestEntity, Any]
  lazy val getVerificationRequest_2: GetVerificationRequest_2Endpoint =
    endpoint
      .name("getVerificationRequest_2")
      .get
      .in(("processors" / path[String]("id").description("The ID of the Processor") / "config" / "verification-requests" / path[String]("requestId").description("The ID of the Verification Request")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[VerifyConfigRequestEntity].description(""))
      .tags(List("Processors"))
  
  type DeleteVerificationRequest_2Endpoint = Endpoint[Unit, (String, String), Unit, VerifyConfigRequestEntity, Any]
  lazy val deleteVerificationRequest_2: DeleteVerificationRequest_2Endpoint =
    endpoint
      .name("deleteVerificationRequest_2")
      .delete
      .in(("processors" / path[String]("id").description("The ID of the Processor") / "config" / "verification-requests" / path[String]("requestId").description("The ID of the Verification Request")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[VerifyConfigRequestEntity].description(""))
      .tags(List("Processors"))
  
  type GetPropertyDescriptor_3Endpoint = Endpoint[Unit, (String, Option[ClientIdParameterStr], String, Option[Boolean]), Unit, PropertyDescriptorEntity, Any]
  lazy val getPropertyDescriptor_3: GetPropertyDescriptor_3Endpoint =
    endpoint
      .name("getPropertyDescriptor_3")
      .get
      .in(("processors" / path[String]("id").description("The processor id.") / "descriptors"))
      .in(query[Option[ClientIdParameterStr]]("clientId").description("If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response."))
      .in(query[String]("propertyName").description("The property name."))
      .in(query[Option[Boolean]]("sensitive").description("Property Descriptor requested sensitive status"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[PropertyDescriptorEntity].description(""))
      .tags(List("Processors"))
  
  type GetProcessorDiagnosticsEndpoint = Endpoint[Unit, String, Unit, ProcessorEntity, Any]
  lazy val getProcessorDiagnostics: GetProcessorDiagnosticsEndpoint =
    endpoint
      .name("getProcessorDiagnostics")
      .get
      .in(("processors" / path[String]("id").description("The processor id.") / "diagnostics"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ProcessorEntity].description(""))
      .tags(List("Processors"))
  
  type UpdateRunStatus_4Endpoint = Endpoint[Unit, (String, ProcessorRunStatusEntity), Unit, ProcessorEntity, Any]
  lazy val updateRunStatus_4: UpdateRunStatus_4Endpoint =
    endpoint
      .name("updateRunStatus_4")
      .put
      .in(("processors" / path[String]("id").description("The processor id.") / "run-status"))
      .in(jsonBody[ProcessorRunStatusEntity].description("The processor run status."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ProcessorEntity].description(""))
      .tags(List("Processors"))
  
  type GetState_2Endpoint = Endpoint[Unit, String, Unit, ComponentStateEntity, Any]
  lazy val getState_2: GetState_2Endpoint =
    endpoint
      .name("getState_2")
      .get
      .in(("processors" / path[String]("id").description("The processor id.") / "state"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ComponentStateEntity].description(""))
      .tags(List("Processors"))
  
  type ClearState_3Endpoint = Endpoint[Unit, (String, ClearState_3BodyIn), Unit, ComponentStateEntity, Any]
  lazy val clearState_3: ClearState_3Endpoint =
    endpoint
      .name("clearState_3")
      .post
      .in(("processors" / path[String]("id").description("The processor id.") / "state" / "clear-requests"))
      .in(oneOfBody[ClearState_3BodyIn](
        EndpointIO.Body(RawBodyType.ByteArrayBody, Codec.id[Array[Byte], `*/*CodecFormat`](`*/*CodecFormat`(), Schema.schemaForByteArray), EndpointIO.Info.empty).map(ClearState_3Body0In(_))(_.value).widenBody[ClearState_3BodyIn].description("Optional component state to perform a selective key removal. If omitted, clears all state."),
        jsonBody[Option[ComponentStateEntity]].map(ClearState_3BodyOption_ComponentStateEntity_In(_))(_.value).widenBody[ClearState_3BodyIn].description("Optional component state to perform a selective key removal. If omitted, clears all state.")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ComponentStateEntity].description(""))
      .tags(List("Processors"))
  
  type TerminateProcessorEndpoint = Endpoint[Unit, String, Unit, ProcessorEntity, Any]
  lazy val terminateProcessor: TerminateProcessorEndpoint =
    endpoint
      .name("terminateProcessor")
      .delete
      .in(("processors" / path[String]("id").description("The processor id.") / "threads"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ProcessorEntity].description(""))
      .tags(List("Processors"))
  
  type SubmitProvenanceRequestEndpoint = Endpoint[Unit, ProvenanceEntity, Unit, ProvenanceEntity, Any]
  lazy val submitProvenanceRequest: SubmitProvenanceRequestEndpoint =
    endpoint
      .name("submitProvenanceRequest")
      .post
      .in(("provenance"))
      .in(jsonBody[ProvenanceEntity].description("The provenance query details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ProvenanceEntity].description("").and(statusCode(sttp.model.StatusCode(201))))
      .tags(List("Provenance"))
  
  type SubmitReplayLatestEventEndpoint = Endpoint[Unit, ReplayLastEventRequestEntity, Unit, ReplayLastEventResponseEntity, Any]
  lazy val submitReplayLatestEvent: SubmitReplayLatestEventEndpoint =
    endpoint
      .name("submitReplayLatestEvent")
      .post
      .in(("provenance-events" / "latest" / "replays"))
      .in(jsonBody[ReplayLastEventRequestEntity].description("The replay request."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ReplayLastEventResponseEntity].description(""))
      .tags(List("ProvenanceEvents"))
  
  type GetLatestProvenanceEventsEndpoint = Endpoint[Unit, (String, Option[Int]), Unit, LatestProvenanceEventsEntity, Any]
  lazy val getLatestProvenanceEvents: GetLatestProvenanceEventsEndpoint =
    endpoint
      .name("getLatestProvenanceEvents")
      .get
      .in(("provenance-events" / "latest" / path[String]("componentId").description("The ID of the component to retrieve the latest Provenance Events for.")))
      .in(query[Option[Int]]("limit").description("The number of events to limit the response to. Defaults to 10."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[LatestProvenanceEventsEntity].description(""))
      .tags(List("ProvenanceEvents"))
  
  type SubmitReplayEndpoint = Endpoint[Unit, SubmitReplayRequestEntity, Unit, ProvenanceEventEntity, Any]
  lazy val submitReplay: SubmitReplayEndpoint =
    endpoint
      .name("submitReplay")
      .post
      .in(("provenance-events" / "replays"))
      .in(jsonBody[SubmitReplayRequestEntity].description("The replay request."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ProvenanceEventEntity].description("").and(statusCode(sttp.model.StatusCode(201))))
      .tags(List("ProvenanceEvents"))
  
  type GetProvenanceEventEndpoint = Endpoint[Unit, (LongParameterInt, Option[String]), Unit, ProvenanceEventEntity, Any]
  lazy val getProvenanceEvent: GetProvenanceEventEndpoint =
    endpoint
      .name("getProvenanceEvent")
      .get
      .in(("provenance-events" / path[LongParameterInt]("id").description("The provenance event id.")))
      .in(query[Option[String]]("clusterNodeId").description("The id of the node where this event exists if clustered."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ProvenanceEventEntity].description(""))
      .tags(List("ProvenanceEvents"))
  
  type GetInputContentEndpoint = Endpoint[Unit, (LongParameterInt, Option[String], Option[String]), Unit, Option[sttp.capabilities.pekko.PekkoStreams.BinaryStream], sttp.capabilities.pekko.PekkoStreams]
  lazy val getInputContent: GetInputContentEndpoint =
    endpoint
      .name("getInputContent")
      .get
      .in(("provenance-events" / path[LongParameterInt]("id").description("The provenance event id.") / "content" / "input"))
      .in(header[Option[String]]("Range").description("Range of bytes requested"))
      .in(query[Option[String]]("clusterNodeId").description("The id of the node where the content exists if clustered."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(416), emptyOutput.description("Requested Range Not Satisfiable based on bytes requested"))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(oneOf[Option[sttp.capabilities.pekko.PekkoStreams.BinaryStream]](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(206), emptyOutput.description("Partial Content with range of bytes requested"))(None),
        oneOfVariantValueMatcher(sttp.model.StatusCode(200), streamBody(sttp.capabilities.pekko.PekkoStreams)(Schema.binary[StreamingOutput], `*/*CodecFormat`()).description("").toEndpointIO.map(Some(_))(_.orNull)){ case Some(_: sttp.capabilities.pekko.PekkoStreams.BinaryStream) => true }))
      .tags(List("ProvenanceEvents"))
  
  type GetOutputContentEndpoint = Endpoint[Unit, (LongParameterInt, Option[String], Option[String]), Unit, Option[sttp.capabilities.pekko.PekkoStreams.BinaryStream], sttp.capabilities.pekko.PekkoStreams]
  lazy val getOutputContent: GetOutputContentEndpoint =
    endpoint
      .name("getOutputContent")
      .get
      .in(("provenance-events" / path[LongParameterInt]("id").description("The provenance event id.") / "content" / "output"))
      .in(header[Option[String]]("Range").description("Range of bytes requested"))
      .in(query[Option[String]]("clusterNodeId").description("The id of the node where the content exists if clustered."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(416), emptyOutput.description("Requested Range Not Satisfiable based on bytes requested"))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(oneOf[Option[sttp.capabilities.pekko.PekkoStreams.BinaryStream]](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(206), emptyOutput.description("Partial Content with range of bytes requested"))(None),
        oneOfVariantValueMatcher(sttp.model.StatusCode(200), streamBody(sttp.capabilities.pekko.PekkoStreams)(Schema.binary[StreamingOutput], `*/*CodecFormat`()).description("").toEndpointIO.map(Some(_))(_.orNull)){ case Some(_: sttp.capabilities.pekko.PekkoStreams.BinaryStream) => true }))
      .tags(List("ProvenanceEvents"))
  
  type SubmitLineageRequestEndpoint = Endpoint[Unit, LineageEntity, Unit, LineageEntity, Any]
  lazy val submitLineageRequest: SubmitLineageRequestEndpoint =
    endpoint
      .name("submitLineageRequest")
      .post
      .in(("provenance" / "lineage"))
      .in(jsonBody[LineageEntity].description("The lineage query details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[LineageEntity].description("").and(statusCode(sttp.model.StatusCode(201))))
      .tags(List("Provenance"))
  
  type GetLineageEndpoint = Endpoint[Unit, (String, Option[String]), Unit, LineageEntity, Any]
  lazy val getLineage: GetLineageEndpoint =
    endpoint
      .name("getLineage")
      .get
      .in(("provenance" / "lineage" / path[String]("id").description("The id of the lineage query.")))
      .in(query[Option[String]]("clusterNodeId").description("The id of the node where this query exists if clustered."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[LineageEntity].description(""))
      .tags(List("Provenance"))
  
  type DeleteLineageEndpoint = Endpoint[Unit, (String, Option[String]), Unit, LineageEntity, Any]
  lazy val deleteLineage: DeleteLineageEndpoint =
    endpoint
      .name("deleteLineage")
      .delete
      .in(("provenance" / "lineage" / path[String]("id").description("The id of the lineage query.")))
      .in(query[Option[String]]("clusterNodeId").description("The id of the node where this query exists if clustered."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[LineageEntity].description(""))
      .tags(List("Provenance"))
  
  type GetSearchOptionsEndpoint = Endpoint[Unit, Unit, Unit, ProvenanceOptionsEntity, Any]
  lazy val getSearchOptions: GetSearchOptionsEndpoint =
    endpoint
      .name("getSearchOptions")
      .get
      .in(("provenance" / "search-options"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ProvenanceOptionsEntity].description(""))
      .tags(List("Provenance"))
  
  type GetProvenanceEndpoint = Endpoint[Unit, (String, Option[String], Option[Boolean], Option[Boolean]), Unit, ProvenanceEntity, Any]
  lazy val getProvenance: GetProvenanceEndpoint =
    endpoint
      .name("getProvenance")
      .get
      .in(("provenance" / path[String]("id").description("The id of the provenance query.")))
      .in(query[Option[String]]("clusterNodeId").description("The id of the node where this query exists if clustered."))
      .in(query[Option[Boolean]]("summarize").description("Whether or not incremental results are returned. If false, provenance events are only returned once the query completes. This property is true by default."))
      .in(query[Option[Boolean]]("incrementalResults").description("Whether or not to summarize provenance events returned. This property is false by default."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ProvenanceEntity].description(""))
      .tags(List("Provenance"))
  
  type DeleteProvenanceEndpoint = Endpoint[Unit, (String, Option[String]), Unit, ProvenanceEntity, Any]
  lazy val deleteProvenance: DeleteProvenanceEndpoint =
    endpoint
      .name("deleteProvenance")
      .delete
      .in(("provenance" / path[String]("id").description("The id of the provenance query.")))
      .in(query[Option[String]]("clusterNodeId").description("The id of the node where this query exists if clustered."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ProvenanceEntity].description(""))
      .tags(List("Provenance"))
  
  type UpdateRemoteProcessGroupRunStatusesEndpoint = Endpoint[Unit, (String, RemotePortRunStatusEntity), Unit, RemoteProcessGroupEntity, Any]
  lazy val updateRemoteProcessGroupRunStatuses: UpdateRemoteProcessGroupRunStatusesEndpoint =
    endpoint
      .name("updateRemoteProcessGroupRunStatuses")
      .put
      .in(("remote-process-groups" / "process-group" / path[String]("id").description("The process group id.") / "run-status"))
      .in(jsonBody[RemotePortRunStatusEntity].description("The remote process groups run status."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[RemoteProcessGroupEntity].description(""))
      .tags(List("RemoteProcessGroups"))
  
  type GetRemoteProcessGroupEndpoint = Endpoint[Unit, String, Unit, RemoteProcessGroupEntity, Any]
  lazy val getRemoteProcessGroup: GetRemoteProcessGroupEndpoint =
    endpoint
      .name("getRemoteProcessGroup")
      .get
      .in(("remote-process-groups" / path[String]("id").description("The remote process group id.")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[RemoteProcessGroupEntity].description(""))
      .tags(List("RemoteProcessGroups"))
  
  type UpdateRemoteProcessGroupEndpoint = Endpoint[Unit, (String, RemoteProcessGroupEntity), Unit, RemoteProcessGroupEntity, Any]
  lazy val updateRemoteProcessGroup: UpdateRemoteProcessGroupEndpoint =
    endpoint
      .name("updateRemoteProcessGroup")
      .put
      .in(("remote-process-groups" / path[String]("id").description("The remote process group id.")))
      .in(jsonBody[RemoteProcessGroupEntity].description("The remote process group."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[RemoteProcessGroupEntity].description(""))
      .tags(List("RemoteProcessGroups"))
  
  type RemoveRemoteProcessGroupEndpoint = Endpoint[Unit, (String, Option[LongParameterInt], Option[ClientIdParameterStr], Option[Boolean]), Unit, RemoteProcessGroupEntity, Any]
  lazy val removeRemoteProcessGroup: RemoveRemoteProcessGroupEndpoint =
    endpoint
      .name("removeRemoteProcessGroup")
      .delete
      .in(("remote-process-groups" / path[String]("id").description("The remote process group id.")))
      .in(query[Option[LongParameterInt]]("version").description("The revision is used to verify the client is working with the latest version of the flow."))
      .in(query[Option[ClientIdParameterStr]]("clientId").description("If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response."))
      .in(query[Option[Boolean]]("disconnectedNodeAcknowledged").description("Acknowledges that this node is disconnected to allow for mutable requests to proceed."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[RemoteProcessGroupEntity].description(""))
      .tags(List("RemoteProcessGroups"))
  
  type UpdateRemoteProcessGroupInputPortEndpoint = Endpoint[Unit, (String, String, RemoteProcessGroupPortEntity), Unit, RemoteProcessGroupPortEntity, Any]
  lazy val updateRemoteProcessGroupInputPort: UpdateRemoteProcessGroupInputPortEndpoint =
    endpoint
      .name("updateRemoteProcessGroupInputPort")
      .put
      .in(("remote-process-groups" / path[String]("id").description("The remote process group id.") / "input-ports" / path[String]("port-id").description("The remote process group port id.")))
      .in(jsonBody[RemoteProcessGroupPortEntity].description("The remote process group port."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[RemoteProcessGroupPortEntity].description(""))
      .tags(List("RemoteProcessGroups"))
  
  type UpdateRemoteProcessGroupInputPortRunStatusEndpoint = Endpoint[Unit, (String, String, RemotePortRunStatusEntity), Unit, RemoteProcessGroupPortEntity, Any]
  lazy val updateRemoteProcessGroupInputPortRunStatus: UpdateRemoteProcessGroupInputPortRunStatusEndpoint =
    endpoint
      .name("updateRemoteProcessGroupInputPortRunStatus")
      .put
      .in(("remote-process-groups" / path[String]("id").description("The remote process group id.") / "input-ports" / path[String]("port-id").description("The remote process group port id.") / "run-status"))
      .in(jsonBody[RemotePortRunStatusEntity].description("The remote process group port."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[RemoteProcessGroupPortEntity].description(""))
      .tags(List("RemoteProcessGroups"))
  
  type UpdateRemoteProcessGroupOutputPortEndpoint = Endpoint[Unit, (String, String, RemoteProcessGroupPortEntity), Unit, RemoteProcessGroupPortEntity, Any]
  lazy val updateRemoteProcessGroupOutputPort: UpdateRemoteProcessGroupOutputPortEndpoint =
    endpoint
      .name("updateRemoteProcessGroupOutputPort")
      .put
      .in(("remote-process-groups" / path[String]("id").description("The remote process group id.") / "output-ports" / path[String]("port-id").description("The remote process group port id.")))
      .in(jsonBody[RemoteProcessGroupPortEntity].description("The remote process group port."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[RemoteProcessGroupPortEntity].description(""))
      .tags(List("RemoteProcessGroups"))
  
  type UpdateRemoteProcessGroupOutputPortRunStatusEndpoint = Endpoint[Unit, (String, String, RemotePortRunStatusEntity), Unit, RemoteProcessGroupPortEntity, Any]
  lazy val updateRemoteProcessGroupOutputPortRunStatus: UpdateRemoteProcessGroupOutputPortRunStatusEndpoint =
    endpoint
      .name("updateRemoteProcessGroupOutputPortRunStatus")
      .put
      .in(("remote-process-groups" / path[String]("id").description("The remote process group id.") / "output-ports" / path[String]("port-id").description("The remote process group port id.") / "run-status"))
      .in(jsonBody[RemotePortRunStatusEntity].description("The remote process group port."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[RemoteProcessGroupPortEntity].description(""))
      .tags(List("RemoteProcessGroups"))
  
  type UpdateRemoteProcessGroupRunStatusEndpoint = Endpoint[Unit, (String, RemotePortRunStatusEntity), Unit, RemoteProcessGroupEntity, Any]
  lazy val updateRemoteProcessGroupRunStatus: UpdateRemoteProcessGroupRunStatusEndpoint =
    endpoint
      .name("updateRemoteProcessGroupRunStatus")
      .put
      .in(("remote-process-groups" / path[String]("id").description("The remote process group id.") / "run-status"))
      .in(jsonBody[RemotePortRunStatusEntity].description("The remote process group run status."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[RemoteProcessGroupEntity].description(""))
      .tags(List("RemoteProcessGroups"))
  
  type GetState_3Endpoint = Endpoint[Unit, String, Unit, ComponentStateEntity, Any]
  lazy val getState_3: GetState_3Endpoint =
    endpoint
      .name("getState_3")
      .get
      .in(("remote-process-groups" / path[String]("id").description("The processor id.") / "state"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ComponentStateEntity].description(""))
      .tags(List("RemoteProcessGroups"))
  
  type GetReportingTaskEndpoint = Endpoint[Unit, String, Unit, ReportingTaskEntity, Any]
  lazy val getReportingTask: GetReportingTaskEndpoint =
    endpoint
      .name("getReportingTask")
      .get
      .in(("reporting-tasks" / path[String]("id").description("The reporting task id.")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ReportingTaskEntity].description(""))
      .tags(List("ReportingTasks"))
  
  type UpdateReportingTaskEndpoint = Endpoint[Unit, (String, ReportingTaskEntity), Unit, ReportingTaskEntity, Any]
  lazy val updateReportingTask: UpdateReportingTaskEndpoint =
    endpoint
      .name("updateReportingTask")
      .put
      .in(("reporting-tasks" / path[String]("id").description("The reporting task id.")))
      .in(jsonBody[ReportingTaskEntity].description("The reporting task configuration details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ReportingTaskEntity].description(""))
      .tags(List("ReportingTasks"))
  
  type RemoveReportingTaskEndpoint = Endpoint[Unit, (String, Option[LongParameterInt], Option[ClientIdParameterStr], Option[Boolean]), Unit, ReportingTaskEntity, Any]
  lazy val removeReportingTask: RemoveReportingTaskEndpoint =
    endpoint
      .name("removeReportingTask")
      .delete
      .in(("reporting-tasks" / path[String]("id").description("The reporting task id.")))
      .in(query[Option[LongParameterInt]]("version").description("The revision is used to verify the client is working with the latest version of the flow."))
      .in(query[Option[ClientIdParameterStr]]("clientId").description("If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response."))
      .in(query[Option[Boolean]]("disconnectedNodeAcknowledged").description("Acknowledges that this node is disconnected to allow for mutable requests to proceed."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ReportingTaskEntity].description(""))
      .tags(List("ReportingTasks"))
  
  type AnalyzeConfiguration_3Endpoint = Endpoint[Unit, (String, ConfigurationAnalysisEntity), Unit, ConfigurationAnalysisEntity, Any]
  lazy val analyzeConfiguration_3: AnalyzeConfiguration_3Endpoint =
    endpoint
      .name("analyzeConfiguration_3")
      .post
      .in(("reporting-tasks" / path[String]("id").description("The reporting task id.") / "config" / "analysis"))
      .in(jsonBody[ConfigurationAnalysisEntity].description("The configuration analysis request."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ConfigurationAnalysisEntity].description(""))
      .tags(List("ReportingTasks"))
  
  type SubmitConfigVerificationRequest_2Endpoint = Endpoint[Unit, (String, VerifyConfigRequestEntity), Unit, VerifyConfigRequestEntity, Any]
  lazy val submitConfigVerificationRequest_2: SubmitConfigVerificationRequest_2Endpoint =
    endpoint
      .name("submitConfigVerificationRequest_2")
      .post
      .in(("reporting-tasks" / path[String]("id").description("The reporting task id.") / "config" / "verification-requests"))
      .in(jsonBody[VerifyConfigRequestEntity].description("The reporting task configuration verification request."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[VerifyConfigRequestEntity].description(""))
      .tags(List("ReportingTasks"))
  
  type GetVerificationRequest_3Endpoint = Endpoint[Unit, (String, String), Unit, VerifyConfigRequestEntity, Any]
  lazy val getVerificationRequest_3: GetVerificationRequest_3Endpoint =
    endpoint
      .name("getVerificationRequest_3")
      .get
      .in(("reporting-tasks" / path[String]("id").description("The ID of the Reporting Task") / "config" / "verification-requests" / path[String]("requestId").description("The ID of the Verification Request")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[VerifyConfigRequestEntity].description(""))
      .tags(List("ReportingTasks"))
  
  type DeleteVerificationRequest_3Endpoint = Endpoint[Unit, (String, String), Unit, VerifyConfigRequestEntity, Any]
  lazy val deleteVerificationRequest_3: DeleteVerificationRequest_3Endpoint =
    endpoint
      .name("deleteVerificationRequest_3")
      .delete
      .in(("reporting-tasks" / path[String]("id").description("The ID of the Reporting Task") / "config" / "verification-requests" / path[String]("requestId").description("The ID of the Verification Request")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[VerifyConfigRequestEntity].description(""))
      .tags(List("ReportingTasks"))
  
  type GetPropertyDescriptor_4Endpoint = Endpoint[Unit, (String, String, Option[Boolean]), Unit, PropertyDescriptorEntity, Any]
  lazy val getPropertyDescriptor_4: GetPropertyDescriptor_4Endpoint =
    endpoint
      .name("getPropertyDescriptor_4")
      .get
      .in(("reporting-tasks" / path[String]("id").description("The reporting task id.") / "descriptors"))
      .in(query[String]("propertyName").description("The property name."))
      .in(query[Option[Boolean]]("sensitive").description("Property Descriptor requested sensitive status"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[PropertyDescriptorEntity].description(""))
      .tags(List("ReportingTasks"))
  
  type UpdateRunStatus_5Endpoint = Endpoint[Unit, (String, ReportingTaskRunStatusEntity), Unit, ReportingTaskEntity, Any]
  lazy val updateRunStatus_5: UpdateRunStatus_5Endpoint =
    endpoint
      .name("updateRunStatus_5")
      .put
      .in(("reporting-tasks" / path[String]("id").description("The reporting task id.") / "run-status"))
      .in(jsonBody[ReportingTaskRunStatusEntity].description("The reporting task run status."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ReportingTaskEntity].description(""))
      .tags(List("ReportingTasks"))
  
  type GetState_4Endpoint = Endpoint[Unit, String, Unit, ComponentStateEntity, Any]
  lazy val getState_4: GetState_4Endpoint =
    endpoint
      .name("getState_4")
      .get
      .in(("reporting-tasks" / path[String]("id").description("The reporting task id.") / "state"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ComponentStateEntity].description(""))
      .tags(List("ReportingTasks"))
  
  type ClearState_4Endpoint = Endpoint[Unit, (String, ClearState_4BodyIn), Unit, ComponentStateEntity, Any]
  lazy val clearState_4: ClearState_4Endpoint =
    endpoint
      .name("clearState_4")
      .post
      .in(("reporting-tasks" / path[String]("id").description("The reporting task id.") / "state" / "clear-requests"))
      .in(oneOfBody[ClearState_4BodyIn](
        EndpointIO.Body(RawBodyType.ByteArrayBody, Codec.id[Array[Byte], `*/*CodecFormat`](`*/*CodecFormat`(), Schema.schemaForByteArray), EndpointIO.Info.empty).map(ClearState_4Body0In(_))(_.value).widenBody[ClearState_4BodyIn].description("Optional component state to perform a selective key removal. If omitted, clears all state."),
        jsonBody[Option[ComponentStateEntity]].map(ClearState_4BodyOption_ComponentStateEntity_In(_))(_.value).widenBody[ClearState_4BodyIn].description("Optional component state to perform a selective key removal. If omitted, clears all state.")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ComponentStateEntity].description(""))
      .tags(List("ReportingTasks"))
  
  type GetResourcesEndpoint = Endpoint[Unit, Unit, Unit, ResourcesEntity, Any]
  lazy val getResources: GetResourcesEndpoint =
    endpoint
      .name("getResources")
      .get
      .in(("resources"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(())))
      .out(jsonBody[ResourcesEntity].description(""))
      .tags(List("Resources"))
  
  type GetSiteToSiteDetailsEndpoint = Endpoint[Unit, Unit, Unit, ControllerEntity, Any]
  lazy val getSiteToSiteDetails: GetSiteToSiteDetailsEndpoint =
    endpoint
      .name("getSiteToSiteDetails")
      .get
      .in(("site-to-site"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[ControllerEntity].description(""))
      .tags(List("SiteToSite"))
  
  type GetPeersEndpoint = Endpoint[Unit, Unit, Unit, PeersEntity, Any]
  lazy val getPeers: GetPeersEndpoint =
    endpoint
      .name("getPeers")
      .get
      .in(("site-to-site" / "peers"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(oneOfBody[PeersEntity](
        jsonBody[PeersEntity].description(""),
        xmlBody[PeersEntity].description("")))
      .tags(List("SiteToSite"))
  
  type CreateSnippetEndpoint = Endpoint[Unit, SnippetEntity, Unit, SnippetEntity, Any]
  lazy val createSnippet: CreateSnippetEndpoint =
    endpoint
      .name("createSnippet")
      .post
      .in(("snippets"))
      .in(jsonBody[SnippetEntity].description("The snippet configuration details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[SnippetEntity].description("").and(statusCode(sttp.model.StatusCode(201))))
      .tags(List("Snippets"))
  
  type UpdateSnippetEndpoint = Endpoint[Unit, (String, SnippetEntity), Unit, SnippetEntity, Any]
  lazy val updateSnippet: UpdateSnippetEndpoint =
    endpoint
      .name("updateSnippet")
      .put
      .in(("snippets" / path[String]("id").description("The snippet id.")))
      .in(jsonBody[SnippetEntity].description("The snippet configuration details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[SnippetEntity].description(""))
      .tags(List("Snippets"))
  
  type DeleteSnippetEndpoint = Endpoint[Unit, (String, Option[Boolean]), Unit, SnippetEntity, Any]
  lazy val deleteSnippet: DeleteSnippetEndpoint =
    endpoint
      .name("deleteSnippet")
      .delete
      .in(("snippets" / path[String]("id").description("The snippet id.")))
      .in(query[Option[Boolean]]("disconnectedNodeAcknowledged").description("Acknowledges that this node is disconnected to allow for mutable requests to proceed."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[SnippetEntity].description(""))
      .tags(List("Snippets"))
  
  type GetSystemDiagnosticsEndpoint = Endpoint[Unit, (Option[Boolean], Option[GetSystemDiagnosticsDiagnosticLevel], Option[String]), Unit, SystemDiagnosticsEntity, Any]
  lazy val getSystemDiagnostics: GetSystemDiagnosticsEndpoint =
    endpoint
      .name("getSystemDiagnostics")
      .get
      .in(("system-diagnostics"))
      .in(query[Option[Boolean]]("nodewise").description("Whether or not to include the breakdown per node. Optional, defaults to false"))
      .in(query[Option[GetSystemDiagnosticsDiagnosticLevel]]("diagnosticLevel").description("Whether or not to include verbose details. Optional, defaults to false"))
      .in(query[Option[String]]("clusterNodeId").description("The id of the node where to get the status."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(())))
      .out(jsonBody[SystemDiagnosticsEntity].description(""))
      .tags(List("SystemDiagnostics"))
  
  sealed trait GetSystemDiagnosticsDiagnosticLevel extends enumeratum.EnumEntry
  object GetSystemDiagnosticsDiagnosticLevel extends enumeratum.Enum[GetSystemDiagnosticsDiagnosticLevel] with enumeratum.CirceEnum[GetSystemDiagnosticsDiagnosticLevel] {
    val values = findValues
    case object BASIC extends GetSystemDiagnosticsDiagnosticLevel
    case object VERBOSE extends GetSystemDiagnosticsDiagnosticLevel
    implicit val enumCodecSupportGetSystemDiagnosticsDiagnosticLevel: ExtraParamSupport[GetSystemDiagnosticsDiagnosticLevel] =
      extraCodecSupport[GetSystemDiagnosticsDiagnosticLevel]("GetSystemDiagnosticsDiagnosticLevel", GetSystemDiagnosticsDiagnosticLevel)
  }
  
  type GetJmxMetricsEndpoint = Endpoint[Unit, Option[String], Unit, JmxMetricsResultsEntity, Any]
  lazy val getJmxMetrics: GetJmxMetricsEndpoint =
    endpoint
      .name("getJmxMetrics")
      .get
      .in(("system-diagnostics" / "jmx-metrics"))
      .in(query[Option[String]]("beanNameFilter").description("Regular Expression Pattern to be applied against the ObjectName"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[JmxMetricsResultsEntity].description(""))
      .tags(List("SystemDiagnostics"))
  
  type SearchTenantsEndpoint = Endpoint[Unit, String, Unit, TenantsEntity, Any]
  lazy val searchTenants: SearchTenantsEndpoint =
    endpoint
      .name("searchTenants")
      .get
      .in(("tenants" / "search-results"))
      .in(query[String]("q").description("Identity to search for."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[TenantsEntity].description(""))
      .tags(List("Tenants"))
  
  type GetUserGroupsEndpoint = Endpoint[Unit, Unit, Unit, UserGroupsEntity, Any]
  lazy val getUserGroups: GetUserGroupsEndpoint =
    endpoint
      .name("getUserGroups")
      .get
      .in(("tenants" / "user-groups"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[UserGroupsEntity].description(""))
      .tags(List("Tenants"))
  
  type CreateUserGroupEndpoint = Endpoint[Unit, UserGroupEntity, Unit, UserGroupEntity, Any]
  lazy val createUserGroup: CreateUserGroupEndpoint =
    endpoint
      .name("createUserGroup")
      .post
      .in(("tenants" / "user-groups"))
      .in(jsonBody[UserGroupEntity].description("The user group configuration details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[UserGroupEntity].description("").and(statusCode(sttp.model.StatusCode(201))))
      .tags(List("Tenants"))
  
  type GetUserGroupEndpoint = Endpoint[Unit, String, Unit, UserGroupEntity, Any]
  lazy val getUserGroup: GetUserGroupEndpoint =
    endpoint
      .name("getUserGroup")
      .get
      .in(("tenants" / "user-groups" / path[String]("id").description("The user group id.")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[UserGroupEntity].description(""))
      .tags(List("Tenants"))
  
  type UpdateUserGroupEndpoint = Endpoint[Unit, (String, UserGroupEntity), Unit, UserGroupEntity, Any]
  lazy val updateUserGroup: UpdateUserGroupEndpoint =
    endpoint
      .name("updateUserGroup")
      .put
      .in(("tenants" / "user-groups" / path[String]("id").description("The user group id.")))
      .in(jsonBody[UserGroupEntity].description("The user group configuration details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[UserGroupEntity].description(""))
      .tags(List("Tenants"))
  
  type RemoveUserGroupEndpoint = Endpoint[Unit, (String, Option[LongParameterInt], Option[ClientIdParameterStr], Option[Boolean]), Unit, UserGroupEntity, Any]
  lazy val removeUserGroup: RemoveUserGroupEndpoint =
    endpoint
      .name("removeUserGroup")
      .delete
      .in(("tenants" / "user-groups" / path[String]("id").description("The user group id.")))
      .in(query[Option[LongParameterInt]]("version").description("The revision is used to verify the client is working with the latest version of the flow."))
      .in(query[Option[ClientIdParameterStr]]("clientId").description("If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response."))
      .in(query[Option[Boolean]]("disconnectedNodeAcknowledged").description("Acknowledges that this node is disconnected to allow for mutable requests to proceed."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[UserGroupEntity].description(""))
      .tags(List("Tenants"))
  
  type GetUsersEndpoint = Endpoint[Unit, Unit, Unit, UsersEntity, Any]
  lazy val getUsers: GetUsersEndpoint =
    endpoint
      .name("getUsers")
      .get
      .in(("tenants" / "users"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[UsersEntity].description(""))
      .tags(List("Tenants"))
  
  type CreateUserEndpoint = Endpoint[Unit, UserEntity, Unit, UserEntity, Any]
  lazy val createUser: CreateUserEndpoint =
    endpoint
      .name("createUser")
      .post
      .in(("tenants" / "users"))
      .in(jsonBody[UserEntity].description("The user configuration details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[UserEntity].description("").and(statusCode(sttp.model.StatusCode(201))))
      .tags(List("Tenants"))
  
  type GetUserEndpoint = Endpoint[Unit, String, Unit, UserEntity, Any]
  lazy val getUser: GetUserEndpoint =
    endpoint
      .name("getUser")
      .get
      .in(("tenants" / "users" / path[String]("id").description("The user id.")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[UserEntity].description(""))
      .tags(List("Tenants"))
  
  type UpdateUserEndpoint = Endpoint[Unit, (String, UserEntity), Unit, UserEntity, Any]
  lazy val updateUser: UpdateUserEndpoint =
    endpoint
      .name("updateUser")
      .put
      .in(("tenants" / "users" / path[String]("id").description("The user id.")))
      .in(jsonBody[UserEntity].description("The user configuration details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[UserEntity].description(""))
      .tags(List("Tenants"))
  
  type RemoveUserEndpoint = Endpoint[Unit, (String, Option[LongParameterInt], Option[ClientIdParameterStr], Option[Boolean]), Unit, UserEntity, Any]
  lazy val removeUser: RemoveUserEndpoint =
    endpoint
      .name("removeUser")
      .delete
      .in(("tenants" / "users" / path[String]("id").description("The user id.")))
      .in(query[Option[LongParameterInt]]("version").description("The revision is used to verify the client is working with the latest version of the flow."))
      .in(query[Option[ClientIdParameterStr]]("clientId").description("If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response."))
      .in(query[Option[Boolean]]("disconnectedNodeAcknowledged").description("Acknowledges that this node is disconnected to allow for mutable requests to proceed."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[UserEntity].description(""))
      .tags(List("Tenants"))
  
  type CreateVersionControlRequestEndpoint = Endpoint[Unit, CreateActiveRequestEntity, Unit, String, Any]
  lazy val createVersionControlRequest: CreateVersionControlRequestEndpoint =
    endpoint
      .name("createVersionControlRequest")
      .post
      .in(("versions" / "active-requests"))
      .in(jsonBody[CreateActiveRequestEntity].description("The versioned flow details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(stringBody.description(""))
      .tags(List("Versions"))
  
  type UpdateVersionControlRequestEndpoint = Endpoint[Unit, (String, VersionControlComponentMappingEntity), Unit, VersionControlInformationEntity, Any]
  lazy val updateVersionControlRequest: UpdateVersionControlRequestEndpoint =
    endpoint
      .name("updateVersionControlRequest")
      .put
      .in(("versions" / "active-requests" / path[String]("id").description("The request ID.")))
      .in(jsonBody[VersionControlComponentMappingEntity].description("The version control component mapping."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[VersionControlInformationEntity].description(""))
      .tags(List("Versions"))
  
  type DeleteVersionControlRequestEndpoint = Endpoint[Unit, (String, Option[Boolean]), Unit, Unit, Any]
  lazy val deleteVersionControlRequest: DeleteVersionControlRequestEndpoint =
    endpoint
      .name("deleteVersionControlRequest")
      .delete
      .in(("versions" / "active-requests" / path[String]("id").description("The request ID.")))
      .in(query[Option[Boolean]]("disconnectedNodeAcknowledged").description("Acknowledges that this node is disconnected to allow for mutable requests to proceed."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .tags(List("Versions"))
  
  type GetVersionInformationEndpoint = Endpoint[Unit, String, Unit, VersionControlInformationEntity, Any]
  lazy val getVersionInformation: GetVersionInformationEndpoint =
    endpoint
      .name("getVersionInformation")
      .get
      .in(("versions" / "process-groups" / path[String]("id").description("The process group id.")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[VersionControlInformationEntity].description(""))
      .tags(List("Versions"))
  
  type UpdateFlowVersionEndpoint = Endpoint[Unit, (String, VersionedFlowSnapshotEntity), Unit, VersionControlInformationEntity, Any]
  lazy val updateFlowVersion: UpdateFlowVersionEndpoint =
    endpoint
      .name("updateFlowVersion")
      .put
      .in(("versions" / "process-groups" / path[String]("id").description("The process group id.")))
      .in(jsonBody[VersionedFlowSnapshotEntity].description("The controller service configuration details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[VersionControlInformationEntity].description(""))
      .tags(List("Versions"))
  
  type SaveToFlowRegistryEndpoint = Endpoint[Unit, (String, StartVersionControlRequestEntity), Unit, VersionControlInformationEntity, Any]
  lazy val saveToFlowRegistry: SaveToFlowRegistryEndpoint =
    endpoint
      .name("saveToFlowRegistry")
      .post
      .in(("versions" / "process-groups" / path[String]("id").description("The process group id.")))
      .in(jsonBody[StartVersionControlRequestEntity].description("The versioned flow details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[VersionControlInformationEntity].description(""))
      .tags(List("Versions"))
  
  type StopVersionControlEndpoint = Endpoint[Unit, (String, Option[LongParameterInt], Option[ClientIdParameterStr], Option[Boolean]), Unit, VersionControlInformationEntity, Any]
  lazy val stopVersionControl: StopVersionControlEndpoint =
    endpoint
      .name("stopVersionControl")
      .delete
      .in(("versions" / "process-groups" / path[String]("id").description("The process group id.")))
      .in(query[Option[LongParameterInt]]("version").description("The version is used to verify the client is working with the latest version of the flow."))
      .in(query[Option[ClientIdParameterStr]]("clientId").description("If the client id is not specified, a new one will be generated. This value (whether specified or generated) is included in the response."))
      .in(query[Option[Boolean]]("disconnectedNodeAcknowledged").description("Acknowledges that this node is disconnected to allow for mutable requests to proceed."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[VersionControlInformationEntity].description(""))
      .tags(List("Versions"))
  
  type ExportFlowVersionEndpoint = Endpoint[Unit, String, Unit, String, Any]
  lazy val exportFlowVersion: ExportFlowVersionEndpoint =
    endpoint
      .name("exportFlowVersion")
      .get
      .in(("versions" / "process-groups" / path[String]("id").description("The process group id.") / "download"))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[String].description(""))
      .tags(List("Versions"))
  
  type InitiateRevertFlowVersionEndpoint = Endpoint[Unit, (String, VersionControlInformationEntity), Unit, VersionedFlowUpdateRequestEntity, Any]
  lazy val initiateRevertFlowVersion: InitiateRevertFlowVersionEndpoint =
    endpoint
      .name("initiateRevertFlowVersion")
      .post
      .in(("versions" / "revert-requests" / "process-groups" / path[String]("id").description("The process group id.")))
      .in(jsonBody[VersionControlInformationEntity].description("The Version Control Information to revert to."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[VersionedFlowUpdateRequestEntity].description(""))
      .tags(List("Versions"))
  
  type GetRevertRequestEndpoint = Endpoint[Unit, String, Unit, VersionedFlowUpdateRequestEntity, Any]
  lazy val getRevertRequest: GetRevertRequestEndpoint =
    endpoint
      .name("getRevertRequest")
      .get
      .in(("versions" / "revert-requests" / path[String]("id").description("The ID of the Revert Request")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[VersionedFlowUpdateRequestEntity].description(""))
      .tags(List("Versions"))
  
  type DeleteRevertRequestEndpoint = Endpoint[Unit, (String, Option[Boolean]), Unit, VersionedFlowUpdateRequestEntity, Any]
  lazy val deleteRevertRequest: DeleteRevertRequestEndpoint =
    endpoint
      .name("deleteRevertRequest")
      .delete
      .in(("versions" / "revert-requests" / path[String]("id").description("The ID of the Revert Request")))
      .in(query[Option[Boolean]]("disconnectedNodeAcknowledged").description("Acknowledges that this node is disconnected to allow for mutable requests to proceed."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[VersionedFlowUpdateRequestEntity].description(""))
      .tags(List("Versions"))
  
  type InitiateVersionControlUpdateEndpoint = Endpoint[Unit, (String, VersionControlInformationEntity), Unit, VersionedFlowUpdateRequestEntity, Any]
  lazy val initiateVersionControlUpdate: InitiateVersionControlUpdateEndpoint =
    endpoint
      .name("initiateVersionControlUpdate")
      .post
      .in(("versions" / "update-requests" / "process-groups" / path[String]("id").description("The process group id.")))
      .in(jsonBody[VersionControlInformationEntity].description("The controller service configuration details."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[VersionedFlowUpdateRequestEntity].description(""))
      .tags(List("Versions"))
  
  type GetUpdateRequestEndpoint = Endpoint[Unit, String, Unit, VersionedFlowUpdateRequestEntity, Any]
  lazy val getUpdateRequest: GetUpdateRequestEndpoint =
    endpoint
      .name("getUpdateRequest")
      .get
      .in(("versions" / "update-requests" / path[String]("id").description("The ID of the Update Request")))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[VersionedFlowUpdateRequestEntity].description(""))
      .tags(List("Versions"))
  
  type DeleteUpdateRequest_1Endpoint = Endpoint[Unit, (String, Option[Boolean]), Unit, VersionedFlowUpdateRequestEntity, Any]
  lazy val deleteUpdateRequest_1: DeleteUpdateRequest_1Endpoint =
    endpoint
      .name("deleteUpdateRequest_1")
      .delete
      .in(("versions" / "update-requests" / path[String]("id").description("The ID of the Update Request")))
      .in(query[Option[Boolean]]("disconnectedNodeAcknowledged").description("Acknowledges that this node is disconnected to allow for mutable requests to proceed."))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(400), emptyOutput.description("NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(404), emptyOutput.description("The specified resource could not be found."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(403), emptyOutput.description("Client is not authorized to make this request."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(409), emptyOutput.description("The request was valid but NiFi was not in the appropriate state to process it."))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("Client could not be authenticated."))(())))
      .out(jsonBody[VersionedFlowUpdateRequestEntity].description(""))
      .tags(List("Versions"))
  
  
  lazy val generatedEndpoints = List(logOut, logOutComplete, createAccessToken, getAuthenticationConfiguration, getConnection, updateConnection, deleteConnection, getControllerService, updateControllerService, removeControllerService, analyzeConfiguration, submitConfigVerificationRequest, getVerificationRequest, deleteVerificationRequest, getPropertyDescriptor_1, getControllerServiceReferences, updateControllerServiceReferences, updateRunStatus_1, getState, clearState_1, createBulletin, getCluster, getNode, updateNode, deleteNode, getControllerConfig, updateControllerConfig, createControllerService, getFlowAnalysisRules, createFlowAnalysisRule, getFlowAnalysisRule, updateFlowAnalysisRule, removeFlowAnalysisRule, analyzeFlowAnalysisRuleConfiguration, submitFlowAnalysisRuleConfigVerificationRequest, getFlowAnalysisRuleVerificationRequest, deleteFlowAnalysisRuleVerificationRequest, getFlowAnalysisRulePropertyDescriptor, updateRunStatus, getFlowAnalysisRuleState, clearState, deleteHistory, getNarSummaries, uploadNar, getNarSummary, deleteNar, downloadNar, getNarDetails, createParameterProvider, getFlowRegistryClients, createFlowRegistryClient, getFlowRegistryClient, updateFlowRegistryClient, deleteFlowRegistryClient, getPropertyDescriptor, getRegistryClientTypes, createReportingTask, importReportingTaskSnapshot, getNodeStatusHistory, getCounters, updateAllCounters, updateCounter, extendInputPortTransactionTTL, commitInputPortTransaction, receiveFlowFiles, extendOutputPortTransactionTTL, commitOutputPortTransaction, transferFlowFiles, createPortTransaction, getAboutInfo, getAdditionalDetails, getBanners, getBulletinBoard, generateClientId, searchCluster, getClusterSummary, getFlowConfig, getConnectionStatistics, getConnectionStatus, getConnectionStatusHistory, getContentViewers, getControllerServiceDefinition, getControllerServiceTypes, getBulletins, getControllerServicesFromController, getCurrentUser, getFlowAnalysisRuleDefinition, getFlowAnalysisRuleTypes, getAllFlowAnalysisResults, getFlowAnalysisResults, queryHistory, getComponentHistory, getAction, getInputPortStatus, getFlowMetrics, getOutputPortStatus, getParameterContexts, getParameterProviderDefinition, getParameterProviderTypes, getParameterProviders, getPrioritizers, getFlow, scheduleComponents, getBreadcrumbs, getControllerServicesFromGroup, activateControllerServices, getProcessGroupStatus, getProcessGroupStatusHistory, getProcessorDefinition, getProcessorTypes, getProcessorStatus, getProcessorStatusHistory, getRegistryClients, getBranches, getBuckets, getVersionDifferences, getFlows, getDetails, getVersions, getRemoteProcessGroupStatus, getRemoteProcessGroupStatusHistory, getReportingTaskDefinition, getReportingTaskTypes, getReportingTasks, downloadReportingTaskSnapshot, getReportingTaskSnapshot, getRuntimeManifest, searchFlow, getControllerStatus, createDropRequest, getDropRequest, removeDropRequest, getFlowFile, downloadFlowFileContent, createFlowFileListing, getListingRequest, deleteListingRequest, getFunnel, updateFunnel, removeFunnel, getInputPort, updateInputPort, removeInputPort, updateRunStatus_2, getLabel, updateLabel, removeLabel, getOutputPort, updateOutputPort, removeOutputPort, updateRunStatus_3, createParameterContext, getAssets, createAsset, getAssetContent, deleteAsset, submitParameterContextUpdate, getParameterContextUpdate, deleteUpdateRequest, submitValidationRequest, getValidationRequest, deleteValidationRequest, getParameterContext, updateParameterContext, deleteParameterContext, getParameterProvider, updateParameterProvider, removeParameterProvider, analyzeConfiguration_1, submitConfigVerificationRequest_1, getVerificationRequest_1, deleteVerificationRequest_1, getPropertyDescriptor_2, fetchParameters, getParameterProviderReferences, getState_1, clearState_2, submitApplyParameters, getParameterProviderApplyParametersRequest, deleteApplyParametersRequest, createAccessPolicy, getAccessPolicyForResource, getAccessPolicy, updateAccessPolicy, removeAccessPolicy, getReplaceProcessGroupRequest, deleteReplaceProcessGroupRequest, getProcessGroup, updateProcessGroup, removeProcessGroup, getConnections, createConnection, createControllerService_1, copy, exportProcessGroup, createEmptyAllConnectionsRequest, getDropAllFlowfilesRequest, removeDropRequest_1, replaceProcessGroup, getFunnels, createFunnel, getInputPorts, createInputPort, getLabels, createLabel, getLocalModifications, getOutputPorts, createOutputPort, paste, getProcessGroups, createProcessGroup, importProcessGroup, uploadProcessGroup, getProcessors, createProcessor, getRemoteProcessGroups, createRemoteProcessGroup, initiateReplaceProcessGroup, copySnippet, getProcessorRunStatusDetails, getProcessor, updateProcessor, deleteProcessor, analyzeConfiguration_2, submitProcessorVerificationRequest, getVerificationRequest_2, deleteVerificationRequest_2, getPropertyDescriptor_3, getProcessorDiagnostics, updateRunStatus_4, getState_2, clearState_3, terminateProcessor, submitProvenanceRequest, submitReplayLatestEvent, getLatestProvenanceEvents, submitReplay, getProvenanceEvent, getInputContent, getOutputContent, submitLineageRequest, getLineage, deleteLineage, getSearchOptions, getProvenance, deleteProvenance, updateRemoteProcessGroupRunStatuses, getRemoteProcessGroup, updateRemoteProcessGroup, removeRemoteProcessGroup, updateRemoteProcessGroupInputPort, updateRemoteProcessGroupInputPortRunStatus, updateRemoteProcessGroupOutputPort, updateRemoteProcessGroupOutputPortRunStatus, updateRemoteProcessGroupRunStatus, getState_3, getReportingTask, updateReportingTask, removeReportingTask, analyzeConfiguration_3, submitConfigVerificationRequest_2, getVerificationRequest_3, deleteVerificationRequest_3, getPropertyDescriptor_4, updateRunStatus_5, getState_4, clearState_4, getResources, getSiteToSiteDetails, getPeers, createSnippet, updateSnippet, deleteSnippet, getSystemDiagnostics, getJmxMetrics, searchTenants, getUserGroups, createUserGroup, getUserGroup, updateUserGroup, removeUserGroup, getUsers, createUser, getUser, updateUser, removeUser, createVersionControlRequest, updateVersionControlRequest, deleteVersionControlRequest, getVersionInformation, updateFlowVersion, saveToFlowRegistry, stopVersionControl, exportFlowVersion, initiateRevertFlowVersion, getRevertRequest, deleteRevertRequest, initiateVersionControlUpdate, getUpdateRequest, deleteUpdateRequest_1)

}
