
package sttp.tapir.generated

object TapirGeneratedEndpoints {

  import sttp.tapir._
  import sttp.tapir.model._
  import sttp.tapir.generic.auto._
  import sttp.tapir.json.circe._
  import io.circe.generic.semiauto._

  import sttp.tapir.generated.TapirGeneratedEndpointsJsonSerdes._
  import TapirGeneratedEndpointsSchemas._

  case class `application/zipCodecFormat`() extends CodecFormat {
    override val mediaType: sttp.model.MediaType = sttp.model.MediaType.unsafeApply(mainType = "application", subType = "zip")
  }
  sealed trait Bearer_or_Empty_or_api_key_or_api_key_and_Bearer_SecurityIn
  sealed trait Bearer_or_api_key_or_api_key_and_Bearer_SecurityIn
  case class Api_keySecurityIn(value: String) extends Bearer_or_Empty_or_api_key_or_api_key_and_Bearer_SecurityIn with Bearer_or_api_key_or_api_key_and_Bearer_SecurityIn
  case class Api_key_and_BearerSecurityIn(value: (String, String)) extends Bearer_or_Empty_or_api_key_or_api_key_and_Bearer_SecurityIn with Bearer_or_api_key_or_api_key_and_Bearer_SecurityIn
  case class BearerSecurityIn(value: String) extends Bearer_or_Empty_or_api_key_or_api_key_and_Bearer_SecurityIn with Bearer_or_api_key_or_api_key_and_Bearer_SecurityIn
  case object EmptySecurityIn extends Bearer_or_Empty_or_api_key_or_api_key_and_Bearer_SecurityIn
  val Api_key_and_BearerSecurityInMapping = sttp.tapir.Mapping.from[(Option[String], Option[String]), Option[(String, String)]] {
      case (Some(v0: String), Some(v1: String)) => Some((v0: String, v1: String))
      case _ => None
    } {
      case Some((v0: String, v1: String)) => (Some(v0: String), Some(v1: String))
      case None => (None, None)
    }

  case class CommaSeparatedValues[T](values: List[T])
  case class ExplodedValues[T](values: List[T])
  trait ExtraParamSupport[T] {
    def decode(s: String): sttp.tapir.DecodeResult[T]
    def encode(t: T): String
  }
  implicit def makePathCodecFromSupport[T](implicit support: ExtraParamSupport[T]): sttp.tapir.Codec[String, T, sttp.tapir.CodecFormat.TextPlain] = {
    sttp.tapir.Codec.string.mapDecode(support.decode)(support.encode)
  }
  implicit def makeQueryCodecFromSupport[T](implicit support: ExtraParamSupport[T]): sttp.tapir.Codec[List[String], T, sttp.tapir.CodecFormat.TextPlain] = {
    sttp.tapir.Codec.listHead[String, String, sttp.tapir.CodecFormat.TextPlain]
      .mapDecode(support.decode)(support.encode)
  }
  implicit def makeQueryOptCodecFromSupport[T](implicit support: ExtraParamSupport[T]): sttp.tapir.Codec[List[String], Option[T], sttp.tapir.CodecFormat.TextPlain] = {
    sttp.tapir.Codec.listHeadOption[String, String, sttp.tapir.CodecFormat.TextPlain]
      .mapDecode(maybeV => DecodeResult.sequence(maybeV.toSeq.map(support.decode)).map(_.headOption))(_.map(support.encode))
  }
  implicit def makeUnexplodedQuerySeqCodecFromListHead[T](implicit support: sttp.tapir.Codec[List[String], T, sttp.tapir.CodecFormat.TextPlain]): sttp.tapir.Codec[List[String], CommaSeparatedValues[T], sttp.tapir.CodecFormat.TextPlain] = {
    sttp.tapir.Codec.listHead[String, String, sttp.tapir.CodecFormat.TextPlain]
      .mapDecode(values => DecodeResult.sequence(values.split(',').toSeq.map(e => support.rawDecode(List(e)))).map(s => CommaSeparatedValues(s.toList)))(_.values.map(support.encode).mkString(","))
  }
  implicit def makeUnexplodedQueryOptSeqCodecFromListHead[T](implicit support: sttp.tapir.Codec[List[String], T, sttp.tapir.CodecFormat.TextPlain]): sttp.tapir.Codec[List[String], Option[CommaSeparatedValues[T]], sttp.tapir.CodecFormat.TextPlain] = {
    sttp.tapir.Codec.listHeadOption[String, String, sttp.tapir.CodecFormat.TextPlain]
      .mapDecode{
        case None => DecodeResult.Value(None)
        case Some(values) => DecodeResult.sequence(values.split(',').toSeq.map(e => support.rawDecode(List(e)))).map(r => Some(CommaSeparatedValues(r.toList)))
      }(_.map(_.values.map(support.encode).mkString(",")))
  }
  implicit def makeExplodedQuerySeqCodecFromListSeq[T](implicit support: sttp.tapir.Codec[List[String], List[T], sttp.tapir.CodecFormat.TextPlain]): sttp.tapir.Codec[List[String], ExplodedValues[T], sttp.tapir.CodecFormat.TextPlain] = {
    support.mapDecode(l => DecodeResult.Value(ExplodedValues(l)))(_.values)
  }
  implicit class RichBody[A, T](bod: EndpointIO.Body[A, T]) {
    def widenBody[TT >: T]: EndpointIO.Body[A, TT] = bod.map(_.asInstanceOf[TT])(_.asInstanceOf[T])
  }
  implicit class RichStreamBody[A, T, R](bod: sttp.tapir.StreamBodyIO[A, T, R]) {
    def widenBody[TT >: T]: sttp.tapir.StreamBodyIO[A, TT, R] = bod.map(_.asInstanceOf[TT])(_.asInstanceOf[T])
  }

  case class EnumExtraParamSupport[T <: enumeratum.EnumEntry](enumName: String, T: enumeratum.Enum[T]) extends ExtraParamSupport[T] {
    // Case-insensitive mapping
    def decode(s: String): sttp.tapir.DecodeResult[T] =
      scala.util.Try(T.upperCaseNameValuesToMap(s.toUpperCase))
        .fold(
          _ =>
            sttp.tapir.DecodeResult.Error(
              s,
              new NoSuchElementException(
                s"Could not find value $s for enum ${enumName}, available values: ${T.values.mkString(", ")}"
              )
            ),
          sttp.tapir.DecodeResult.Value(_)
        )
    def encode(t: T): String = t.entryName
  }
  def extraCodecSupport[T <: enumeratum.EnumEntry](enumName: String, T: enumeratum.Enum[T]): ExtraParamSupport[T] =
    EnumExtraParamSupport(enumName, T)
  sealed trait ADTWithDiscriminator
  sealed trait AnyObjectWithInlineEnum
  sealed trait Error
  sealed trait ADTWithDiscriminatorNoMapping
  sealed trait ADTWithoutDiscriminator
  case class NotNullableThingy (
    uuid: java.util.UUID
  )
  case class ObjectWithInlineEnum2 (
    inlineEnum: ObjectWithInlineEnum2InlineEnum
  ) extends AnyObjectWithInlineEnum

  sealed trait ObjectWithInlineEnum2InlineEnum extends enumeratum.EnumEntry
  object ObjectWithInlineEnum2InlineEnum extends enumeratum.Enum[ObjectWithInlineEnum2InlineEnum] with enumeratum.CirceEnum[ObjectWithInlineEnum2InlineEnum] {
    val values = findValues
    case object bar1 extends ObjectWithInlineEnum2InlineEnum
    case object bar2 extends ObjectWithInlineEnum2InlineEnum
  }
  case class SimpleError (
    message: String
  ) extends Error
  case class NotFoundError (
    reason: String
  ) extends Error
  case class SubtypeWithoutD1 (
    s: String,
    i: Option[Int] = None,
    a: Seq[String],
    absent: Option[String] = None
  ) extends ADTWithoutDiscriminator
  case class SubtypeWithD1 (
    s: String,
    i: Option[Int] = None,
    d: Option[Double] = None
  ) extends ADTWithDiscriminator with ADTWithDiscriminatorNoMapping {
    def `type`: String = "SubA"
  }
  case class SubtypeWithoutD3 (
    s: String,
    i: Option[Int] = None,
    e: Option[AnEnum] = None,
    absent: Option[String] = None
  ) extends ADTWithoutDiscriminator
  case class NullableThingy2 (
    uuid: java.util.UUID
  )
  case class ObjectWithInlineEnum (
    id: java.util.UUID,
    inlineEnum: ObjectWithInlineEnumInlineEnum = ObjectWithInlineEnumInlineEnum.foo3
  ) extends AnyObjectWithInlineEnum

  sealed trait ObjectWithInlineEnumInlineEnum extends enumeratum.EnumEntry
  object ObjectWithInlineEnumInlineEnum extends enumeratum.Enum[ObjectWithInlineEnumInlineEnum] with enumeratum.CirceEnum[ObjectWithInlineEnumInlineEnum] {
    val values = findValues
    case object foo1 extends ObjectWithInlineEnumInlineEnum
    case object foo2 extends ObjectWithInlineEnumInlineEnum
    case object foo3 extends ObjectWithInlineEnumInlineEnum
    case object foo4 extends ObjectWithInlineEnumInlineEnum
  }
  case class SubtypeWithoutD2 (
    a: Seq[String],
    absent: Option[String] = None
  ) extends ADTWithoutDiscriminator
  case class SubtypeWithD2 (
    s: String,
    a: Option[Seq[String]] = None
  ) extends ADTWithDiscriminator with ADTWithDiscriminatorNoMapping {
    def `type`: String = "SubB"
  }

  sealed trait AnEnum extends enumeratum.EnumEntry
  object AnEnum extends enumeratum.Enum[AnEnum] with enumeratum.CirceEnum[AnEnum] {
    val values = findValues
    case object Foo extends AnEnum
    case object Bar extends AnEnum
    case object Baz extends AnEnum
  }
  type ListType = List[String]
  case class NullableThingy (
    uuid: java.util.UUID
  )

  sealed trait PostJsonStringJsonBodyBodyIn extends Product with java.io.Serializable
  case class PostJsonStringJsonBodyBodyOption_String_In(value: Option[String]) extends PostJsonStringJsonBodyBodyIn
  case class PostJsonStringJsonBodyBody1In(value: Array[Byte]) extends PostJsonStringJsonBodyBodyIn


  sealed trait PostJsonStringJsonBodyBodyOut extends Product with java.io.Serializable {
    def `application/json`: () => Option[String] = () => throw new RuntimeException("Body for content type application/json not provided")
    def `application/zip`: () => Array[Byte] = () => throw new RuntimeException("Body for content type application/zip not provided")
  }
  case class PostJsonStringJsonBodyBodyOutFull (
    override val `application/json`: () => Option[String],
    override val `application/zip`: () => Array[Byte],
  ) extends PostJsonStringJsonBodyBodyOut
  case class PostJsonStringJsonBodyBodyOption_String_Out(value: Option[String]) extends PostJsonStringJsonBodyBodyOut{
    override def `application/json`: () => Option[String] = () => value
  }
  case class PostJsonStringJsonBodyBody1Out(value: Array[Byte]) extends PostJsonStringJsonBodyBodyOut{
    override def `application/zip`: () => Array[Byte] = () => value
  }

  case class PutInlineSimpleObjectRequest (
    foo: String,
    bar: Option[java.util.UUID] = None
  )
  case class PutInlineSimpleObjectResponse (
    foo: String,
    bar: Option[java.util.UUID] = None
  )
  case class PostInlineSimpleObjectRequest (
    foo: String,
    bar: Option[java.util.UUID] = None
  )
  case class PostInlineSimpleObjectResponse (
    foo: String,
    bar: Option[java.util.UUID] = None
  )

  type TapirCodegenDirectivesExtension = Seq[String]
  val tapirCodegenDirectivesExtensionKey = new sttp.tapir.AttributeKey[TapirCodegenDirectivesExtension]("sttp.tapir.generated.TapirGeneratedEndpoints.TapirCodegenDirectivesExtension")

  type GetBinaryTestEndpoint = Endpoint[String, Unit, Unit, sttp.capabilities.pekko.PekkoStreams.BinaryStream, sttp.capabilities.pekko.PekkoStreams]
  lazy val getBinaryTest: GetBinaryTestEndpoint =
    endpoint
      .get
      .in(("binary" / "test"))
      .securityIn(auth.bearer[String]())
      .out(streamBody(sttp.capabilities.pekko.PekkoStreams)(Schema.binary[Array[Byte]], CodecFormat.OctetStream()).description("Response CSV body"))

  type PostBinaryTestEndpoint = Endpoint[String, sttp.capabilities.pekko.PekkoStreams.BinaryStream, Unit, String, sttp.capabilities.pekko.PekkoStreams]
  lazy val postBinaryTest: PostBinaryTestEndpoint =
    endpoint
      .post
      .in(("binary" / "test"))
      .securityIn(auth.oauth2.implicitFlow("https://petstore3.swagger.io/oauth/authorize", None))
      .in(streamBody(sttp.capabilities.pekko.PekkoStreams)(Schema.binary[Array[Byte]], CodecFormat.OctetStream()).description("Upload a csv"))
      .out(jsonBody[String].description("successful operation"))

  type PutOptionalTestEndpoint = Endpoint[Bearer_or_api_key_or_api_key_and_Bearer_SecurityIn, Option[NotNullableThingy], Unit, NotNullableThingy, Any]
  lazy val putOptionalTest: PutOptionalTestEndpoint =
    endpoint
      .put
      .in(("optional" / "test"))
      .securityIn(auth.apiKey(header[Option[String]]("api_key")))
      .securityIn(auth.apiKey(header[Option[String]]("api_key"))
        .and(auth.bearer[Option[String]]()).map(Api_key_and_BearerSecurityInMapping))
      .securityIn(auth.bearer[Option[String]]())
      .mapSecurityInDecode[Bearer_or_api_key_or_api_key_and_Bearer_SecurityIn]{
        case (Some(x), None, None) => DecodeResult.Value(Api_keySecurityIn(x))
        case (_, Some(x), _) => DecodeResult.Value(Api_key_and_BearerSecurityIn(x))
        case (None, None, Some(x)) => DecodeResult.Value(BearerSecurityIn(x))
        case other =>
          val count = other.productIterator.count(_.isInstanceOf[Some[?]])
          DecodeResult.Error(s"$count security inputs", new RuntimeException(s"Expected a single security input, found $count"))
      }{
        case Api_keySecurityIn(x) => (Some(x), None, None)
        case Api_key_and_BearerSecurityIn(x) => (None, Some(x), None)
        case BearerSecurityIn(x) => (None, None, Some(x))
      }
      .in(jsonBody[Option[NotNullableThingy]].description("an optional request body (not required)"))
      .out(jsonBody[NotNullableThingy].description("a non-optional response body"))

  type PostOptionalTestEndpoint = Endpoint[Option[(String, String)], Option[NullableThingy2], Unit, Option[NullableThingy], Any]
  lazy val postOptionalTest: PostOptionalTestEndpoint =
    endpoint
      .post
      .in(("optional" / "test"))
      .securityIn(auth.apiKey(header[Option[String]]("api_key"))
        .and(auth.bearer[Option[String]]()).map(Api_key_and_BearerSecurityInMapping))
      .in(jsonBody[Option[NullableThingy2]].description("an optional request body (nullable)"))
      .out(jsonBody[Option[NullableThingy]].description("an optional response body"))

  type PostJsonStringJsonBodyEndpoint = Endpoint[Option[String], PostJsonStringJsonBodyBodyIn, Unit, Option[PostJsonStringJsonBodyBodyOut], Any]
  lazy val postJsonStringJsonBody: PostJsonStringJsonBodyEndpoint =
    endpoint
      .post
      .in(("json" / "stringJsonBody"))
      .securityIn(auth.bearer[Option[String]]())
      .in(oneOfBody[PostJsonStringJsonBodyBodyIn](
        stringJsonBody.map(Option(_))(_.orNull).map(PostJsonStringJsonBodyBodyOption_String_In(_))(_.value).widenBody[PostJsonStringJsonBodyBodyIn],
        EndpointIO.Body(RawBodyType.ByteArrayBody, Codec.id[Array[Byte], `application/zipCodecFormat`](`application/zipCodecFormat`(), Schema.schemaForByteArray), EndpointIO.Info.empty).map(PostJsonStringJsonBodyBody1In(_))(_.value).widenBody[PostJsonStringJsonBodyBodyIn]))
      .out(oneOf[Option[PostJsonStringJsonBodyBodyOut]](
        oneOfVariantValueMatcher(sttp.model.StatusCode(200), oneOfBody[PostJsonStringJsonBodyBodyOut](
        stringJsonBody.map(Option(_))(_.orNull).map(PostJsonStringJsonBodyBodyOption_String_Out(_))(_.`application/json`())
        .map(_.asInstanceOf[PostJsonStringJsonBodyBodyOut])(p => PostJsonStringJsonBodyBodyOption_String_Out(p.`application/json`())).description("Possibly-invalid json"),
        EndpointIO.Body(RawBodyType.ByteArrayBody, Codec.id[Array[Byte], `application/zipCodecFormat`](`application/zipCodecFormat`(), Schema.schemaForByteArray), EndpointIO.Info.empty).map(PostJsonStringJsonBodyBody1Out(_))(_.`application/zip`())
        .map(_.asInstanceOf[PostJsonStringJsonBodyBodyOut])(p => PostJsonStringJsonBodyBody1Out(p.`application/zip`())).description("Possibly-invalid json")).map(Some(_))(_.orNull)){ case Some(_: PostJsonStringJsonBodyBodyOut) => true },
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(204), emptyOutput.description("No response"))(None)))
      .attribute[TapirCodegenDirectivesExtension](tapirCodegenDirectivesExtensionKey, Vector("json-body-as-string"))

  type PostJsonStringJsonBodySimpleEndpoint = Endpoint[String, String, Unit, String, Any]
  lazy val postJsonStringJsonBodySimple: PostJsonStringJsonBodySimpleEndpoint =
    endpoint
      .post
      .in(("json" / "stringJsonBody" / "simple"))
      .securityIn(auth.oauth2.implicitFlow("https://petstore3.swagger.io/oauth/authorize", None))
      .in(stringJsonBody)
      .out(stringJsonBody.description("Possibly-invalid json"))
      .attribute[TapirCodegenDirectivesExtension](tapirCodegenDirectivesExtensionKey, Vector("json-body-as-string"))

  type GetSecurityGroupSecurityGroupNameEndpoint = Endpoint[(String, String), Unit, Unit, Unit, Any]
  lazy val getSecurityGroupSecurityGroupName: GetSecurityGroupSecurityGroupNameEndpoint =
    endpoint
      .get
      .securityIn(auth.oauth2.implicitFlow("https://petstore3.swagger.io/oauth/authorize", None))
      .prependSecurityIn("security-group" / path[String]("securityGroupName").description("used by security logic"))
      .out(statusCode(sttp.model.StatusCode(204)).description("OK"))

  type PutAdtTestEndpoint = Endpoint[Unit, ADTWithoutDiscriminator, Unit, ADTWithoutDiscriminator, Any]
  lazy val putAdtTest: PutAdtTestEndpoint =
    endpoint
      .put
      .in(("adt" / "test"))
      .in(jsonBody[ADTWithoutDiscriminator].description("Update an existent user in the store"))
      .out(jsonBody[ADTWithoutDiscriminator].description("successful operation"))

  type PostAdtTestEndpoint = Endpoint[String, ADTWithDiscriminatorNoMapping, Unit, ADTWithDiscriminator, Any]
  lazy val postAdtTest: PostAdtTestEndpoint =
    endpoint
      .post
      .in(("adt" / "test"))
      .securityIn(auth.apiKey(header[String]("api_key")))
      .in(jsonBody[ADTWithDiscriminatorNoMapping].description("Update an existent user in the store"))
      .out(jsonBody[ADTWithDiscriminator].description("successful operation"))

  type GetHeadersTestsEndpoint = Endpoint[String, Unit, Unit, Option[String], Any]
  lazy val getHeadersTests: GetHeadersTestsEndpoint =
    endpoint
      .get
      .in(("headers" / "tests"))
      .securityIn(auth.oauth2.implicitFlow("https://petstore3.swagger.io/oauth/authorize", None))
      .out(statusCode(sttp.model.StatusCode(302)).description("response").and(header[Option[String]]("foo").description("a description")))

  type GetOneofErrorSecParamTestEndpoint = Endpoint[(String, Bearer_or_Empty_or_api_key_or_api_key_and_Bearer_SecurityIn), Unit, Error, Unit, Any]
  lazy val getOneofErrorSecParamTest: GetOneofErrorSecParamTestEndpoint =
    endpoint
      .get
      .in(("test"))
      .securityIn(auth.apiKey(header[Option[String]]("api_key")))
      .securityIn(auth.apiKey(header[Option[String]]("api_key"))
        .and(auth.bearer[Option[String]]()).map(Api_key_and_BearerSecurityInMapping))
      .securityIn(auth.bearer[Option[String]]())
      .mapSecurityInDecode[Bearer_or_Empty_or_api_key_or_api_key_and_Bearer_SecurityIn]{
        case (Some(x), None, None) => DecodeResult.Value(Api_keySecurityIn(x))
        case (_, Some(x), _) => DecodeResult.Value(Api_key_and_BearerSecurityIn(x))
        case (None, None, Some(x)) => DecodeResult.Value(BearerSecurityIn(x))
        case (None, None, None) => DecodeResult.Value(EmptySecurityIn)
        case other =>
          val count = other.productIterator.count(_.isInstanceOf[Some[?]])
          DecodeResult.Error(s"$count security inputs", new RuntimeException(s"Expected a single security input, found $count"))
      }{
        case Api_keySecurityIn(x) => (Some(x), None, None)
        case Api_key_and_BearerSecurityIn(x) => (None, Some(x), None)
        case BearerSecurityIn(x) => (None, None, Some(x))
        case EmptySecurityIn => (None, None, None)
      }
      .prependSecurityIn("oneof" / "error" / path[String]("secParam"))
      .errorOut(oneOf[Error](
        oneOfVariant[NotFoundError](sttp.model.StatusCode(404), jsonBody[NotFoundError].description("Not found")),
        oneOfVariant[SimpleError](sttp.model.StatusCode(400), jsonBody[SimpleError].description("Not found"))))
      .out(statusCode(sttp.model.StatusCode(204)).description("No response"))

  type GetSecurityGroupSecurityGroupNameMorePathEndpoint = Endpoint[(String, String), Unit, Unit, Unit, Any]
  lazy val getSecurityGroupSecurityGroupNameMorePath: GetSecurityGroupSecurityGroupNameMorePathEndpoint =
    endpoint
      .get
      .in(("more-path"))
      .securityIn(auth.oauth2.implicitFlow("https://petstore3.swagger.io/oauth/authorize", None))
      .prependSecurityIn("security-group" / path[String]("securityGroupName").description("used by security logic"))
      .out(statusCode(sttp.model.StatusCode(204)).description("OK"))

  type GetOneofOptionTestEndpoint = Endpoint[String, Unit, Unit, (Option[AnyObjectWithInlineEnum], Option[String]), Any]
  lazy val getOneofOptionTest: GetOneofOptionTestEndpoint =
    endpoint
      .get
      .in(("oneof" / "option" / "test"))
      .securityIn(auth.oauth2.implicitFlow("https://petstore3.swagger.io/oauth/authorize", None))
      .out(oneOf[(Option[AnyObjectWithInlineEnum], Option[String])](
        oneOfVariantValueMatcher(sttp.model.StatusCode(204), emptyOutputAs(None).description("No response").and(header[Option[String]]("common-response-header"))){ case (None, _) => true},
        oneOfVariantValueMatcher(sttp.model.StatusCode(200), jsonBody[Option[ObjectWithInlineEnum]].description("An object").and(header[Option[String]]("common-response-header"))){ case (Some(_: ObjectWithInlineEnum), _) => true },
        oneOfVariantValueMatcher(sttp.model.StatusCode(201), jsonBody[Option[ObjectWithInlineEnum2]].description("Another object").and(header[Option[String]]("common-response-header"))){ case (Some(_: ObjectWithInlineEnum2), _) => true }))

  type PostInlineEnumTestEndpoint = Endpoint[Unit, (PostInlineEnumTestQueryEnum, Option[PostInlineEnumTestQueryOptEnum], List[PostInlineEnumTestQuerySeqEnum], Option[List[PostInlineEnumTestQueryOptSeqEnum]], ObjectWithInlineEnum), Unit, Unit, Any]
  lazy val postInlineEnumTest: PostInlineEnumTestEndpoint =
    endpoint
      .post
      .in(("inline" / "enum" / "test"))
      .in(query[PostInlineEnumTestQueryEnum]("query-enum").description("An enum, inline, in a query string"))
      .in(query[Option[PostInlineEnumTestQueryOptEnum]]("query-opt-enum").description("An optional enum, inline, in a query string"))
      .in(query[CommaSeparatedValues[PostInlineEnumTestQuerySeqEnum]]("query-seq-enum").map(_.values)(CommaSeparatedValues(_)).description("A sequence of enums, inline, in a query string"))
      .in(query[Option[CommaSeparatedValues[PostInlineEnumTestQueryOptSeqEnum]]]("query-opt-seq-enum").map(_.map(_.values))(_.map(CommaSeparatedValues(_))).description("An optional sequence of enums, inline, in a query string"))
      .in(jsonBody[ObjectWithInlineEnum].description("Check inline enums"))
      .out(statusCode(sttp.model.StatusCode(204)).description("No Content"))

  sealed trait PostInlineEnumTestQueryEnum extends enumeratum.EnumEntry
  object PostInlineEnumTestQueryEnum extends enumeratum.Enum[PostInlineEnumTestQueryEnum] with enumeratum.CirceEnum[PostInlineEnumTestQueryEnum] {
    val values = findValues
    case object bar1 extends PostInlineEnumTestQueryEnum
    case object bar2 extends PostInlineEnumTestQueryEnum
    case object bar3 extends PostInlineEnumTestQueryEnum
    implicit val enumCodecSupportPostInlineEnumTestQueryEnum: ExtraParamSupport[PostInlineEnumTestQueryEnum] =
      extraCodecSupport[PostInlineEnumTestQueryEnum]("PostInlineEnumTestQueryEnum", PostInlineEnumTestQueryEnum)
  }

  sealed trait PostInlineEnumTestQueryOptEnum extends enumeratum.EnumEntry
  object PostInlineEnumTestQueryOptEnum extends enumeratum.Enum[PostInlineEnumTestQueryOptEnum] with enumeratum.CirceEnum[PostInlineEnumTestQueryOptEnum] {
    val values = findValues
    case object bar1 extends PostInlineEnumTestQueryOptEnum
    case object bar2 extends PostInlineEnumTestQueryOptEnum
    case object bar3 extends PostInlineEnumTestQueryOptEnum
    implicit val enumCodecSupportPostInlineEnumTestQueryOptEnum: ExtraParamSupport[PostInlineEnumTestQueryOptEnum] =
      extraCodecSupport[PostInlineEnumTestQueryOptEnum]("PostInlineEnumTestQueryOptEnum", PostInlineEnumTestQueryOptEnum)
  }

  sealed trait PostInlineEnumTestQuerySeqEnum extends enumeratum.EnumEntry
  object PostInlineEnumTestQuerySeqEnum extends enumeratum.Enum[PostInlineEnumTestQuerySeqEnum] with enumeratum.CirceEnum[PostInlineEnumTestQuerySeqEnum] {
    val values = findValues
    case object baz1 extends PostInlineEnumTestQuerySeqEnum
    case object baz2 extends PostInlineEnumTestQuerySeqEnum
    case object baz3 extends PostInlineEnumTestQuerySeqEnum
    implicit val enumCodecSupportPostInlineEnumTestQuerySeqEnum: ExtraParamSupport[PostInlineEnumTestQuerySeqEnum] =
      extraCodecSupport[PostInlineEnumTestQuerySeqEnum]("PostInlineEnumTestQuerySeqEnum", PostInlineEnumTestQuerySeqEnum)
  }

  sealed trait PostInlineEnumTestQueryOptSeqEnum extends enumeratum.EnumEntry
  object PostInlineEnumTestQueryOptSeqEnum extends enumeratum.Enum[PostInlineEnumTestQueryOptSeqEnum] with enumeratum.CirceEnum[PostInlineEnumTestQueryOptSeqEnum] {
    val values = findValues
    case object baz1 extends PostInlineEnumTestQueryOptSeqEnum
    case object baz2 extends PostInlineEnumTestQueryOptSeqEnum
    case object baz3 extends PostInlineEnumTestQueryOptSeqEnum
    implicit val enumCodecSupportPostInlineEnumTestQueryOptSeqEnum: ExtraParamSupport[PostInlineEnumTestQueryOptSeqEnum] =
      extraCodecSupport[PostInlineEnumTestQueryOptSeqEnum]("PostInlineEnumTestQueryOptSeqEnum", PostInlineEnumTestQueryOptSeqEnum)
  }

  type PutInlineSimpleObjectEndpoint = Endpoint[String, PutInlineSimpleObjectRequest, Array[Byte], PutInlineSimpleObjectResponse, Any]
  lazy val putInlineSimpleObject: PutInlineSimpleObjectEndpoint =
    endpoint
      .put
      .in(("inline" / "simple" / "object"))
      .securityIn(auth.oauth2.implicitFlow("https://petstore3.swagger.io/oauth/authorize", None))
      .in(multipartBody[PutInlineSimpleObjectRequest])
      .errorOut(oneOf[Array[Byte]](
        oneOfVariant[Array[Byte]](sttp.model.StatusCode(400), rawBinaryBody(sttp.tapir.RawBodyType.ByteArrayBody).description("application/octet-stream in error position")),
        oneOfVariant[Array[Byte]](sttp.model.StatusCode(401), rawBinaryBody(sttp.tapir.RawBodyType.ByteArrayBody).description("application/octet-stream in error position 2"))))
      .out(multipartBody[PutInlineSimpleObjectResponse].description("An object"))

  type PostInlineSimpleObjectEndpoint = Endpoint[String, Option[PostInlineSimpleObjectRequest], Unit, (PostInlineSimpleObjectResponse, String), Any]
  lazy val postInlineSimpleObject: PostInlineSimpleObjectEndpoint =
    endpoint
      .post
      .in(("inline" / "simple" / "object"))
      .securityIn(auth.oauth2.implicitFlow("https://petstore3.swagger.io/oauth/authorize", None))
      .in(jsonBody[Option[PostInlineSimpleObjectRequest]])
      .out(jsonBody[PostInlineSimpleObjectResponse].description("An object").and(header[String]("x-combat-status").description("a response header")))

  type DeleteInlineSimpleObjectEndpoint = Endpoint[String, Unit, Unit, Unit, Any]
  lazy val deleteInlineSimpleObject: DeleteInlineSimpleObjectEndpoint =
    endpoint
      .delete
      .in(("inline" / "simple" / "object"))
      .securityIn(auth.oauth2.implicitFlow("https://petstore3.swagger.io/oauth/authorize", None))
      .errorOut(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(401), emptyOutput.description("empty response 3"))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(402), emptyOutput.description("empty response 4"))(())))
      .out(oneOf[Unit](
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(200), emptyOutput.description("empty response 1"))(()),
        oneOfVariantSingletonMatcher(sttp.model.StatusCode(201), emptyOutput.description("empty response 2"))(())))

  type PatchInlineSimpleObjectEndpoint = Endpoint[String, Option[ListType], ListType, ListType, Any]
  lazy val patchInlineSimpleObject: PatchInlineSimpleObjectEndpoint =
    endpoint
      .patch
      .in(("inline" / "simple" / "object"))
      .securityIn(auth.oauth2.implicitFlow("https://petstore3.swagger.io/oauth/authorize", None))
      .in(jsonBody[Option[ListType]].description("list type in"))
      .errorOut(jsonBody[ListType].description("list type error").and(statusCode(sttp.model.StatusCode(400))))
      .out(jsonBody[ListType].description("list type out"))


  lazy val generatedEndpoints = List(getBinaryTest, postBinaryTest, putOptionalTest, postOptionalTest, postJsonStringJsonBody, postJsonStringJsonBodySimple, getSecurityGroupSecurityGroupName, putAdtTest, postAdtTest, getHeadersTests, getOneofErrorSecParamTest, getSecurityGroupSecurityGroupNameMorePath, getOneofOptionTest, postInlineEnumTest, putInlineSimpleObject, postInlineSimpleObject, deleteInlineSimpleObject, patchInlineSimpleObject)


  object Servers {
    import sttp.model.Uri.UriContext

    /*
      These are the main endpoints.
      The environments are self-documenting!
    */
    object `https://{environment}.my-co.org:{port}/api/{customer}/prefix` {
      sealed trait environment extends enumeratum.EnumEntry
      object environment extends enumeratum.Enum[environment] {
        val values = findValues
        case object dev extends environment
        case object staging extends environment
        case object prod extends environment
        val default: environment = prod
      }
      val defaultPort = "1234"
      val defaultCustomer = "big-dogs"
      def uri(_environment: environment = environment.default, _port: String = defaultPort, _customer: String = defaultCustomer): sttp.model.Uri =
        uri"https://${_environment}.my-co.org:${_port}/api/${_customer}/prefix"
    }
    
    /*
      Legacy endpoint that doesn't require TLS
      Doesn't work, retained for completely mysterious reasons lost to the winds of time
    */
    object `http://testing.my-co.org:{port}/api/{scoped}/prefix` {
      val defaultPort = "4321"
      val defaultScoped = "false"
      def uri(_port: String = defaultPort, _scoped: String = defaultScoped): sttp.model.Uri =
        uri"http://testing.my-co.org:${_port}/api/${_scoped}/prefix"
    }
    
    /*
      Locally
    */
    val `/`: sttp.model.Uri = uri"/"

  }
}
