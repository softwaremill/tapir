# 2. Codecs, schemas, validators

Date: 2019-11-09

## Context

Schemas for objects need to be customised, adding description/format information so that it's added to the docs.

## Decision

First, a definition:

`Schema[T]` describes the shape of the low-level, "raw" representation of type `T`

A schema is one of the following: a basic schema (string, int, number, boolean, date, ...), an array, binary, 
object (product / coproduct / open product) or a reference to an object (for recursive schemas). 

Apart from the information that schema carries with its type, it contains:

* a description
* a format, giving more low-level details about the representation of the type
* optionality

## Customising schemas

To customise schemas, the derived schema implicits for case classes (generated by magnolia) are wrapped in a 
`Derived[T](value: T)` class, with a low-priority implicit converter from `Derived[T]` to `T` (similar to `Exported`
in circe).

To customise a schema for a given type, we can could do:

```scala
implicit val mySchema: Schema[Person] = customise(implicitly[Derived[Person]].value)
```

## Relationship with validator

One of the philosophical questions is, should the validator be part of the schema? Should we derive json 
encoders/decoders from the schema? Both sound tempting.

I think it's worth keeping the divide. On the "cons" side, we have the duplicate recursive logic of building up 
validators/schemas/encoders for composite types. On the "pro" side however, we have a clear division of responsibility:

* schemas describe the low-level shape of the value; however, they don't specify the final format of the values, and are not concerned with constructing/deconstructing objects from raw value tuples, or decode failures
* validators describe the subset of values for potentially higher-level types. They are context-free, that is they only constrain values based on the value itself, without knowing the parent object
* encoders/decoders translate the value to the low-level format

Hence, a validator can influence the schema; the high-level description of the possible values can narrow down the format of the low-level representation, for example. However, not the other way round - it's not generally possible to derive a validator from a schema. Let's consider the `uuid` format and the `UUID` high-level type. In this case, the format is an intrinsic property of the high-level type, no validation apart from decoding is required.

## Why not annotations

Adding `@Description` or `@Format` annotations could also be a viable solution, however it has one major drawback: it requires modifying the target datatype. So while this could be an addition to the mechanism described above, it's not a real alternative; we would need a way to change the schemas "by hand" anyway, to be able to describe existing datatypes, which we cannot annotate.

## Update 12/2020

In the end, we added validators to schemas. The reasoning was that once auto- and semi-auto-derivation has been 
introduced, having to manually derive two structures was highly impractical. Hence, a schema is now a description
of the target type `T`, including both the low-level representation, and the high-level validation rules.