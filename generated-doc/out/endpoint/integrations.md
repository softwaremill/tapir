# Datatypes integrations

```eval_rst
.. note::

  Note that the codecs defined by the tapir integrations are used only when the specific types (e.g. enumerations0 are 
  used at the top level. Any nested usages (e.g. as part of a json body), need to be separately configured to work with 
  the used json library.
```

## Cats datatypes integration

The `tapir-cats` module contains additional instances for some [cats](https://typelevel.org/cats/)
datatypes as well as additional syntax:

```scala
"com.softwaremill.sttp.tapir" %% "tapir-cats" % "1.1.3"
```

- `import sttp.tapir.integ.cats.codec._` - brings schema, validator and codec instances
- `import sttp.tapir.integ.cats.syntax._` - brings additional syntax for `tapir` types

## Refined integration

If you use [refined](https://github.com/fthomas/refined), the `tapir-refined` module will provide implicit codecs and
validators for `T Refined P` as long as a codec for `T` already exists:

```scala
"com.softwaremill.sttp.tapir" %% "tapir-refined" % "1.1.3"
```

You'll need to extend the `sttp.tapir.codec.refined.TapirCodecRefined`
trait or `import sttp.tapir.codec.refined._` to bring the implicit values into scope.

The refined codecs contain a validator which wrap/unwrap the value from/to its refined equivalent.

Some predicates will bind correctly to the vanilla tapir Validator, while others will bind to a custom validator that
might not be very clear when reading the generated documentation. Correctly bound predicates can be found in
`integration/refined/src/main/scala/sttp/tapir/codec/refined/TapirCodecRefined.scala`.
If you are not satisfied with the validator generated by `tapir-refined`, you can provide an implicit
`ValidatorForPredicate[T, P]` in scope using `ValidatorForPredicate.fromPrimitiveValidator` to build it (do not
hesitate to contribute your work!).

## Enumeratum integration

The `tapir-enumeratum` module provides schemas, validators and codecs for [Enumeratum](https://github.com/lloydmeta/enumeratum)
enumerations. To use, add the following dependency:

```scala
"com.softwaremill.sttp.tapir" %% "tapir-enumeratum" % "1.1.3"
```

Then, `import sttp.tapir.codec.enumeratum._`, or extends the `sttp.tapir.codec.enumeratum.TapirCodecEnumeratum` trait.

This will bring into scope implicit values for values extending `*EnumEntry`.

## Enumeration integration

There is no library for the use of the build in scala `Enumeration`, but it can be implemented by hand.

The example code below will generate [enums](https://swagger.io/docs/specification/data-models/enums/) to the open-api documentation.

```scala
import sttp.tapir._

trait EnumHelper { e: Enumeration =>
  import io.circe._

  implicit val enumDecoder: Decoder[e.Value] = Decoder.decodeEnumeration(e)
  implicit val enumEncoder: Encoder[e.Value] = Encoder.encodeEnumeration(e)

  // needs to be a def or lazy val so that the enumeration values are available!
  implicit def schemaForEnum: Schema[e.Value] = Schema.string.validate(Validator.enumeration(e.values.toList, v => Option(v)))
}
object Color extends Enumeration with EnumHelper {
  type Color = Value
  val Blue = Value("blue")
  val Red   = Value("red")
}
``` 

Tapir `Schema` for any `Enumeration.Value` can also be auto or semi-auto derived using `import sttp.tapir.generic.auto._` or `Schema.derivedEnumerationValue`.

## NewType integration

If you use [scala-newtype](https://github.com/estatico/scala-newtype), the `tapir-newtype` module will provide implicit codecs and
schemas for types with a `@newtype` and `@newsubtype` annotations as long as a codec and schema for its underlying value already exists:

```scala
"com.softwaremill.sttp.tapir" %% "tapir-newtype" % "1.1.3"
```

Then, `import sttp.tapir.codec.newtype._`, or extend the `sttp.tapir.codec.newtype.TapirCodecNewType` trait to bring the implicit values into scope.

## Monix NewType integration

If you use [monix newtypes](https://github.com/monix/newtypes), the `tapir-monix-newtype` module will provide implicit codecs and
schemas for types which extend `NewtypeWrapped` and `NewsubtypeWrapped` annotations as long as a codec and schema for its underlying value already exists:

```scala
"com.softwaremill.sttp.tapir" %% "tapir-monix-newtype" % "1.1.3"
```

Then, `import sttp.tapir.codec.monix.newtype._`, or extend the `sttp.tapir.codec.monix.newtype.TapirCodecMonixNewType` trait to bring the implicit values into scope.

## ZIO Prelude Newtype integration

If you use [ZIO Prelude Newtypes](https://zio.github.io/zio-prelude/docs/newtypes/), the `tapir-zio-prelude` module will provide implicit codecs and
schemas for types defined using `Newtype` and `Subtype` as long as a codec and a schema for the underlying type already exists:

```scala
"com.softwaremill.sttp.tapir" %% "tapir-zio-prelude" % "1.1.3"
```

Then, mix in `sttp.tapir.codec.zio.prelude.newtype.TapirNewtypeSupport` into your newtype to bring the implicit values into scope:

```scala
import sttp.tapir.Codec.PlainCodec
import sttp.tapir.Schema
import sttp.tapir.codec.zio.prelude.newtype.TapirNewtypeSupport
import zio.prelude.Newtype

object Foo extends Newtype[String] with TapirNewtypeSupport[String]
type Foo = Foo.Type

implicitly[Schema[Foo]]
implicitly[PlainCodec[Foo]]
```

Or use the `TapirNewtype` helper to derive a codec or a schema without modifying the newtype:
```scala
import sttp.tapir.codec.zio.prelude.newtype.TapirNewtype

object Bar extends Newtype[String]
type Bar = Bar.Type

// Explicitly provide the base type of your newtype when instantiating the helper, in this case, String.
val BarSupport = TapirNewtype[String](Bar)
import BarSupport._
implicitly[Schema[Bar]]
implicitly[PlainCodec[Bar]]
```

## Derevo integration

The `tapir-derevo` module provides a way to derive schema for your type using `@derive` annotation.
For details refer to [derevo documentation](https://github.com/tofu-tf/derevo#installation).
To use, add the following dependency:

```scala
"com.softwaremill.sttp.tapir" %% "tapir-derevo" % "1.1.3"
```

Then you can derive schema for your ADT along with other typeclasses besides ADT declaration itself:

```scala
import derevo.derive
import sttp.tapir.derevo.schema

@derive(schema)
case class Person(name: String, age: Int)

//or with custom description

@derive(schema("Type of currency in the country"))
sealed trait Currency
  object Currency {case object CommunisticCurrency extends Currency
  case class USD(amount: Long) extends Currency
}
```

The annotation will simply generate a `Schema[T]` for your type `T` and put it into companion object.
Generation rules are the same as in `Schema.derived[T]`.

This will also work for newtypes â€” [estatico](https://github.com/estatico/scala-newtype) or [supertagged](https://github.com/rudogma/scala-supertagged):

```scala
import derevo.derive
import sttp.tapir.derevo.schema
import io.estatico.newtype.macros.newtype

object types {
  @derive(schema)
  @newtype
  case class Amount(i: Int)
}
```

Resulting schema will be equivalent to `implicitly[Schema[Int]].map(i => Some(types.Amount(i)))`.
Note that due to limitations of the `derevo` library one can't provide custom description for generated schema.

## Next

Read on about [serving static content](static.md).
